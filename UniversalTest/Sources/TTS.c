#include "TTS.h"

static void CVIFUNC _ISpeechVoiceEventsRegOnStartStream_EventVTableFunc (void *thisPtr,
                                                                         long streamNumber,
                                                                         VARIANT streamPosition);

static void CVIFUNC _ISpeechVoiceEventsRegOnEndStream_EventVTableFunc (void *thisPtr,
                                                                       long streamNumber,
                                                                       VARIANT streamPosition);

static void CVIFUNC _ISpeechVoiceEventsRegOnVoiceChange_EventVTableFunc (void *thisPtr,
                                                                         long streamNumber,
                                                                         VARIANT streamPosition,
                                                                         LPDISPATCH voiceObjectToken);

static void CVIFUNC _ISpeechVoiceEventsRegOnBookmark_EventVTableFunc (void *thisPtr,
                                                                      long streamNumber,
                                                                      VARIANT streamPosition,
                                                                      BSTR bookmark,
                                                                      long bookmarkId);

static void CVIFUNC _ISpeechVoiceEventsRegOnWord_EventVTableFunc (void *thisPtr,
                                                                  long streamNumber,
                                                                  VARIANT streamPosition,
                                                                  long characterPosition,
                                                                  long length);

static void CVIFUNC _ISpeechVoiceEventsRegOnSentence_EventVTableFunc (void *thisPtr,
                                                                      long streamNumber,
                                                                      VARIANT streamPosition,
                                                                      long characterPosition,
                                                                      long length);

static void CVIFUNC _ISpeechVoiceEventsRegOnPhoneme_EventVTableFunc (void *thisPtr,
                                                                     long streamNumber,
                                                                     VARIANT streamPosition,
                                                                     long duration,
                                                                     short nextPhoneId,
                                                                     long feature,
                                                                     short currentPhoneId);

static void CVIFUNC _ISpeechVoiceEventsRegOnViseme_EventVTableFunc (void *thisPtr,
                                                                    long streamNumber,
                                                                    VARIANT streamPosition,
                                                                    long duration,
                                                                    long nextVisemeId,
                                                                    long feature,
                                                                    long currentVisemeId);

static void CVIFUNC _ISpeechVoiceEventsRegOnAudioLevel_EventVTableFunc (void *thisPtr,
                                                                        long streamNumber,
                                                                        VARIANT streamPosition,
                                                                        long audioLevel);

static void CVIFUNC _ISpeechVoiceEventsRegOnEnginePrivate_EventVTableFunc (void *thisPtr,
                                                                           long streamNumber,
                                                                           long streamPosition,
                                                                           VARIANT engineData);

static void CVIFUNC _ISpeechRecoContextEventsRegOnStartStream_EventVTableFunc (void *thisPtr,
                                                                               long streamNumber,
                                                                               VARIANT streamPosition);

static void CVIFUNC _ISpeechRecoContextEventsRegOnEndStream_EventVTableFunc (void *thisPtr,
                                                                             long streamNumber,
                                                                             VARIANT streamPosition,
                                                                             VBOOL streamReleased);

static void CVIFUNC _ISpeechRecoContextEventsRegOnBookmark_EventVTableFunc (void *thisPtr,
                                                                            long streamNumber,
                                                                            VARIANT streamPosition,
                                                                            VARIANT bookmarkId,
                                                                            long options);

static void CVIFUNC _ISpeechRecoContextEventsRegOnSoundStart_EventVTableFunc (void *thisPtr,
                                                                              long streamNumber,
                                                                              VARIANT streamPosition);

static void CVIFUNC _ISpeechRecoContextEventsRegOnSoundEnd_EventVTableFunc (void *thisPtr,
                                                                            long streamNumber,
                                                                            VARIANT streamPosition);

static void CVIFUNC _ISpeechRecoContextEventsRegOnPhraseStart_EventVTableFunc (void *thisPtr,
                                                                               long streamNumber,
                                                                               VARIANT streamPosition);

static void CVIFUNC _ISpeechRecoContextEventsRegOnRecognition_EventVTableFunc (void *thisPtr,
                                                                               long streamNumber,
                                                                               VARIANT streamPosition,
                                                                               long recognitionType,
                                                                               LPDISPATCH result);

static void CVIFUNC _ISpeechRecoContextEventsRegOnHypothesis_EventVTableFunc (void *thisPtr,
                                                                              long streamNumber,
                                                                              VARIANT streamPosition,
                                                                              LPDISPATCH result);

static void CVIFUNC _ISpeechRecoContextEventsRegOnPropertyNumberChange_EventVTableFunc (void *thisPtr,
                                                                                        long streamNumber,
                                                                                        VARIANT streamPosition,
                                                                                        BSTR propertyName,
                                                                                        long newNumberValue);

static void CVIFUNC _ISpeechRecoContextEventsRegOnPropertyStringChange_EventVTableFunc (void *thisPtr,
                                                                                        long streamNumber,
                                                                                        VARIANT streamPosition,
                                                                                        BSTR propertyName,
                                                                                        BSTR newStringValue);

static void CVIFUNC _ISpeechRecoContextEventsRegOnFalseRecognition_EventVTableFunc (void *thisPtr,
                                                                                    long streamNumber,
                                                                                    VARIANT streamPosition,
                                                                                    LPDISPATCH result);

static void CVIFUNC _ISpeechRecoContextEventsRegOnInterference_EventVTableFunc (void *thisPtr,
                                                                                long streamNumber,
                                                                                VARIANT streamPosition,
                                                                                long interference);

static void CVIFUNC _ISpeechRecoContextEventsRegOnRequestUI_EventVTableFunc (void *thisPtr,
                                                                             long streamNumber,
                                                                             VARIANT streamPosition,
                                                                             BSTR UIType);

static void CVIFUNC _ISpeechRecoContextEventsRegOnRecognizerStateChange_EventVTableFunc (void *thisPtr,
                                                                                         long streamNumber,
                                                                                         VARIANT streamPosition,
                                                                                         long newState);

static void CVIFUNC _ISpeechRecoContextEventsRegOnAdaptation_EventVTableFunc (void *thisPtr,
                                                                              long streamNumber,
                                                                              VARIANT streamPosition);

static void CVIFUNC _ISpeechRecoContextEventsRegOnRecognitionForOtherContext_EventVTableFunc (void *thisPtr,
                                                                                              long streamNumber,
                                                                                              VARIANT streamPosition);

static void CVIFUNC _ISpeechRecoContextEventsRegOnAudioLevel_EventVTableFunc (void *thisPtr,
                                                                              long streamNumber,
                                                                              VARIANT streamPosition,
                                                                              long audioLevel);

static void CVIFUNC _ISpeechRecoContextEventsRegOnEnginePrivate_EventVTableFunc (void *thisPtr,
                                                                                 long streamNumber,
                                                                                 VARIANT streamPosition,
                                                                                 VARIANT engineData);

typedef interface tagSpeechLib_ISpNotifyTranslator_Interface SpeechLib_ISpNotifyTranslator_Interface;

typedef struct tagSpeechLib_ISpNotifyTranslator_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpNotifyTranslator_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpNotifyTranslator_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpNotifyTranslator_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Notify_) (SpeechLib_ISpNotifyTranslator_Interface __RPC_FAR *This);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder2) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder3) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder4) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InitWin32Event_) (SpeechLib_ISpNotifyTranslator_Interface __RPC_FAR *This, 
	                                                         void *hEvent, 
	                                                         long fCloseHandleOnRelease);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Wait_) (SpeechLib_ISpNotifyTranslator_Interface __RPC_FAR *This, 
	                                               unsigned long dwMilliseconds);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEventHandle_) (SpeechLib_ISpNotifyTranslator_Interface __RPC_FAR *This);

} SpeechLib_ISpNotifyTranslator_VTable;

typedef interface tagSpeechLib_ISpNotifyTranslator_Interface
{
	CONST_VTBL SpeechLib_ISpNotifyTranslator_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpNotifyTranslator_Interface;

typedef interface tagSpeechLib_ISpeechObjectTokenCategory_Interface SpeechLib_ISpeechObjectTokenCategory_Interface;

typedef struct tagSpeechLib_ISpeechObjectTokenCategory_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpeechObjectTokenCategory_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpeechObjectTokenCategory_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpeechObjectTokenCategory_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( SpeechLib_ISpeechObjectTokenCategory_Interface __RPC_FAR * This, 
	                                                           UINT __RPC_FAR *pctinfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( SpeechLib_ISpeechObjectTokenCategory_Interface __RPC_FAR * This, 
	                                                      UINT iTInfo, 
	                                                      LCID lcid, 
	                                                      ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( SpeechLib_ISpeechObjectTokenCategory_Interface __RPC_FAR * This, 
	                                                        REFIID riid, 
	                                                        LPOLESTR __RPC_FAR *rgszNames, 
	                                                        UINT cNames, 
	                                                        LCID lcid, 
	                                                        DISPID __RPC_FAR *rgDispId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( SpeechLib_ISpeechObjectTokenCategory_Interface __RPC_FAR * This, 
	                                                 DISPID dispIdMember, 
	                                                 REFIID riid, 
	                                                 LCID lcid, 
	                                                 WORD wFlags, 
	                                                 DISPPARAMS __RPC_FAR *pDispParams, 
	                                                 VARIANT __RPC_FAR *pVarResult, 
	                                                 EXCEPINFO __RPC_FAR *pExcepInfo, 
	                                                 UINT __RPC_FAR *puArgErr);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetId_) (SpeechLib_ISpeechObjectTokenCategory_Interface __RPC_FAR *This, 
	                                                BSTR *id);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDefault_) (SpeechLib_ISpeechObjectTokenCategory_Interface __RPC_FAR *This, 
	                                                     BSTR tokenId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDefault_) (SpeechLib_ISpeechObjectTokenCategory_Interface __RPC_FAR *This, 
	                                                     BSTR *tokenId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetId_) (SpeechLib_ISpeechObjectTokenCategory_Interface __RPC_FAR *This, 
	                                                BSTR id, 
	                                                VBOOL createIfNotExist);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDataKey_) (SpeechLib_ISpeechObjectTokenCategory_Interface __RPC_FAR *This, 
	                                                     long location, 
	                                                     LPDISPATCH *dataKey);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumerateTokens_) (SpeechLib_ISpeechObjectTokenCategory_Interface __RPC_FAR *This, 
	                                                          BSTR requiredAttributes, 
	                                                          BSTR optionalAttributes, 
	                                                          LPDISPATCH *tokens);

} SpeechLib_ISpeechObjectTokenCategory_VTable;

typedef interface tagSpeechLib_ISpeechObjectTokenCategory_Interface
{
	CONST_VTBL SpeechLib_ISpeechObjectTokenCategory_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpeechObjectTokenCategory_Interface;

typedef interface tagSpeechLib_ISpObjectTokenCategory_Interface SpeechLib_ISpObjectTokenCategory_Interface;

typedef struct tagSpeechLib_ISpObjectTokenCategory_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpObjectTokenCategory_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpObjectTokenCategory_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpObjectTokenCategory_Interface __RPC_FAR * This);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder1) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder2) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder3) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder4) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder5) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder6) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder7) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder8) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder9) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder10) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder11) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder12) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder13) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder14) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDataKey_) (SpeechLib_ISpObjectTokenCategory_Interface __RPC_FAR *This, 
	                                                     long spdkl, 
	                                                     LPUNKNOWN *ppDataKey);

} SpeechLib_ISpObjectTokenCategory_VTable;

typedef interface tagSpeechLib_ISpObjectTokenCategory_Interface
{
	CONST_VTBL SpeechLib_ISpObjectTokenCategory_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpObjectTokenCategory_Interface;

typedef interface tagSpeechLib_ISpeechObjectToken_Interface SpeechLib_ISpeechObjectToken_Interface;

typedef struct tagSpeechLib_ISpeechObjectToken_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpeechObjectToken_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpeechObjectToken_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpeechObjectToken_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( SpeechLib_ISpeechObjectToken_Interface __RPC_FAR * This, 
	                                                           UINT __RPC_FAR *pctinfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( SpeechLib_ISpeechObjectToken_Interface __RPC_FAR * This, 
	                                                      UINT iTInfo, 
	                                                      LCID lcid, 
	                                                      ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( SpeechLib_ISpeechObjectToken_Interface __RPC_FAR * This, 
	                                                        REFIID riid, 
	                                                        LPOLESTR __RPC_FAR *rgszNames, 
	                                                        UINT cNames, 
	                                                        LCID lcid, 
	                                                        DISPID __RPC_FAR *rgDispId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( SpeechLib_ISpeechObjectToken_Interface __RPC_FAR * This, 
	                                                 DISPID dispIdMember, 
	                                                 REFIID riid, 
	                                                 LCID lcid, 
	                                                 WORD wFlags, 
	                                                 DISPPARAMS __RPC_FAR *pDispParams, 
	                                                 VARIANT __RPC_FAR *pVarResult, 
	                                                 EXCEPINFO __RPC_FAR *pExcepInfo, 
	                                                 UINT __RPC_FAR *puArgErr);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetId_) (SpeechLib_ISpeechObjectToken_Interface __RPC_FAR *This, 
	                                                BSTR *objectId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDataKey_) (SpeechLib_ISpeechObjectToken_Interface __RPC_FAR *This, 
	                                                     LPDISPATCH *dataKey);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCategory_) (SpeechLib_ISpeechObjectToken_Interface __RPC_FAR *This, 
	                                                      LPDISPATCH *category);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDescription_) (SpeechLib_ISpeechObjectToken_Interface __RPC_FAR *This, 
	                                                         long locale, 
	                                                         BSTR *description);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetId_) (SpeechLib_ISpeechObjectToken_Interface __RPC_FAR *This, 
	                                                BSTR id, 
	                                                BSTR categoryID, 
	                                                VBOOL createIfNotExist);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAttribute_) (SpeechLib_ISpeechObjectToken_Interface __RPC_FAR *This, 
	                                                       BSTR attributeName, 
	                                                       BSTR *attributeValue);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateInstance_) (SpeechLib_ISpeechObjectToken_Interface __RPC_FAR *This, 
	                                                         LPUNKNOWN pUnkOuter, 
	                                                         long clsContext, 
	                                                         LPUNKNOWN *object);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Remove_) (SpeechLib_ISpeechObjectToken_Interface __RPC_FAR *This, 
	                                                 BSTR objectStorageCLSID);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStorageFileName_) (SpeechLib_ISpeechObjectToken_Interface __RPC_FAR *This, 
	                                                             BSTR objectStorageCLSID, 
	                                                             BSTR keyName, 
	                                                             BSTR fileName, 
	                                                             long folder, 
	                                                             BSTR *filePath);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveStorageFileName_) (SpeechLib_ISpeechObjectToken_Interface __RPC_FAR *This, 
	                                                                BSTR objectStorageCLSID, 
	                                                                BSTR keyName, 
	                                                                VBOOL deleteFile);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsUISupported_) (SpeechLib_ISpeechObjectToken_Interface __RPC_FAR *This, 
	                                                        BSTR typeOfUI, 
	                                                        VARIANT *extraData, 
	                                                        LPUNKNOWN object, 
	                                                        VBOOL *supported);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DisplayUI_) (SpeechLib_ISpeechObjectToken_Interface __RPC_FAR *This, 
	                                                    long hWnd, 
	                                                    BSTR title, 
	                                                    BSTR typeOfUI, 
	                                                    VARIANT *extraData, 
	                                                    LPUNKNOWN object);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MatchesAttributes_) (SpeechLib_ISpeechObjectToken_Interface __RPC_FAR *This, 
	                                                            BSTR attributes, 
	                                                            VBOOL *matches);

} SpeechLib_ISpeechObjectToken_VTable;

typedef interface tagSpeechLib_ISpeechObjectToken_Interface
{
	CONST_VTBL SpeechLib_ISpeechObjectToken_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpeechObjectToken_Interface;

typedef interface tagSpeechLib_ISpObjectToken_Interface SpeechLib_ISpObjectToken_Interface;

typedef struct tagSpeechLib_ISpObjectToken_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpObjectToken_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpObjectToken_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpObjectToken_Interface __RPC_FAR * This);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder1) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder2) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder3) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder4) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder5) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder6) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder7) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder8) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder9) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder10) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder11) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder12) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder13) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder14) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCategory_) (SpeechLib_ISpObjectToken_Interface __RPC_FAR *This, 
	                                                      LPUNKNOWN *ppTokenCategory);

} SpeechLib_ISpObjectToken_VTable;

typedef interface tagSpeechLib_ISpObjectToken_Interface
{
	CONST_VTBL SpeechLib_ISpObjectToken_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpObjectToken_Interface;

typedef interface tagSpeechLib_ISpStreamFormatConverter_Interface SpeechLib_ISpStreamFormatConverter_Interface;

typedef struct tagSpeechLib_ISpStreamFormatConverter_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpStreamFormatConverter_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpStreamFormatConverter_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpStreamFormatConverter_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoteRead_) (SpeechLib_ISpStreamFormatConverter_Interface __RPC_FAR *This, 
	                                                     unsigned char *pv, 
	                                                     unsigned long cb, 
	                                                     unsigned long *pcbRead);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoteWrite_) (SpeechLib_ISpStreamFormatConverter_Interface __RPC_FAR *This, 
	                                                      unsigned char *pv, 
	                                                      unsigned long cb, 
	                                                      unsigned long *pcbWritten);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder3) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder4) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder5) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Commit_) (SpeechLib_ISpStreamFormatConverter_Interface __RPC_FAR *This, 
	                                                 unsigned long grfCommitFlags);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Revert_) (SpeechLib_ISpStreamFormatConverter_Interface __RPC_FAR *This);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder8) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder9) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder10) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone_) (SpeechLib_ISpStreamFormatConverter_Interface __RPC_FAR *This, 
	                                                LPUNKNOWN *ppstm);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder12) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBaseStream_) (SpeechLib_ISpStreamFormatConverter_Interface __RPC_FAR *This, 
	                                                        LPUNKNOWN pStream, 
	                                                        long fSetFormatToBaseStreamFormat, 
	                                                        long fWriteToBaseStream);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBaseStream_) (SpeechLib_ISpStreamFormatConverter_Interface __RPC_FAR *This, 
	                                                        LPUNKNOWN *ppStream);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder15) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResetSeekPosition_) (SpeechLib_ISpStreamFormatConverter_Interface __RPC_FAR *This);

} SpeechLib_ISpStreamFormatConverter_VTable;

typedef interface tagSpeechLib_ISpStreamFormatConverter_Interface
{
	CONST_VTBL SpeechLib_ISpStreamFormatConverter_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpStreamFormatConverter_Interface;

typedef interface tagSpeechLib_IEnumSpObjectTokens_Interface SpeechLib_IEnumSpObjectTokens_Interface;

typedef struct tagSpeechLib_IEnumSpObjectTokens_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_IEnumSpObjectTokens_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_IEnumSpObjectTokens_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_IEnumSpObjectTokens_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next_) (SpeechLib_IEnumSpObjectTokens_Interface __RPC_FAR *This, 
	                                               unsigned long celt, 
	                                               LPUNKNOWN *pelt, 
	                                               unsigned long *pceltFetched);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip_) (SpeechLib_IEnumSpObjectTokens_Interface __RPC_FAR *This, 
	                                               unsigned long celt);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset_) (SpeechLib_IEnumSpObjectTokens_Interface __RPC_FAR *This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone_) (SpeechLib_IEnumSpObjectTokens_Interface __RPC_FAR *This, 
	                                                LPUNKNOWN *ppEnum);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Item_) (SpeechLib_IEnumSpObjectTokens_Interface __RPC_FAR *This, 
	                                               unsigned long index, 
	                                               LPUNKNOWN *ppToken);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount_) (SpeechLib_IEnumSpObjectTokens_Interface __RPC_FAR *This, 
	                                                   unsigned long *pCount);

} SpeechLib_IEnumSpObjectTokens_VTable;

typedef interface tagSpeechLib_IEnumSpObjectTokens_Interface
{
	CONST_VTBL SpeechLib_IEnumSpObjectTokens_VTable __RPC_FAR *lpVtbl;
} SpeechLib_IEnumSpObjectTokens_Interface;

typedef interface tagSpeechLib_ISpeechMMSysAudio_Interface SpeechLib_ISpeechMMSysAudio_Interface;

typedef struct tagSpeechLib_ISpeechMMSysAudio_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpeechMMSysAudio_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpeechMMSysAudio_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpeechMMSysAudio_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( SpeechLib_ISpeechMMSysAudio_Interface __RPC_FAR * This, 
	                                                           UINT __RPC_FAR *pctinfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( SpeechLib_ISpeechMMSysAudio_Interface __RPC_FAR * This, 
	                                                      UINT iTInfo, 
	                                                      LCID lcid, 
	                                                      ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( SpeechLib_ISpeechMMSysAudio_Interface __RPC_FAR * This, 
	                                                        REFIID riid, 
	                                                        LPOLESTR __RPC_FAR *rgszNames, 
	                                                        UINT cNames, 
	                                                        LCID lcid, 
	                                                        DISPID __RPC_FAR *rgDispId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( SpeechLib_ISpeechMMSysAudio_Interface __RPC_FAR * This, 
	                                                 DISPID dispIdMember, 
	                                                 REFIID riid, 
	                                                 LCID lcid, 
	                                                 WORD wFlags, 
	                                                 DISPPARAMS __RPC_FAR *pDispParams, 
	                                                 VARIANT __RPC_FAR *pVarResult, 
	                                                 EXCEPINFO __RPC_FAR *pExcepInfo, 
	                                                 UINT __RPC_FAR *puArgErr);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFormat_) (SpeechLib_ISpeechMMSysAudio_Interface __RPC_FAR *This, 
	                                                    LPDISPATCH *audioFormat);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetByRefFormat_) (SpeechLib_ISpeechMMSysAudio_Interface __RPC_FAR *This, 
	                                                         LPDISPATCH audioFormat);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Read_) (SpeechLib_ISpeechMMSysAudio_Interface __RPC_FAR *This, 
	                                               VARIANT *buffer, 
	                                               long numberOfBytes, 
	                                               long *bytesRead);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Write_) (SpeechLib_ISpeechMMSysAudio_Interface __RPC_FAR *This, 
	                                                VARIANT buffer, 
	                                                long *bytesWritten);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Seek_) (SpeechLib_ISpeechMMSysAudio_Interface __RPC_FAR *This, 
	                                               VARIANT position, 
	                                               long origin, 
	                                               VARIANT *newPosition);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatus_) (SpeechLib_ISpeechMMSysAudio_Interface __RPC_FAR *This, 
	                                                    LPDISPATCH *status);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBufferInfo_) (SpeechLib_ISpeechMMSysAudio_Interface __RPC_FAR *This, 
	                                                        LPDISPATCH *bufferInfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDefaultFormat_) (SpeechLib_ISpeechMMSysAudio_Interface __RPC_FAR *This, 
	                                                           LPDISPATCH *streamFormat);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetVolume_) (SpeechLib_ISpeechMMSysAudio_Interface __RPC_FAR *This, 
	                                                    long *volume);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetVolume_) (SpeechLib_ISpeechMMSysAudio_Interface __RPC_FAR *This, 
	                                                    long volume);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBufferNotifySize_) (SpeechLib_ISpeechMMSysAudio_Interface __RPC_FAR *This, 
	                                                              long *bufferNotifySize);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBufferNotifySize_) (SpeechLib_ISpeechMMSysAudio_Interface __RPC_FAR *This, 
	                                                              long bufferNotifySize);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEventHandle_) (SpeechLib_ISpeechMMSysAudio_Interface __RPC_FAR *This, 
	                                                         long *eventHandle);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetState_) (SpeechLib_ISpeechMMSysAudio_Interface __RPC_FAR *This, 
	                                                   long state);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDeviceId_) (SpeechLib_ISpeechMMSysAudio_Interface __RPC_FAR *This, 
	                                                      long *deviceId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDeviceId_) (SpeechLib_ISpeechMMSysAudio_Interface __RPC_FAR *This, 
	                                                      long deviceId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLineId_) (SpeechLib_ISpeechMMSysAudio_Interface __RPC_FAR *This, 
	                                                    long *lineId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLineId_) (SpeechLib_ISpeechMMSysAudio_Interface __RPC_FAR *This, 
	                                                    long lineId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMMHandle_) (SpeechLib_ISpeechMMSysAudio_Interface __RPC_FAR *This, 
	                                                      long *handle);

} SpeechLib_ISpeechMMSysAudio_VTable;

typedef interface tagSpeechLib_ISpeechMMSysAudio_Interface
{
	CONST_VTBL SpeechLib_ISpeechMMSysAudio_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpeechMMSysAudio_Interface;

typedef interface tagSpeechLib_ISpEventSource_Interface SpeechLib_ISpEventSource_Interface;

typedef struct tagSpeechLib_ISpEventSource_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpEventSource_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpEventSource_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpEventSource_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetNotifySink_) (SpeechLib_ISpEventSource_Interface __RPC_FAR *This, 
	                                                        LPUNKNOWN pNotifySink);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder2) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder3) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder4) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetNotifyWin32Event_) (SpeechLib_ISpEventSource_Interface __RPC_FAR *This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WaitForNotifyEvent_) (SpeechLib_ISpEventSource_Interface __RPC_FAR *This, 
	                                                             unsigned long dwMilliseconds);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNotifyEventHandle_) (SpeechLib_ISpEventSource_Interface __RPC_FAR *This);

} SpeechLib_ISpEventSource_VTable;

typedef interface tagSpeechLib_ISpEventSource_Interface
{
	CONST_VTBL SpeechLib_ISpEventSource_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpEventSource_Interface;

typedef interface tagSpeechLib_ISpObjectWithToken_Interface SpeechLib_ISpObjectWithToken_Interface;

typedef struct tagSpeechLib_ISpObjectWithToken_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpObjectWithToken_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpObjectWithToken_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpObjectWithToken_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetObjectToken_) (SpeechLib_ISpObjectWithToken_Interface __RPC_FAR *This, 
	                                                         LPUNKNOWN pToken);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetObjectToken_) (SpeechLib_ISpObjectWithToken_Interface __RPC_FAR *This, 
	                                                         LPUNKNOWN *ppToken);

} SpeechLib_ISpObjectWithToken_VTable;

typedef interface tagSpeechLib_ISpObjectWithToken_Interface
{
	CONST_VTBL SpeechLib_ISpObjectWithToken_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpObjectWithToken_Interface;

typedef interface tagSpeechLib_ISpMMSysAudio_Interface SpeechLib_ISpMMSysAudio_Interface;

typedef struct tagSpeechLib_ISpMMSysAudio_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpMMSysAudio_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpMMSysAudio_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpMMSysAudio_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoteRead_) (SpeechLib_ISpMMSysAudio_Interface __RPC_FAR *This, 
	                                                     unsigned char *pv, 
	                                                     unsigned long cb, 
	                                                     unsigned long *pcbRead);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoteWrite_) (SpeechLib_ISpMMSysAudio_Interface __RPC_FAR *This, 
	                                                      unsigned char *pv, 
	                                                      unsigned long cb, 
	                                                      unsigned long *pcbWritten);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder3) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder4) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder5) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Commit_) (SpeechLib_ISpMMSysAudio_Interface __RPC_FAR *This, 
	                                                 unsigned long grfCommitFlags);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Revert_) (SpeechLib_ISpMMSysAudio_Interface __RPC_FAR *This);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder8) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder9) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder10) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone_) (SpeechLib_ISpMMSysAudio_Interface __RPC_FAR *This, 
	                                                LPUNKNOWN *ppstm);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder12) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder13) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder14) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder15) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder16) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder17) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder18) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EventHandle_) (SpeechLib_ISpMMSysAudio_Interface __RPC_FAR *This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetVolumeLevel_) (SpeechLib_ISpMMSysAudio_Interface __RPC_FAR *This, 
	                                                         unsigned long *pLevel);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetVolumeLevel_) (SpeechLib_ISpMMSysAudio_Interface __RPC_FAR *This, 
	                                                         unsigned long level);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBufferNotifySize_) (SpeechLib_ISpMMSysAudio_Interface __RPC_FAR *This, 
	                                                              unsigned long *pcbSize);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBufferNotifySize_) (SpeechLib_ISpMMSysAudio_Interface __RPC_FAR *This, 
	                                                              unsigned long cbSize);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDeviceId_) (SpeechLib_ISpMMSysAudio_Interface __RPC_FAR *This, 
	                                                      unsigned long *puDeviceId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDeviceId_) (SpeechLib_ISpMMSysAudio_Interface __RPC_FAR *This, 
	                                                      unsigned long uDeviceId);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder26) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLineId_) (SpeechLib_ISpMMSysAudio_Interface __RPC_FAR *This, 
	                                                    unsigned long *puLineId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLineId_) (SpeechLib_ISpMMSysAudio_Interface __RPC_FAR *This, 
	                                                    unsigned long uLineId);

} SpeechLib_ISpMMSysAudio_VTable;

typedef interface tagSpeechLib_ISpMMSysAudio_Interface
{
	CONST_VTBL SpeechLib_ISpMMSysAudio_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpMMSysAudio_Interface;

typedef interface tagSpeechLib_ISpStream_Interface SpeechLib_ISpStream_Interface;

typedef struct tagSpeechLib_ISpStream_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpStream_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpStream_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpStream_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoteRead_) (SpeechLib_ISpStream_Interface __RPC_FAR *This, 
	                                                     unsigned char *pv, 
	                                                     unsigned long cb, 
	                                                     unsigned long *pcbRead);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoteWrite_) (SpeechLib_ISpStream_Interface __RPC_FAR *This, 
	                                                      unsigned char *pv, 
	                                                      unsigned long cb, 
	                                                      unsigned long *pcbWritten);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder3) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder4) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder5) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Commit_) (SpeechLib_ISpStream_Interface __RPC_FAR *This, 
	                                                 unsigned long grfCommitFlags);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Revert_) (SpeechLib_ISpStream_Interface __RPC_FAR *This);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder8) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder9) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder10) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone_) (SpeechLib_ISpStream_Interface __RPC_FAR *This, 
	                                                LPUNKNOWN *ppstm);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder12) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder13) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBaseStream_) (SpeechLib_ISpStream_Interface __RPC_FAR *This, 
	                                                        LPUNKNOWN *ppStream);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder15) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close_) (SpeechLib_ISpStream_Interface __RPC_FAR *This);

} SpeechLib_ISpStream_VTable;

typedef interface tagSpeechLib_ISpStream_Interface
{
	CONST_VTBL SpeechLib_ISpStream_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpStream_Interface;

typedef interface tagSpeechLib_ISpeechVoice_Interface SpeechLib_ISpeechVoice_Interface;

typedef struct tagSpeechLib_ISpeechVoice_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpeechVoice_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpeechVoice_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpeechVoice_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( SpeechLib_ISpeechVoice_Interface __RPC_FAR * This, 
	                                                           UINT __RPC_FAR *pctinfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( SpeechLib_ISpeechVoice_Interface __RPC_FAR * This, 
	                                                      UINT iTInfo, 
	                                                      LCID lcid, 
	                                                      ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( SpeechLib_ISpeechVoice_Interface __RPC_FAR * This, 
	                                                        REFIID riid, 
	                                                        LPOLESTR __RPC_FAR *rgszNames, 
	                                                        UINT cNames, 
	                                                        LCID lcid, 
	                                                        DISPID __RPC_FAR *rgDispId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( SpeechLib_ISpeechVoice_Interface __RPC_FAR * This, 
	                                                 DISPID dispIdMember, 
	                                                 REFIID riid, 
	                                                 LCID lcid, 
	                                                 WORD wFlags, 
	                                                 DISPPARAMS __RPC_FAR *pDispParams, 
	                                                 VARIANT __RPC_FAR *pVarResult, 
	                                                 EXCEPINFO __RPC_FAR *pExcepInfo, 
	                                                 UINT __RPC_FAR *puArgErr);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatus_) (SpeechLib_ISpeechVoice_Interface __RPC_FAR *This, 
	                                                    LPDISPATCH *status);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetVoice_) (SpeechLib_ISpeechVoice_Interface __RPC_FAR *This, 
	                                                   LPDISPATCH *voice);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetByRefVoice_) (SpeechLib_ISpeechVoice_Interface __RPC_FAR *This, 
	                                                        LPDISPATCH voice);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAudioOutput_) (SpeechLib_ISpeechVoice_Interface __RPC_FAR *This, 
	                                                         LPDISPATCH *audioOutput);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetByRefAudioOutput_) (SpeechLib_ISpeechVoice_Interface __RPC_FAR *This, 
	                                                              LPDISPATCH audioOutput);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAudioOutputStream_) (SpeechLib_ISpeechVoice_Interface __RPC_FAR *This, 
	                                                               LPDISPATCH *audioOutputStream);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetByRefAudioOutputStream_) (SpeechLib_ISpeechVoice_Interface __RPC_FAR *This, 
	                                                                    LPDISPATCH audioOutputStream);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRate_) (SpeechLib_ISpeechVoice_Interface __RPC_FAR *This, 
	                                                  long *rate);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRate_) (SpeechLib_ISpeechVoice_Interface __RPC_FAR *This, 
	                                                  long rate);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetVolume_) (SpeechLib_ISpeechVoice_Interface __RPC_FAR *This, 
	                                                    long *volume);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetVolume_) (SpeechLib_ISpeechVoice_Interface __RPC_FAR *This, 
	                                                    long volume);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAllowAudioOutputFormatChangesOnNextSet_) (SpeechLib_ISpeechVoice_Interface __RPC_FAR *This, 
	                                                                                    VBOOL allow);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAllowAudioOutputFormatChangesOnNextSet_) (SpeechLib_ISpeechVoice_Interface __RPC_FAR *This, 
	                                                                                    VBOOL *allow);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEventInterests_) (SpeechLib_ISpeechVoice_Interface __RPC_FAR *This, 
	                                                            long *eventInterestFlags);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEventInterests_) (SpeechLib_ISpeechVoice_Interface __RPC_FAR *This, 
	                                                            long eventInterestFlags);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPriority_) (SpeechLib_ISpeechVoice_Interface __RPC_FAR *This, 
	                                                      long priority);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPriority_) (SpeechLib_ISpeechVoice_Interface __RPC_FAR *This, 
	                                                      long *priority);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAlertBoundary_) (SpeechLib_ISpeechVoice_Interface __RPC_FAR *This, 
	                                                           long boundary);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAlertBoundary_) (SpeechLib_ISpeechVoice_Interface __RPC_FAR *This, 
	                                                           long *boundary);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSynchronousSpeakTimeout_) (SpeechLib_ISpeechVoice_Interface __RPC_FAR *This, 
	                                                                     long msTimeout);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSynchronousSpeakTimeout_) (SpeechLib_ISpeechVoice_Interface __RPC_FAR *This, 
	                                                                     long *msTimeout);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Speak_) (SpeechLib_ISpeechVoice_Interface __RPC_FAR *This, 
	                                                BSTR text, 
	                                                long flags, 
	                                                long *streamNumber);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SpeakStream_) (SpeechLib_ISpeechVoice_Interface __RPC_FAR *This, 
	                                                      LPDISPATCH stream, 
	                                                      long flags, 
	                                                      long *streamNumber);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Pause_) (SpeechLib_ISpeechVoice_Interface __RPC_FAR *This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Resume_) (SpeechLib_ISpeechVoice_Interface __RPC_FAR *This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip_) (SpeechLib_ISpeechVoice_Interface __RPC_FAR *This, 
	                                               BSTR type, 
	                                               long numItems, 
	                                               long *numSkipped);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetVoices_) (SpeechLib_ISpeechVoice_Interface __RPC_FAR *This, 
	                                                    BSTR requiredAttributes, 
	                                                    BSTR optionalAttributes, 
	                                                    LPDISPATCH *objectTokens);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAudioOutputs_) (SpeechLib_ISpeechVoice_Interface __RPC_FAR *This, 
	                                                          BSTR requiredAttributes, 
	                                                          BSTR optionalAttributes, 
	                                                          LPDISPATCH *objectTokens);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WaitUntilDone_) (SpeechLib_ISpeechVoice_Interface __RPC_FAR *This, 
	                                                        long msTimeout, 
	                                                        VBOOL *done);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SpeakCompleteEvent_) (SpeechLib_ISpeechVoice_Interface __RPC_FAR *This, 
	                                                             long *handle);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsUISupported_) (SpeechLib_ISpeechVoice_Interface __RPC_FAR *This, 
	                                                        BSTR typeOfUI, 
	                                                        VARIANT *extraData, 
	                                                        VBOOL *supported);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DisplayUI_) (SpeechLib_ISpeechVoice_Interface __RPC_FAR *This, 
	                                                    long hWndParent, 
	                                                    BSTR title, 
	                                                    BSTR typeOfUI, 
	                                                    VARIANT *extraData);

} SpeechLib_ISpeechVoice_VTable;

typedef interface tagSpeechLib_ISpeechVoice_Interface
{
	CONST_VTBL SpeechLib_ISpeechVoice_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpeechVoice_Interface;

typedef interface tagSpeechLib_ISpVoice_Interface SpeechLib_ISpVoice_Interface;

typedef struct tagSpeechLib_ISpVoice_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpVoice_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpVoice_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpVoice_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetNotifySink_) (SpeechLib_ISpVoice_Interface __RPC_FAR *This, 
	                                                        LPUNKNOWN pNotifySink);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder2) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder3) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder4) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetNotifyWin32Event_) (SpeechLib_ISpVoice_Interface __RPC_FAR *This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WaitForNotifyEvent_) (SpeechLib_ISpVoice_Interface __RPC_FAR *This, 
	                                                             unsigned long dwMilliseconds);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNotifyEventHandle_) (SpeechLib_ISpVoice_Interface __RPC_FAR *This);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder8) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder9) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder10) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOutput_) (SpeechLib_ISpVoice_Interface __RPC_FAR *This, 
	                                                    LPUNKNOWN pUnkOutput, 
	                                                    long fAllowFormatChanges);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOutputObjectToken_) (SpeechLib_ISpVoice_Interface __RPC_FAR *This, 
	                                                               LPUNKNOWN *ppObjectToken);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOutputStream_) (SpeechLib_ISpVoice_Interface __RPC_FAR *This, 
	                                                          LPUNKNOWN *ppStream);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Pause_) (SpeechLib_ISpVoice_Interface __RPC_FAR *This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Resume_) (SpeechLib_ISpVoice_Interface __RPC_FAR *This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetVoice_) (SpeechLib_ISpVoice_Interface __RPC_FAR *This, 
	                                                   LPUNKNOWN pToken);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetVoice_) (SpeechLib_ISpVoice_Interface __RPC_FAR *This, 
	                                                   LPUNKNOWN *ppToken);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder18) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SpeakStream_) (SpeechLib_ISpVoice_Interface __RPC_FAR *This, 
	                                                      LPUNKNOWN pStream, 
	                                                      unsigned long dwFlags, 
	                                                      unsigned long *pulStreamNumber);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder20) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder21) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPriority_) (SpeechLib_ISpVoice_Interface __RPC_FAR *This, 
	                                                      long ePriority);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPriority_) (SpeechLib_ISpVoice_Interface __RPC_FAR *This, 
	                                                      long *pePriority);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAlertBoundary_) (SpeechLib_ISpVoice_Interface __RPC_FAR *This, 
	                                                           long eBoundary);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAlertBoundary_) (SpeechLib_ISpVoice_Interface __RPC_FAR *This, 
	                                                           long *peBoundary);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRate_) (SpeechLib_ISpVoice_Interface __RPC_FAR *This, 
	                                                  long rateAdjust);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRate_) (SpeechLib_ISpVoice_Interface __RPC_FAR *This, 
	                                                  long *pRateAdjust);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetVolume_) (SpeechLib_ISpVoice_Interface __RPC_FAR *This, 
	                                                    unsigned short usVolume);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetVolume_) (SpeechLib_ISpVoice_Interface __RPC_FAR *This, 
	                                                    unsigned short *pusVolume);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WaitUntilDone_) (SpeechLib_ISpVoice_Interface __RPC_FAR *This, 
	                                                        unsigned long msTimeout);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSyncSpeakTimeout_) (SpeechLib_ISpVoice_Interface __RPC_FAR *This, 
	                                                              unsigned long msTimeout);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSyncSpeakTimeout_) (SpeechLib_ISpVoice_Interface __RPC_FAR *This, 
	                                                              unsigned long *pmsTimeout);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SpeakCompleteEvent_) (SpeechLib_ISpVoice_Interface __RPC_FAR *This);

} SpeechLib_ISpVoice_VTable;

typedef interface tagSpeechLib_ISpVoice_Interface
{
	CONST_VTBL SpeechLib_ISpVoice_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpVoice_Interface;

typedef interface tagSpeechLib_ISpPhoneticAlphabetSelection_Interface SpeechLib_ISpPhoneticAlphabetSelection_Interface;

typedef struct tagSpeechLib_ISpPhoneticAlphabetSelection_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpPhoneticAlphabetSelection_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpPhoneticAlphabetSelection_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpPhoneticAlphabetSelection_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsAlphabetUPS_) (SpeechLib_ISpPhoneticAlphabetSelection_Interface __RPC_FAR *This, 
	                                                        long *pfIsUPS);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAlphabetToUPS_) (SpeechLib_ISpPhoneticAlphabetSelection_Interface __RPC_FAR *This, 
	                                                           long fForceUPS);

} SpeechLib_ISpPhoneticAlphabetSelection_VTable;

typedef interface tagSpeechLib_ISpPhoneticAlphabetSelection_Interface
{
	CONST_VTBL SpeechLib_ISpPhoneticAlphabetSelection_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpPhoneticAlphabetSelection_Interface;

typedef interface tagSpeechLib_ISpeechRecoContext_Interface SpeechLib_ISpeechRecoContext_Interface;

typedef struct tagSpeechLib_ISpeechRecoContext_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpeechRecoContext_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpeechRecoContext_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpeechRecoContext_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( SpeechLib_ISpeechRecoContext_Interface __RPC_FAR * This, 
	                                                           UINT __RPC_FAR *pctinfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( SpeechLib_ISpeechRecoContext_Interface __RPC_FAR * This, 
	                                                      UINT iTInfo, 
	                                                      LCID lcid, 
	                                                      ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( SpeechLib_ISpeechRecoContext_Interface __RPC_FAR * This, 
	                                                        REFIID riid, 
	                                                        LPOLESTR __RPC_FAR *rgszNames, 
	                                                        UINT cNames, 
	                                                        LCID lcid, 
	                                                        DISPID __RPC_FAR *rgDispId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( SpeechLib_ISpeechRecoContext_Interface __RPC_FAR * This, 
	                                                 DISPID dispIdMember, 
	                                                 REFIID riid, 
	                                                 LCID lcid, 
	                                                 WORD wFlags, 
	                                                 DISPPARAMS __RPC_FAR *pDispParams, 
	                                                 VARIANT __RPC_FAR *pVarResult, 
	                                                 EXCEPINFO __RPC_FAR *pExcepInfo, 
	                                                 UINT __RPC_FAR *puArgErr);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRecognizer_) (SpeechLib_ISpeechRecoContext_Interface __RPC_FAR *This, 
	                                                        LPDISPATCH *recognizer);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAudioInputInterferenceStatus_) (SpeechLib_ISpeechRecoContext_Interface __RPC_FAR *This, 
	                                                                          long *interference);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRequestedUIType_) (SpeechLib_ISpeechRecoContext_Interface __RPC_FAR *This, 
	                                                             BSTR *UIType);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetByRefVoice_) (SpeechLib_ISpeechRecoContext_Interface __RPC_FAR *This, 
	                                                        LPDISPATCH voice);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetVoice_) (SpeechLib_ISpeechRecoContext_Interface __RPC_FAR *This, 
	                                                   LPDISPATCH *voice);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAllowVoiceFormatMatchingOnNextSet_) (SpeechLib_ISpeechRecoContext_Interface __RPC_FAR *This, 
	                                                                               VBOOL pAllow);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAllowVoiceFormatMatchingOnNextSet_) (SpeechLib_ISpeechRecoContext_Interface __RPC_FAR *This, 
	                                                                               VBOOL *pAllow);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetVoicePurgeEvent_) (SpeechLib_ISpeechRecoContext_Interface __RPC_FAR *This, 
	                                                             long eventInterest);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetVoicePurgeEvent_) (SpeechLib_ISpeechRecoContext_Interface __RPC_FAR *This, 
	                                                             long *eventInterest);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEventInterests_) (SpeechLib_ISpeechRecoContext_Interface __RPC_FAR *This, 
	                                                            long eventInterest);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEventInterests_) (SpeechLib_ISpeechRecoContext_Interface __RPC_FAR *This, 
	                                                            long *eventInterest);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCmdMaxAlternates_) (SpeechLib_ISpeechRecoContext_Interface __RPC_FAR *This, 
	                                                              long maxAlternates);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCmdMaxAlternates_) (SpeechLib_ISpeechRecoContext_Interface __RPC_FAR *This, 
	                                                              long *maxAlternates);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetState_) (SpeechLib_ISpeechRecoContext_Interface __RPC_FAR *This, 
	                                                   long state);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetState_) (SpeechLib_ISpeechRecoContext_Interface __RPC_FAR *This, 
	                                                   long *state);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRetainedAudio_) (SpeechLib_ISpeechRecoContext_Interface __RPC_FAR *This, 
	                                                           long option);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRetainedAudio_) (SpeechLib_ISpeechRecoContext_Interface __RPC_FAR *This, 
	                                                           long *option);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetByRefRetainedAudioFormat_) (SpeechLib_ISpeechRecoContext_Interface __RPC_FAR *This, 
	                                                                      LPDISPATCH format);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRetainedAudioFormat_) (SpeechLib_ISpeechRecoContext_Interface __RPC_FAR *This, 
	                                                                 LPDISPATCH *format);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Pause_) (SpeechLib_ISpeechRecoContext_Interface __RPC_FAR *This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Resume_) (SpeechLib_ISpeechRecoContext_Interface __RPC_FAR *This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateGrammar_) (SpeechLib_ISpeechRecoContext_Interface __RPC_FAR *This, 
	                                                        VARIANT grammarId, 
	                                                        LPDISPATCH *grammar);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateResultFromMemory_) (SpeechLib_ISpeechRecoContext_Interface __RPC_FAR *This, 
	                                                                 VARIANT *resultBlock, 
	                                                                 LPDISPATCH *result);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Bookmark_) (SpeechLib_ISpeechRecoContext_Interface __RPC_FAR *This, 
	                                                   long options, 
	                                                   VARIANT streamPos, 
	                                                   VARIANT bookmarkId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAdaptationData_) (SpeechLib_ISpeechRecoContext_Interface __RPC_FAR *This, 
	                                                            BSTR adaptationString);

} SpeechLib_ISpeechRecoContext_VTable;

typedef interface tagSpeechLib_ISpeechRecoContext_Interface
{
	CONST_VTBL SpeechLib_ISpeechRecoContext_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpeechRecoContext_Interface;

typedef interface tagSpeechLib_ISpRecoContext_Interface SpeechLib_ISpRecoContext_Interface;

typedef struct tagSpeechLib_ISpRecoContext_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpRecoContext_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpRecoContext_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpRecoContext_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetNotifySink_) (SpeechLib_ISpRecoContext_Interface __RPC_FAR *This, 
	                                                        LPUNKNOWN pNotifySink);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder2) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder3) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder4) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetNotifyWin32Event_) (SpeechLib_ISpRecoContext_Interface __RPC_FAR *This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WaitForNotifyEvent_) (SpeechLib_ISpRecoContext_Interface __RPC_FAR *This, 
	                                                             unsigned long dwMilliseconds);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNotifyEventHandle_) (SpeechLib_ISpRecoContext_Interface __RPC_FAR *This);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder8) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder9) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder10) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRecognizer_) (SpeechLib_ISpRecoContext_Interface __RPC_FAR *This, 
	                                                        LPUNKNOWN *ppRecognizer);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder12) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder13) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMaxAlternates_) (SpeechLib_ISpRecoContext_Interface __RPC_FAR *This, 
	                                                           unsigned long *pcAlternates);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMaxAlternates_) (SpeechLib_ISpRecoContext_Interface __RPC_FAR *This, 
	                                                           unsigned long cAlternates);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder16) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder17) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder18) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder19) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder20) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Pause_) (SpeechLib_ISpRecoContext_Interface __RPC_FAR *This, 
	                                                unsigned long dwReserved);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Resume_) (SpeechLib_ISpRecoContext_Interface __RPC_FAR *This, 
	                                                 unsigned long dwReserved);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetVoice_) (SpeechLib_ISpRecoContext_Interface __RPC_FAR *This, 
	                                                   LPUNKNOWN pVoice, 
	                                                   long fAllowFormatChanges);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetVoice_) (SpeechLib_ISpRecoContext_Interface __RPC_FAR *This, 
	                                                   LPUNKNOWN *ppVoice);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder25) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder26) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetContextState_) (SpeechLib_ISpRecoContext_Interface __RPC_FAR *This, 
	                                                          long eContextState);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetContextState_) (SpeechLib_ISpRecoContext_Interface __RPC_FAR *This, 
	                                                          long *peContextState);

} SpeechLib_ISpRecoContext_VTable;

typedef interface tagSpeechLib_ISpRecoContext_Interface
{
	CONST_VTBL SpeechLib_ISpRecoContext_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpRecoContext_Interface;

typedef interface tagSpeechLib_ISpRecoContext2_Interface SpeechLib_ISpRecoContext2_Interface;

typedef struct tagSpeechLib_ISpRecoContext2_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpRecoContext2_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpRecoContext2_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpRecoContext2_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetGrammarOptions_) (SpeechLib_ISpRecoContext2_Interface __RPC_FAR *This, 
	                                                            unsigned long eGrammarOptions);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetGrammarOptions_) (SpeechLib_ISpRecoContext2_Interface __RPC_FAR *This, 
	                                                            unsigned long *peGrammarOptions);

} SpeechLib_ISpRecoContext2_VTable;

typedef interface tagSpeechLib_ISpRecoContext2_Interface
{
	CONST_VTBL SpeechLib_ISpRecoContext2_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpRecoContext2_Interface;

typedef interface tagSpeechLib_ISpeechRecognizer_Interface SpeechLib_ISpeechRecognizer_Interface;

typedef struct tagSpeechLib_ISpeechRecognizer_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpeechRecognizer_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpeechRecognizer_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpeechRecognizer_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( SpeechLib_ISpeechRecognizer_Interface __RPC_FAR * This, 
	                                                           UINT __RPC_FAR *pctinfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( SpeechLib_ISpeechRecognizer_Interface __RPC_FAR * This, 
	                                                      UINT iTInfo, 
	                                                      LCID lcid, 
	                                                      ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( SpeechLib_ISpeechRecognizer_Interface __RPC_FAR * This, 
	                                                        REFIID riid, 
	                                                        LPOLESTR __RPC_FAR *rgszNames, 
	                                                        UINT cNames, 
	                                                        LCID lcid, 
	                                                        DISPID __RPC_FAR *rgDispId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( SpeechLib_ISpeechRecognizer_Interface __RPC_FAR * This, 
	                                                 DISPID dispIdMember, 
	                                                 REFIID riid, 
	                                                 LCID lcid, 
	                                                 WORD wFlags, 
	                                                 DISPPARAMS __RPC_FAR *pDispParams, 
	                                                 VARIANT __RPC_FAR *pVarResult, 
	                                                 EXCEPINFO __RPC_FAR *pExcepInfo, 
	                                                 UINT __RPC_FAR *puArgErr);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetByRefRecognizer_) (SpeechLib_ISpeechRecognizer_Interface __RPC_FAR *This, 
	                                                             LPDISPATCH recognizer);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRecognizer_) (SpeechLib_ISpeechRecognizer_Interface __RPC_FAR *This, 
	                                                        LPDISPATCH *recognizer);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAllowAudioInputFormatChangesOnNextSet_) (SpeechLib_ISpeechRecognizer_Interface __RPC_FAR *This, 
	                                                                                   VBOOL allow);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAllowAudioInputFormatChangesOnNextSet_) (SpeechLib_ISpeechRecognizer_Interface __RPC_FAR *This, 
	                                                                                   VBOOL *allow);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetByRefAudioInput_) (SpeechLib_ISpeechRecognizer_Interface __RPC_FAR *This, 
	                                                             LPDISPATCH audioInput);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAudioInput_) (SpeechLib_ISpeechRecognizer_Interface __RPC_FAR *This, 
	                                                        LPDISPATCH *audioInput);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetByRefAudioInputStream_) (SpeechLib_ISpeechRecognizer_Interface __RPC_FAR *This, 
	                                                                   LPDISPATCH audioInputStream);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAudioInputStream_) (SpeechLib_ISpeechRecognizer_Interface __RPC_FAR *This, 
	                                                              LPDISPATCH *audioInputStream);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIsShared_) (SpeechLib_ISpeechRecognizer_Interface __RPC_FAR *This, 
	                                                      VBOOL *shared);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetState_) (SpeechLib_ISpeechRecognizer_Interface __RPC_FAR *This, 
	                                                   long state);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetState_) (SpeechLib_ISpeechRecognizer_Interface __RPC_FAR *This, 
	                                                   long *state);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatus_) (SpeechLib_ISpeechRecognizer_Interface __RPC_FAR *This, 
	                                                    LPDISPATCH *status);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetByRefProfile_) (SpeechLib_ISpeechRecognizer_Interface __RPC_FAR *This, 
	                                                          LPDISPATCH profile);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProfile_) (SpeechLib_ISpeechRecognizer_Interface __RPC_FAR *This, 
	                                                     LPDISPATCH *profile);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EmulateRecognition_) (SpeechLib_ISpeechRecognizer_Interface __RPC_FAR *This, 
	                                                             VARIANT textElements, 
	                                                             VARIANT *elementDisplayAttributes, 
	                                                             long languageId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateRecoContext_) (SpeechLib_ISpeechRecognizer_Interface __RPC_FAR *This, 
	                                                            LPDISPATCH *newContext);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFormat_) (SpeechLib_ISpeechRecognizer_Interface __RPC_FAR *This, 
	                                                    long type, 
	                                                    LPDISPATCH *format);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPropertyNumber_) (SpeechLib_ISpeechRecognizer_Interface __RPC_FAR *This, 
	                                                            BSTR name, 
	                                                            long value, 
	                                                            VBOOL *supported);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropertyNumber_) (SpeechLib_ISpeechRecognizer_Interface __RPC_FAR *This, 
	                                                            BSTR name, 
	                                                            long *value, 
	                                                            VBOOL *supported);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPropertyString_) (SpeechLib_ISpeechRecognizer_Interface __RPC_FAR *This, 
	                                                            BSTR name, 
	                                                            BSTR value, 
	                                                            VBOOL *supported);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropertyString_) (SpeechLib_ISpeechRecognizer_Interface __RPC_FAR *This, 
	                                                            BSTR name, 
	                                                            BSTR *value, 
	                                                            VBOOL *supported);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsUISupported_) (SpeechLib_ISpeechRecognizer_Interface __RPC_FAR *This, 
	                                                        BSTR typeOfUI, 
	                                                        VARIANT *extraData, 
	                                                        VBOOL *supported);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DisplayUI_) (SpeechLib_ISpeechRecognizer_Interface __RPC_FAR *This, 
	                                                    long hWndParent, 
	                                                    BSTR title, 
	                                                    BSTR typeOfUI, 
	                                                    VARIANT *extraData);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRecognizers_) (SpeechLib_ISpeechRecognizer_Interface __RPC_FAR *This, 
	                                                         BSTR requiredAttributes, 
	                                                         BSTR optionalAttributes, 
	                                                         LPDISPATCH *objectTokens);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAudioInputs_) (SpeechLib_ISpeechRecognizer_Interface __RPC_FAR *This, 
	                                                         BSTR requiredAttributes, 
	                                                         BSTR optionalAttributes, 
	                                                         LPDISPATCH *objectTokens);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProfiles_) (SpeechLib_ISpeechRecognizer_Interface __RPC_FAR *This, 
	                                                      BSTR requiredAttributes, 
	                                                      BSTR optionalAttributes, 
	                                                      LPDISPATCH *objectTokens);

} SpeechLib_ISpeechRecognizer_VTable;

typedef interface tagSpeechLib_ISpeechRecognizer_Interface
{
	CONST_VTBL SpeechLib_ISpeechRecognizer_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpeechRecognizer_Interface;

typedef interface tagSpeechLib_ISpRecognizer_Interface SpeechLib_ISpRecognizer_Interface;

typedef struct tagSpeechLib_ISpRecognizer_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpRecognizer_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpRecognizer_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpRecognizer_Interface __RPC_FAR * This);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder1) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder2) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder3) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder4) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRecognizer_) (SpeechLib_ISpRecognizer_Interface __RPC_FAR *This, 
	                                                        LPUNKNOWN pRecognizer);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRecognizer_) (SpeechLib_ISpRecognizer_Interface __RPC_FAR *This, 
	                                                        LPUNKNOWN *ppRecognizer);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetInput_) (SpeechLib_ISpRecognizer_Interface __RPC_FAR *This, 
	                                                   LPUNKNOWN pUnkInput, 
	                                                   long fAllowFormatChanges);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInputObjectToken_) (SpeechLib_ISpRecognizer_Interface __RPC_FAR *This, 
	                                                              LPUNKNOWN *ppToken);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInputStream_) (SpeechLib_ISpRecognizer_Interface __RPC_FAR *This, 
	                                                         LPUNKNOWN *ppStream);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateRecoContext_) (SpeechLib_ISpRecognizer_Interface __RPC_FAR *This, 
	                                                            LPUNKNOWN *ppNewCtxt);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRecoProfile_) (SpeechLib_ISpRecognizer_Interface __RPC_FAR *This, 
	                                                         LPUNKNOWN *ppToken);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRecoProfile_) (SpeechLib_ISpRecognizer_Interface __RPC_FAR *This, 
	                                                         LPUNKNOWN pToken);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsSharedInstance_) (SpeechLib_ISpRecognizer_Interface __RPC_FAR *This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRecoState_) (SpeechLib_ISpRecognizer_Interface __RPC_FAR *This, 
	                                                       long *pState);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRecoState_) (SpeechLib_ISpRecognizer_Interface __RPC_FAR *This, 
	                                                       long newState);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder16) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder17) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder18) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder19) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EmulateRecognition_) (SpeechLib_ISpRecognizer_Interface __RPC_FAR *This, 
	                                                             LPUNKNOWN pPhrase);

} SpeechLib_ISpRecognizer_VTable;

typedef interface tagSpeechLib_ISpRecognizer_Interface
{
	CONST_VTBL SpeechLib_ISpRecognizer_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpRecognizer_Interface;

typedef interface tagSpeechLib_ISpRecognizer2_Interface SpeechLib_ISpRecognizer2_Interface;

typedef struct tagSpeechLib_ISpRecognizer2_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpRecognizer2_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpRecognizer2_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpRecognizer2_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EmulateRecognitionEx_) (SpeechLib_ISpRecognizer2_Interface __RPC_FAR *This, 
	                                                               LPUNKNOWN pPhrase, 
	                                                               unsigned long dwCompareFlags);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTrainingState_) (SpeechLib_ISpRecognizer2_Interface __RPC_FAR *This, 
	                                                           long fDoingTraining, 
	                                                           long fAdaptFromTrainingData);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResetAcousticModelAdaptation_) (SpeechLib_ISpRecognizer2_Interface __RPC_FAR *This);

} SpeechLib_ISpRecognizer2_VTable;

typedef interface tagSpeechLib_ISpRecognizer2_Interface
{
	CONST_VTBL SpeechLib_ISpRecognizer2_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpRecognizer2_Interface;

typedef interface tagSpeechLib_ISpRecognizer3_Interface SpeechLib_ISpRecognizer3_Interface;

typedef struct tagSpeechLib_ISpRecognizer3_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpRecognizer3_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpRecognizer3_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpRecognizer3_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCategory_) (SpeechLib_ISpRecognizer3_Interface __RPC_FAR *This, 
	                                                      long categoryType, 
	                                                      LPUNKNOWN *ppCategory);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetActiveCategory_) (SpeechLib_ISpRecognizer3_Interface __RPC_FAR *This, 
	                                                            LPUNKNOWN pCategory);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetActiveCategory_) (SpeechLib_ISpRecognizer3_Interface __RPC_FAR *This, 
	                                                            LPUNKNOWN *ppCategory);

} SpeechLib_ISpRecognizer3_VTable;

typedef interface tagSpeechLib_ISpRecognizer3_Interface
{
	CONST_VTBL SpeechLib_ISpRecognizer3_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpRecognizer3_Interface;

typedef interface tagSpeechLib_ISpSerializeState_Interface SpeechLib_ISpSerializeState_Interface;

typedef struct tagSpeechLib_ISpSerializeState_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpSerializeState_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpSerializeState_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpSerializeState_Interface __RPC_FAR * This);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder1) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSerializedState_) (SpeechLib_ISpSerializeState_Interface __RPC_FAR *This, 
	                                                             unsigned char *pbData, 
	                                                             unsigned long ulSize, 
	                                                             unsigned long dwReserved);

} SpeechLib_ISpSerializeState_VTable;

typedef interface tagSpeechLib_ISpSerializeState_Interface
{
	CONST_VTBL SpeechLib_ISpSerializeState_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpSerializeState_Interface;

typedef interface tagSpeechLib_ISpeechLexicon_Interface SpeechLib_ISpeechLexicon_Interface;

typedef struct tagSpeechLib_ISpeechLexicon_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpeechLexicon_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpeechLexicon_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpeechLexicon_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( SpeechLib_ISpeechLexicon_Interface __RPC_FAR * This, 
	                                                           UINT __RPC_FAR *pctinfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( SpeechLib_ISpeechLexicon_Interface __RPC_FAR * This, 
	                                                      UINT iTInfo, 
	                                                      LCID lcid, 
	                                                      ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( SpeechLib_ISpeechLexicon_Interface __RPC_FAR * This, 
	                                                        REFIID riid, 
	                                                        LPOLESTR __RPC_FAR *rgszNames, 
	                                                        UINT cNames, 
	                                                        LCID lcid, 
	                                                        DISPID __RPC_FAR *rgDispId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( SpeechLib_ISpeechLexicon_Interface __RPC_FAR * This, 
	                                                 DISPID dispIdMember, 
	                                                 REFIID riid, 
	                                                 LCID lcid, 
	                                                 WORD wFlags, 
	                                                 DISPPARAMS __RPC_FAR *pDispParams, 
	                                                 VARIANT __RPC_FAR *pVarResult, 
	                                                 EXCEPINFO __RPC_FAR *pExcepInfo, 
	                                                 UINT __RPC_FAR *puArgErr);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetGenerationId_) (SpeechLib_ISpeechLexicon_Interface __RPC_FAR *This, 
	                                                          long *generationId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetWords_) (SpeechLib_ISpeechLexicon_Interface __RPC_FAR *This, 
	                                                   long flags, 
	                                                   long *generationId, 
	                                                   LPDISPATCH *words);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddPronunciation_) (SpeechLib_ISpeechLexicon_Interface __RPC_FAR *This, 
	                                                           BSTR bstrWord, 
	                                                           long langId, 
	                                                           long partOfSpeech, 
	                                                           BSTR bstrPronunciation);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddPronunciationByPhoneIds_) (SpeechLib_ISpeechLexicon_Interface __RPC_FAR *This, 
	                                                                     BSTR bstrWord, 
	                                                                     long langId, 
	                                                                     long partOfSpeech, 
	                                                                     VARIANT *phoneIds);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemovePronunciation_) (SpeechLib_ISpeechLexicon_Interface __RPC_FAR *This, 
	                                                              BSTR bstrWord, 
	                                                              long langId, 
	                                                              long partOfSpeech, 
	                                                              BSTR bstrPronunciation);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemovePronunciationByPhoneIds_) (SpeechLib_ISpeechLexicon_Interface __RPC_FAR *This, 
	                                                                        BSTR bstrWord, 
	                                                                        long langId, 
	                                                                        long partOfSpeech, 
	                                                                        VARIANT *phoneIds);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPronunciations_) (SpeechLib_ISpeechLexicon_Interface __RPC_FAR *This, 
	                                                            BSTR bstrWord, 
	                                                            long langId, 
	                                                            long typeFlags, 
	                                                            LPDISPATCH *ppPronunciations);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetGenerationChange_) (SpeechLib_ISpeechLexicon_Interface __RPC_FAR *This, 
	                                                              long *generationId, 
	                                                              LPDISPATCH *ppWords);

} SpeechLib_ISpeechLexicon_VTable;

typedef interface tagSpeechLib_ISpeechLexicon_Interface
{
	CONST_VTBL SpeechLib_ISpeechLexicon_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpeechLexicon_Interface;

typedef interface tagSpeechLib_ISpLexicon_Interface SpeechLib_ISpLexicon_Interface;

typedef struct tagSpeechLib_ISpLexicon_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpLexicon_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpLexicon_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpLexicon_Interface __RPC_FAR * This);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder1) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder2) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder3) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetGeneration_) (SpeechLib_ISpLexicon_Interface __RPC_FAR *This, 
	                                                        unsigned long *pdwGeneration);

} SpeechLib_ISpLexicon_VTable;

typedef interface tagSpeechLib_ISpLexicon_Interface
{
	CONST_VTBL SpeechLib_ISpLexicon_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpLexicon_Interface;

typedef interface tagSpeechLib_ISpShortcut_Interface SpeechLib_ISpShortcut_Interface;

typedef struct tagSpeechLib_ISpShortcut_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpShortcut_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpShortcut_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpShortcut_Interface __RPC_FAR * This);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder1) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder2) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder3) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetGeneration_) (SpeechLib_ISpShortcut_Interface __RPC_FAR *This, 
	                                                        unsigned long *pdwGeneration);

} SpeechLib_ISpShortcut_VTable;

typedef interface tagSpeechLib_ISpShortcut_Interface
{
	CONST_VTBL SpeechLib_ISpShortcut_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpShortcut_Interface;

typedef interface tagSpeechLib_ISpeechPhoneConverter_Interface SpeechLib_ISpeechPhoneConverter_Interface;

typedef struct tagSpeechLib_ISpeechPhoneConverter_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpeechPhoneConverter_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpeechPhoneConverter_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpeechPhoneConverter_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( SpeechLib_ISpeechPhoneConverter_Interface __RPC_FAR * This, 
	                                                           UINT __RPC_FAR *pctinfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( SpeechLib_ISpeechPhoneConverter_Interface __RPC_FAR * This, 
	                                                      UINT iTInfo, 
	                                                      LCID lcid, 
	                                                      ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( SpeechLib_ISpeechPhoneConverter_Interface __RPC_FAR * This, 
	                                                        REFIID riid, 
	                                                        LPOLESTR __RPC_FAR *rgszNames, 
	                                                        UINT cNames, 
	                                                        LCID lcid, 
	                                                        DISPID __RPC_FAR *rgDispId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( SpeechLib_ISpeechPhoneConverter_Interface __RPC_FAR * This, 
	                                                 DISPID dispIdMember, 
	                                                 REFIID riid, 
	                                                 LCID lcid, 
	                                                 WORD wFlags, 
	                                                 DISPPARAMS __RPC_FAR *pDispParams, 
	                                                 VARIANT __RPC_FAR *pVarResult, 
	                                                 EXCEPINFO __RPC_FAR *pExcepInfo, 
	                                                 UINT __RPC_FAR *puArgErr);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLanguageId_) (SpeechLib_ISpeechPhoneConverter_Interface __RPC_FAR *This, 
	                                                        long *languageId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLanguageId_) (SpeechLib_ISpeechPhoneConverter_Interface __RPC_FAR *This, 
	                                                        long languageId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PhoneToId_) (SpeechLib_ISpeechPhoneConverter_Interface __RPC_FAR *This, 
	                                                    BSTR phonemes, 
	                                                    VARIANT *idArray);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IdToPhone_) (SpeechLib_ISpeechPhoneConverter_Interface __RPC_FAR *This, 
	                                                    VARIANT idArray, 
	                                                    BSTR *phonemes);

} SpeechLib_ISpeechPhoneConverter_VTable;

typedef interface tagSpeechLib_ISpeechPhoneConverter_Interface
{
	CONST_VTBL SpeechLib_ISpeechPhoneConverter_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpeechPhoneConverter_Interface;

typedef interface tagSpeechLib_ISpPhoneConverter_Interface SpeechLib_ISpPhoneConverter_Interface;

typedef struct tagSpeechLib_ISpPhoneConverter_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpPhoneConverter_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpPhoneConverter_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpPhoneConverter_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetObjectToken_) (SpeechLib_ISpPhoneConverter_Interface __RPC_FAR *This, 
	                                                         LPUNKNOWN pToken);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetObjectToken_) (SpeechLib_ISpPhoneConverter_Interface __RPC_FAR *This, 
	                                                         LPUNKNOWN *ppToken);

} SpeechLib_ISpPhoneConverter_VTable;

typedef interface tagSpeechLib_ISpPhoneConverter_Interface
{
	CONST_VTBL SpeechLib_ISpPhoneConverter_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpPhoneConverter_Interface;

typedef interface tagSpeechLib_ISpPhoneticAlphabetConverter_Interface SpeechLib_ISpPhoneticAlphabetConverter_Interface;

typedef struct tagSpeechLib_ISpPhoneticAlphabetConverter_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpPhoneticAlphabetConverter_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpPhoneticAlphabetConverter_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpPhoneticAlphabetConverter_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLangId_) (SpeechLib_ISpPhoneticAlphabetConverter_Interface __RPC_FAR *This, 
	                                                    unsigned short *pLangID);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLangId_) (SpeechLib_ISpPhoneticAlphabetConverter_Interface __RPC_FAR *This, 
	                                                    unsigned short langId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SAPI2UPS_) (SpeechLib_ISpPhoneticAlphabetConverter_Interface __RPC_FAR *This, 
	                                                   unsigned short *pszSAPIId, 
	                                                   unsigned short *pszUPSId, 
	                                                   unsigned long cMaxLength);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UPS2SAPI_) (SpeechLib_ISpPhoneticAlphabetConverter_Interface __RPC_FAR *This, 
	                                                   unsigned short *pszUPSId, 
	                                                   unsigned short *pszSAPIId, 
	                                                   unsigned long cMaxLength);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMaxConvertLength_) (SpeechLib_ISpPhoneticAlphabetConverter_Interface __RPC_FAR *This, 
	                                                              unsigned long cSrcLength, 
	                                                              long bSAPI2UPS, 
	                                                              unsigned long *pcMaxDestLength);

} SpeechLib_ISpPhoneticAlphabetConverter_VTable;

typedef interface tagSpeechLib_ISpPhoneticAlphabetConverter_Interface
{
	CONST_VTBL SpeechLib_ISpPhoneticAlphabetConverter_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpPhoneticAlphabetConverter_Interface;

typedef interface tagSpeechLib_ISpeechTextSelectionInformation_Interface SpeechLib_ISpeechTextSelectionInformation_Interface;

typedef struct tagSpeechLib_ISpeechTextSelectionInformation_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpeechTextSelectionInformation_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpeechTextSelectionInformation_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpeechTextSelectionInformation_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( SpeechLib_ISpeechTextSelectionInformation_Interface __RPC_FAR * This, 
	                                                           UINT __RPC_FAR *pctinfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( SpeechLib_ISpeechTextSelectionInformation_Interface __RPC_FAR * This, 
	                                                      UINT iTInfo, 
	                                                      LCID lcid, 
	                                                      ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( SpeechLib_ISpeechTextSelectionInformation_Interface __RPC_FAR * This, 
	                                                        REFIID riid, 
	                                                        LPOLESTR __RPC_FAR *rgszNames, 
	                                                        UINT cNames, 
	                                                        LCID lcid, 
	                                                        DISPID __RPC_FAR *rgDispId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( SpeechLib_ISpeechTextSelectionInformation_Interface __RPC_FAR * This, 
	                                                 DISPID dispIdMember, 
	                                                 REFIID riid, 
	                                                 LCID lcid, 
	                                                 WORD wFlags, 
	                                                 DISPPARAMS __RPC_FAR *pDispParams, 
	                                                 VARIANT __RPC_FAR *pVarResult, 
	                                                 EXCEPINFO __RPC_FAR *pExcepInfo, 
	                                                 UINT __RPC_FAR *puArgErr);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetActiveOffset_) (SpeechLib_ISpeechTextSelectionInformation_Interface __RPC_FAR *This, 
	                                                          long activeOffset);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetActiveOffset_) (SpeechLib_ISpeechTextSelectionInformation_Interface __RPC_FAR *This, 
	                                                          long *activeOffset);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetActiveLength_) (SpeechLib_ISpeechTextSelectionInformation_Interface __RPC_FAR *This, 
	                                                          long activeLength);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetActiveLength_) (SpeechLib_ISpeechTextSelectionInformation_Interface __RPC_FAR *This, 
	                                                          long *activeLength);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSelectionOffset_) (SpeechLib_ISpeechTextSelectionInformation_Interface __RPC_FAR *This, 
	                                                             long selectionOffset);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSelectionOffset_) (SpeechLib_ISpeechTextSelectionInformation_Interface __RPC_FAR *This, 
	                                                             long *selectionOffset);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSelectionLength_) (SpeechLib_ISpeechTextSelectionInformation_Interface __RPC_FAR *This, 
	                                                             long selectionLength);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSelectionLength_) (SpeechLib_ISpeechTextSelectionInformation_Interface __RPC_FAR *This, 
	                                                             long *selectionLength);

} SpeechLib_ISpeechTextSelectionInformation_VTable;

typedef interface tagSpeechLib_ISpeechTextSelectionInformation_Interface
{
	CONST_VTBL SpeechLib_ISpeechTextSelectionInformation_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpeechTextSelectionInformation_Interface;

typedef interface tagSpeechLib_ISpeechPhraseInfoBuilder_Interface SpeechLib_ISpeechPhraseInfoBuilder_Interface;

typedef struct tagSpeechLib_ISpeechPhraseInfoBuilder_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpeechPhraseInfoBuilder_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpeechPhraseInfoBuilder_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpeechPhraseInfoBuilder_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( SpeechLib_ISpeechPhraseInfoBuilder_Interface __RPC_FAR * This, 
	                                                           UINT __RPC_FAR *pctinfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( SpeechLib_ISpeechPhraseInfoBuilder_Interface __RPC_FAR * This, 
	                                                      UINT iTInfo, 
	                                                      LCID lcid, 
	                                                      ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( SpeechLib_ISpeechPhraseInfoBuilder_Interface __RPC_FAR * This, 
	                                                        REFIID riid, 
	                                                        LPOLESTR __RPC_FAR *rgszNames, 
	                                                        UINT cNames, 
	                                                        LCID lcid, 
	                                                        DISPID __RPC_FAR *rgDispId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( SpeechLib_ISpeechPhraseInfoBuilder_Interface __RPC_FAR * This, 
	                                                 DISPID dispIdMember, 
	                                                 REFIID riid, 
	                                                 LCID lcid, 
	                                                 WORD wFlags, 
	                                                 DISPPARAMS __RPC_FAR *pDispParams, 
	                                                 VARIANT __RPC_FAR *pVarResult, 
	                                                 EXCEPINFO __RPC_FAR *pExcepInfo, 
	                                                 UINT __RPC_FAR *puArgErr);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RestorePhraseFromMemory_) (SpeechLib_ISpeechPhraseInfoBuilder_Interface __RPC_FAR *This, 
	                                                                  VARIANT *phraseInMemory, 
	                                                                  LPDISPATCH *phraseInfo);

} SpeechLib_ISpeechPhraseInfoBuilder_VTable;

typedef interface tagSpeechLib_ISpeechPhraseInfoBuilder_Interface
{
	CONST_VTBL SpeechLib_ISpeechPhraseInfoBuilder_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpeechPhraseInfoBuilder_Interface;

typedef interface tagSpeechLib_ISpeechAudioFormat_Interface SpeechLib_ISpeechAudioFormat_Interface;

typedef struct tagSpeechLib_ISpeechAudioFormat_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpeechAudioFormat_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpeechAudioFormat_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpeechAudioFormat_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( SpeechLib_ISpeechAudioFormat_Interface __RPC_FAR * This, 
	                                                           UINT __RPC_FAR *pctinfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( SpeechLib_ISpeechAudioFormat_Interface __RPC_FAR * This, 
	                                                      UINT iTInfo, 
	                                                      LCID lcid, 
	                                                      ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( SpeechLib_ISpeechAudioFormat_Interface __RPC_FAR * This, 
	                                                        REFIID riid, 
	                                                        LPOLESTR __RPC_FAR *rgszNames, 
	                                                        UINT cNames, 
	                                                        LCID lcid, 
	                                                        DISPID __RPC_FAR *rgDispId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( SpeechLib_ISpeechAudioFormat_Interface __RPC_FAR * This, 
	                                                 DISPID dispIdMember, 
	                                                 REFIID riid, 
	                                                 LCID lcid, 
	                                                 WORD wFlags, 
	                                                 DISPPARAMS __RPC_FAR *pDispParams, 
	                                                 VARIANT __RPC_FAR *pVarResult, 
	                                                 EXCEPINFO __RPC_FAR *pExcepInfo, 
	                                                 UINT __RPC_FAR *puArgErr);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType_) (SpeechLib_ISpeechAudioFormat_Interface __RPC_FAR *This, 
	                                                  long *audioFormat);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetType_) (SpeechLib_ISpeechAudioFormat_Interface __RPC_FAR *This, 
	                                                  long audioFormat);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetGuid_) (SpeechLib_ISpeechAudioFormat_Interface __RPC_FAR *This, 
	                                                  BSTR *guid);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetGuid_) (SpeechLib_ISpeechAudioFormat_Interface __RPC_FAR *This, 
	                                                  BSTR guid);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetWaveFormatEx_) (SpeechLib_ISpeechAudioFormat_Interface __RPC_FAR *This, 
	                                                          LPDISPATCH *speechWaveFormatEx);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetWaveFormatEx_) (SpeechLib_ISpeechAudioFormat_Interface __RPC_FAR *This, 
	                                                          LPDISPATCH speechWaveFormatEx);

} SpeechLib_ISpeechAudioFormat_VTable;

typedef interface tagSpeechLib_ISpeechAudioFormat_Interface
{
	CONST_VTBL SpeechLib_ISpeechAudioFormat_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpeechAudioFormat_Interface;

typedef interface tagSpeechLib_ISpeechWaveFormatEx_Interface SpeechLib_ISpeechWaveFormatEx_Interface;

typedef struct tagSpeechLib_ISpeechWaveFormatEx_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpeechWaveFormatEx_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpeechWaveFormatEx_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpeechWaveFormatEx_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( SpeechLib_ISpeechWaveFormatEx_Interface __RPC_FAR * This, 
	                                                           UINT __RPC_FAR *pctinfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( SpeechLib_ISpeechWaveFormatEx_Interface __RPC_FAR * This, 
	                                                      UINT iTInfo, 
	                                                      LCID lcid, 
	                                                      ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( SpeechLib_ISpeechWaveFormatEx_Interface __RPC_FAR * This, 
	                                                        REFIID riid, 
	                                                        LPOLESTR __RPC_FAR *rgszNames, 
	                                                        UINT cNames, 
	                                                        LCID lcid, 
	                                                        DISPID __RPC_FAR *rgDispId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( SpeechLib_ISpeechWaveFormatEx_Interface __RPC_FAR * This, 
	                                                 DISPID dispIdMember, 
	                                                 REFIID riid, 
	                                                 LCID lcid, 
	                                                 WORD wFlags, 
	                                                 DISPPARAMS __RPC_FAR *pDispParams, 
	                                                 VARIANT __RPC_FAR *pVarResult, 
	                                                 EXCEPINFO __RPC_FAR *pExcepInfo, 
	                                                 UINT __RPC_FAR *puArgErr);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFormatTag_) (SpeechLib_ISpeechWaveFormatEx_Interface __RPC_FAR *This, 
	                                                       short *formatTag);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFormatTag_) (SpeechLib_ISpeechWaveFormatEx_Interface __RPC_FAR *This, 
	                                                       short formatTag);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetChannels_) (SpeechLib_ISpeechWaveFormatEx_Interface __RPC_FAR *This, 
	                                                      short *channels);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetChannels_) (SpeechLib_ISpeechWaveFormatEx_Interface __RPC_FAR *This, 
	                                                      short channels);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSamplesPerSec_) (SpeechLib_ISpeechWaveFormatEx_Interface __RPC_FAR *This, 
	                                                           long *samplesPerSec);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSamplesPerSec_) (SpeechLib_ISpeechWaveFormatEx_Interface __RPC_FAR *This, 
	                                                           long samplesPerSec);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAvgBytesPerSec_) (SpeechLib_ISpeechWaveFormatEx_Interface __RPC_FAR *This, 
	                                                            long *avgBytesPerSec);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAvgBytesPerSec_) (SpeechLib_ISpeechWaveFormatEx_Interface __RPC_FAR *This, 
	                                                            long avgBytesPerSec);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBlockAlign_) (SpeechLib_ISpeechWaveFormatEx_Interface __RPC_FAR *This, 
	                                                        short *blockAlign);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBlockAlign_) (SpeechLib_ISpeechWaveFormatEx_Interface __RPC_FAR *This, 
	                                                        short blockAlign);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBitsPerSample_) (SpeechLib_ISpeechWaveFormatEx_Interface __RPC_FAR *This, 
	                                                           short *bitsPerSample);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBitsPerSample_) (SpeechLib_ISpeechWaveFormatEx_Interface __RPC_FAR *This, 
	                                                           short bitsPerSample);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetExtraData_) (SpeechLib_ISpeechWaveFormatEx_Interface __RPC_FAR *This, 
	                                                       VARIANT *extraData);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetExtraData_) (SpeechLib_ISpeechWaveFormatEx_Interface __RPC_FAR *This, 
	                                                       VARIANT extraData);

} SpeechLib_ISpeechWaveFormatEx_VTable;

typedef interface tagSpeechLib_ISpeechWaveFormatEx_Interface
{
	CONST_VTBL SpeechLib_ISpeechWaveFormatEx_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpeechWaveFormatEx_Interface;

typedef interface tagSpeechLib_ISpeechCustomStream_Interface SpeechLib_ISpeechCustomStream_Interface;

typedef struct tagSpeechLib_ISpeechCustomStream_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpeechCustomStream_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpeechCustomStream_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpeechCustomStream_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( SpeechLib_ISpeechCustomStream_Interface __RPC_FAR * This, 
	                                                           UINT __RPC_FAR *pctinfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( SpeechLib_ISpeechCustomStream_Interface __RPC_FAR * This, 
	                                                      UINT iTInfo, 
	                                                      LCID lcid, 
	                                                      ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( SpeechLib_ISpeechCustomStream_Interface __RPC_FAR * This, 
	                                                        REFIID riid, 
	                                                        LPOLESTR __RPC_FAR *rgszNames, 
	                                                        UINT cNames, 
	                                                        LCID lcid, 
	                                                        DISPID __RPC_FAR *rgDispId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( SpeechLib_ISpeechCustomStream_Interface __RPC_FAR * This, 
	                                                 DISPID dispIdMember, 
	                                                 REFIID riid, 
	                                                 LCID lcid, 
	                                                 WORD wFlags, 
	                                                 DISPPARAMS __RPC_FAR *pDispParams, 
	                                                 VARIANT __RPC_FAR *pVarResult, 
	                                                 EXCEPINFO __RPC_FAR *pExcepInfo, 
	                                                 UINT __RPC_FAR *puArgErr);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFormat_) (SpeechLib_ISpeechCustomStream_Interface __RPC_FAR *This, 
	                                                    LPDISPATCH *audioFormat);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetByRefFormat_) (SpeechLib_ISpeechCustomStream_Interface __RPC_FAR *This, 
	                                                         LPDISPATCH audioFormat);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Read_) (SpeechLib_ISpeechCustomStream_Interface __RPC_FAR *This, 
	                                               VARIANT *buffer, 
	                                               long numberOfBytes, 
	                                               long *bytesRead);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Write_) (SpeechLib_ISpeechCustomStream_Interface __RPC_FAR *This, 
	                                                VARIANT buffer, 
	                                                long *bytesWritten);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Seek_) (SpeechLib_ISpeechCustomStream_Interface __RPC_FAR *This, 
	                                               VARIANT position, 
	                                               long origin, 
	                                               VARIANT *newPosition);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBaseStream_) (SpeechLib_ISpeechCustomStream_Interface __RPC_FAR *This, 
	                                                        LPUNKNOWN *ppUnkStream);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetByRefBaseStream_) (SpeechLib_ISpeechCustomStream_Interface __RPC_FAR *This, 
	                                                             LPUNKNOWN ppUnkStream);

} SpeechLib_ISpeechCustomStream_VTable;

typedef interface tagSpeechLib_ISpeechCustomStream_Interface
{
	CONST_VTBL SpeechLib_ISpeechCustomStream_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpeechCustomStream_Interface;

typedef interface tagSpeechLib_ISpeechFileStream_Interface SpeechLib_ISpeechFileStream_Interface;

typedef struct tagSpeechLib_ISpeechFileStream_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpeechFileStream_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpeechFileStream_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpeechFileStream_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( SpeechLib_ISpeechFileStream_Interface __RPC_FAR * This, 
	                                                           UINT __RPC_FAR *pctinfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( SpeechLib_ISpeechFileStream_Interface __RPC_FAR * This, 
	                                                      UINT iTInfo, 
	                                                      LCID lcid, 
	                                                      ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( SpeechLib_ISpeechFileStream_Interface __RPC_FAR * This, 
	                                                        REFIID riid, 
	                                                        LPOLESTR __RPC_FAR *rgszNames, 
	                                                        UINT cNames, 
	                                                        LCID lcid, 
	                                                        DISPID __RPC_FAR *rgDispId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( SpeechLib_ISpeechFileStream_Interface __RPC_FAR * This, 
	                                                 DISPID dispIdMember, 
	                                                 REFIID riid, 
	                                                 LCID lcid, 
	                                                 WORD wFlags, 
	                                                 DISPPARAMS __RPC_FAR *pDispParams, 
	                                                 VARIANT __RPC_FAR *pVarResult, 
	                                                 EXCEPINFO __RPC_FAR *pExcepInfo, 
	                                                 UINT __RPC_FAR *puArgErr);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFormat_) (SpeechLib_ISpeechFileStream_Interface __RPC_FAR *This, 
	                                                    LPDISPATCH *audioFormat);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetByRefFormat_) (SpeechLib_ISpeechFileStream_Interface __RPC_FAR *This, 
	                                                         LPDISPATCH audioFormat);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Read_) (SpeechLib_ISpeechFileStream_Interface __RPC_FAR *This, 
	                                               VARIANT *buffer, 
	                                               long numberOfBytes, 
	                                               long *bytesRead);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Write_) (SpeechLib_ISpeechFileStream_Interface __RPC_FAR *This, 
	                                                VARIANT buffer, 
	                                                long *bytesWritten);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Seek_) (SpeechLib_ISpeechFileStream_Interface __RPC_FAR *This, 
	                                               VARIANT position, 
	                                               long origin, 
	                                               VARIANT *newPosition);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open_) (SpeechLib_ISpeechFileStream_Interface __RPC_FAR *This, 
	                                               BSTR fileName, 
	                                               long fileMode, 
	                                               VBOOL doEvents);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Close_) (SpeechLib_ISpeechFileStream_Interface __RPC_FAR *This);

} SpeechLib_ISpeechFileStream_VTable;

typedef interface tagSpeechLib_ISpeechFileStream_Interface
{
	CONST_VTBL SpeechLib_ISpeechFileStream_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpeechFileStream_Interface;

typedef interface tagSpeechLib_ISpeechMemoryStream_Interface SpeechLib_ISpeechMemoryStream_Interface;

typedef struct tagSpeechLib_ISpeechMemoryStream_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpeechMemoryStream_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpeechMemoryStream_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpeechMemoryStream_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( SpeechLib_ISpeechMemoryStream_Interface __RPC_FAR * This, 
	                                                           UINT __RPC_FAR *pctinfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( SpeechLib_ISpeechMemoryStream_Interface __RPC_FAR * This, 
	                                                      UINT iTInfo, 
	                                                      LCID lcid, 
	                                                      ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( SpeechLib_ISpeechMemoryStream_Interface __RPC_FAR * This, 
	                                                        REFIID riid, 
	                                                        LPOLESTR __RPC_FAR *rgszNames, 
	                                                        UINT cNames, 
	                                                        LCID lcid, 
	                                                        DISPID __RPC_FAR *rgDispId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( SpeechLib_ISpeechMemoryStream_Interface __RPC_FAR * This, 
	                                                 DISPID dispIdMember, 
	                                                 REFIID riid, 
	                                                 LCID lcid, 
	                                                 WORD wFlags, 
	                                                 DISPPARAMS __RPC_FAR *pDispParams, 
	                                                 VARIANT __RPC_FAR *pVarResult, 
	                                                 EXCEPINFO __RPC_FAR *pExcepInfo, 
	                                                 UINT __RPC_FAR *puArgErr);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFormat_) (SpeechLib_ISpeechMemoryStream_Interface __RPC_FAR *This, 
	                                                    LPDISPATCH *audioFormat);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetByRefFormat_) (SpeechLib_ISpeechMemoryStream_Interface __RPC_FAR *This, 
	                                                         LPDISPATCH audioFormat);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Read_) (SpeechLib_ISpeechMemoryStream_Interface __RPC_FAR *This, 
	                                               VARIANT *buffer, 
	                                               long numberOfBytes, 
	                                               long *bytesRead);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Write_) (SpeechLib_ISpeechMemoryStream_Interface __RPC_FAR *This, 
	                                                VARIANT buffer, 
	                                                long *bytesWritten);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Seek_) (SpeechLib_ISpeechMemoryStream_Interface __RPC_FAR *This, 
	                                               VARIANT position, 
	                                               long origin, 
	                                               VARIANT *newPosition);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetData_) (SpeechLib_ISpeechMemoryStream_Interface __RPC_FAR *This, 
	                                                  VARIANT data);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetData_) (SpeechLib_ISpeechMemoryStream_Interface __RPC_FAR *This, 
	                                                  VARIANT *pData);

} SpeechLib_ISpeechMemoryStream_VTable;

typedef interface tagSpeechLib_ISpeechMemoryStream_Interface
{
	CONST_VTBL SpeechLib_ISpeechMemoryStream_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpeechMemoryStream_Interface;

typedef interface tagSpeechLib_ISpeechDataKey_Interface SpeechLib_ISpeechDataKey_Interface;

typedef struct tagSpeechLib_ISpeechDataKey_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpeechDataKey_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpeechDataKey_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpeechDataKey_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( SpeechLib_ISpeechDataKey_Interface __RPC_FAR * This, 
	                                                           UINT __RPC_FAR *pctinfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( SpeechLib_ISpeechDataKey_Interface __RPC_FAR * This, 
	                                                      UINT iTInfo, 
	                                                      LCID lcid, 
	                                                      ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( SpeechLib_ISpeechDataKey_Interface __RPC_FAR * This, 
	                                                        REFIID riid, 
	                                                        LPOLESTR __RPC_FAR *rgszNames, 
	                                                        UINT cNames, 
	                                                        LCID lcid, 
	                                                        DISPID __RPC_FAR *rgDispId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( SpeechLib_ISpeechDataKey_Interface __RPC_FAR * This, 
	                                                 DISPID dispIdMember, 
	                                                 REFIID riid, 
	                                                 LCID lcid, 
	                                                 WORD wFlags, 
	                                                 DISPPARAMS __RPC_FAR *pDispParams, 
	                                                 VARIANT __RPC_FAR *pVarResult, 
	                                                 EXCEPINFO __RPC_FAR *pExcepInfo, 
	                                                 UINT __RPC_FAR *puArgErr);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBinaryValue_) (SpeechLib_ISpeechDataKey_Interface __RPC_FAR *This, 
	                                                         BSTR valueName, 
	                                                         VARIANT value);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBinaryValue_) (SpeechLib_ISpeechDataKey_Interface __RPC_FAR *This, 
	                                                         BSTR valueName, 
	                                                         VARIANT *value);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStringValue_) (SpeechLib_ISpeechDataKey_Interface __RPC_FAR *This, 
	                                                         BSTR valueName, 
	                                                         BSTR value);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStringValue_) (SpeechLib_ISpeechDataKey_Interface __RPC_FAR *This, 
	                                                         BSTR valueName, 
	                                                         BSTR *value);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLongValue_) (SpeechLib_ISpeechDataKey_Interface __RPC_FAR *This, 
	                                                       BSTR valueName, 
	                                                       long value);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLongValue_) (SpeechLib_ISpeechDataKey_Interface __RPC_FAR *This, 
	                                                       BSTR valueName, 
	                                                       long *value);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenKey_) (SpeechLib_ISpeechDataKey_Interface __RPC_FAR *This, 
	                                                  BSTR subKeyName, 
	                                                  LPDISPATCH *subKey);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateKey_) (SpeechLib_ISpeechDataKey_Interface __RPC_FAR *This, 
	                                                    BSTR subKeyName, 
	                                                    LPDISPATCH *subKey);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteKey_) (SpeechLib_ISpeechDataKey_Interface __RPC_FAR *This, 
	                                                    BSTR subKeyName);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteValue_) (SpeechLib_ISpeechDataKey_Interface __RPC_FAR *This, 
	                                                      BSTR valueName);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumKeys_) (SpeechLib_ISpeechDataKey_Interface __RPC_FAR *This, 
	                                                   long index, 
	                                                   BSTR *subKeyName);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumValues_) (SpeechLib_ISpeechDataKey_Interface __RPC_FAR *This, 
	                                                     long index, 
	                                                     BSTR *valueName);

} SpeechLib_ISpeechDataKey_VTable;

typedef interface tagSpeechLib_ISpeechDataKey_Interface
{
	CONST_VTBL SpeechLib_ISpeechDataKey_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpeechDataKey_Interface;

typedef interface tagSpeechLib_ISpeechObjectTokens_Interface SpeechLib_ISpeechObjectTokens_Interface;

typedef struct tagSpeechLib_ISpeechObjectTokens_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpeechObjectTokens_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpeechObjectTokens_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpeechObjectTokens_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( SpeechLib_ISpeechObjectTokens_Interface __RPC_FAR * This, 
	                                                           UINT __RPC_FAR *pctinfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( SpeechLib_ISpeechObjectTokens_Interface __RPC_FAR * This, 
	                                                      UINT iTInfo, 
	                                                      LCID lcid, 
	                                                      ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( SpeechLib_ISpeechObjectTokens_Interface __RPC_FAR * This, 
	                                                        REFIID riid, 
	                                                        LPOLESTR __RPC_FAR *rgszNames, 
	                                                        UINT cNames, 
	                                                        LCID lcid, 
	                                                        DISPID __RPC_FAR *rgDispId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( SpeechLib_ISpeechObjectTokens_Interface __RPC_FAR * This, 
	                                                 DISPID dispIdMember, 
	                                                 REFIID riid, 
	                                                 LCID lcid, 
	                                                 WORD wFlags, 
	                                                 DISPPARAMS __RPC_FAR *pDispParams, 
	                                                 VARIANT __RPC_FAR *pVarResult, 
	                                                 EXCEPINFO __RPC_FAR *pExcepInfo, 
	                                                 UINT __RPC_FAR *puArgErr);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount_) (SpeechLib_ISpeechObjectTokens_Interface __RPC_FAR *This, 
	                                                   long *count);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Item_) (SpeechLib_ISpeechObjectTokens_Interface __RPC_FAR *This, 
	                                               long index, 
	                                               LPDISPATCH *token);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get_NewEnum_) (SpeechLib_ISpeechObjectTokens_Interface __RPC_FAR *This, 
	                                                      LPUNKNOWN *ppEnumVARIANT);

} SpeechLib_ISpeechObjectTokens_VTable;

typedef interface tagSpeechLib_ISpeechObjectTokens_Interface
{
	CONST_VTBL SpeechLib_ISpeechObjectTokens_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpeechObjectTokens_Interface;

typedef interface tagSpeechLib_ISpeechAudioBufferInfo_Interface SpeechLib_ISpeechAudioBufferInfo_Interface;

typedef struct tagSpeechLib_ISpeechAudioBufferInfo_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpeechAudioBufferInfo_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpeechAudioBufferInfo_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpeechAudioBufferInfo_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( SpeechLib_ISpeechAudioBufferInfo_Interface __RPC_FAR * This, 
	                                                           UINT __RPC_FAR *pctinfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( SpeechLib_ISpeechAudioBufferInfo_Interface __RPC_FAR * This, 
	                                                      UINT iTInfo, 
	                                                      LCID lcid, 
	                                                      ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( SpeechLib_ISpeechAudioBufferInfo_Interface __RPC_FAR * This, 
	                                                        REFIID riid, 
	                                                        LPOLESTR __RPC_FAR *rgszNames, 
	                                                        UINT cNames, 
	                                                        LCID lcid, 
	                                                        DISPID __RPC_FAR *rgDispId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( SpeechLib_ISpeechAudioBufferInfo_Interface __RPC_FAR * This, 
	                                                 DISPID dispIdMember, 
	                                                 REFIID riid, 
	                                                 LCID lcid, 
	                                                 WORD wFlags, 
	                                                 DISPPARAMS __RPC_FAR *pDispParams, 
	                                                 VARIANT __RPC_FAR *pVarResult, 
	                                                 EXCEPINFO __RPC_FAR *pExcepInfo, 
	                                                 UINT __RPC_FAR *puArgErr);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMinNotification_) (SpeechLib_ISpeechAudioBufferInfo_Interface __RPC_FAR *This, 
	                                                             long *minNotification);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetMinNotification_) (SpeechLib_ISpeechAudioBufferInfo_Interface __RPC_FAR *This, 
	                                                             long minNotification);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBufferSize_) (SpeechLib_ISpeechAudioBufferInfo_Interface __RPC_FAR *This, 
	                                                        long *bufferSize);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBufferSize_) (SpeechLib_ISpeechAudioBufferInfo_Interface __RPC_FAR *This, 
	                                                        long bufferSize);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEventBias_) (SpeechLib_ISpeechAudioBufferInfo_Interface __RPC_FAR *This, 
	                                                       long *eventBias);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEventBias_) (SpeechLib_ISpeechAudioBufferInfo_Interface __RPC_FAR *This, 
	                                                       long eventBias);

} SpeechLib_ISpeechAudioBufferInfo_VTable;

typedef interface tagSpeechLib_ISpeechAudioBufferInfo_Interface
{
	CONST_VTBL SpeechLib_ISpeechAudioBufferInfo_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpeechAudioBufferInfo_Interface;

typedef interface tagSpeechLib_ISpeechAudioStatus_Interface SpeechLib_ISpeechAudioStatus_Interface;

typedef struct tagSpeechLib_ISpeechAudioStatus_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpeechAudioStatus_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpeechAudioStatus_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpeechAudioStatus_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( SpeechLib_ISpeechAudioStatus_Interface __RPC_FAR * This, 
	                                                           UINT __RPC_FAR *pctinfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( SpeechLib_ISpeechAudioStatus_Interface __RPC_FAR * This, 
	                                                      UINT iTInfo, 
	                                                      LCID lcid, 
	                                                      ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( SpeechLib_ISpeechAudioStatus_Interface __RPC_FAR * This, 
	                                                        REFIID riid, 
	                                                        LPOLESTR __RPC_FAR *rgszNames, 
	                                                        UINT cNames, 
	                                                        LCID lcid, 
	                                                        DISPID __RPC_FAR *rgDispId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( SpeechLib_ISpeechAudioStatus_Interface __RPC_FAR * This, 
	                                                 DISPID dispIdMember, 
	                                                 REFIID riid, 
	                                                 LCID lcid, 
	                                                 WORD wFlags, 
	                                                 DISPPARAMS __RPC_FAR *pDispParams, 
	                                                 VARIANT __RPC_FAR *pVarResult, 
	                                                 EXCEPINFO __RPC_FAR *pExcepInfo, 
	                                                 UINT __RPC_FAR *puArgErr);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFreeBufferSpace_) (SpeechLib_ISpeechAudioStatus_Interface __RPC_FAR *This, 
	                                                             long *freeBufferSpace);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNonBlockingIO_) (SpeechLib_ISpeechAudioStatus_Interface __RPC_FAR *This, 
	                                                           long *nonBlockingIO);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetState_) (SpeechLib_ISpeechAudioStatus_Interface __RPC_FAR *This, 
	                                                   long *state);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCurrentSeekPosition_) (SpeechLib_ISpeechAudioStatus_Interface __RPC_FAR *This, 
	                                                                 VARIANT *currentSeekPosition);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCurrentDevicePosition_) (SpeechLib_ISpeechAudioStatus_Interface __RPC_FAR *This, 
	                                                                   VARIANT *currentDevicePosition);

} SpeechLib_ISpeechAudioStatus_VTable;

typedef interface tagSpeechLib_ISpeechAudioStatus_Interface
{
	CONST_VTBL SpeechLib_ISpeechAudioStatus_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpeechAudioStatus_Interface;

typedef interface tagSpeechLib_ISpeechBaseStream_Interface SpeechLib_ISpeechBaseStream_Interface;

typedef struct tagSpeechLib_ISpeechBaseStream_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpeechBaseStream_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpeechBaseStream_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpeechBaseStream_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( SpeechLib_ISpeechBaseStream_Interface __RPC_FAR * This, 
	                                                           UINT __RPC_FAR *pctinfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( SpeechLib_ISpeechBaseStream_Interface __RPC_FAR * This, 
	                                                      UINT iTInfo, 
	                                                      LCID lcid, 
	                                                      ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( SpeechLib_ISpeechBaseStream_Interface __RPC_FAR * This, 
	                                                        REFIID riid, 
	                                                        LPOLESTR __RPC_FAR *rgszNames, 
	                                                        UINT cNames, 
	                                                        LCID lcid, 
	                                                        DISPID __RPC_FAR *rgDispId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( SpeechLib_ISpeechBaseStream_Interface __RPC_FAR * This, 
	                                                 DISPID dispIdMember, 
	                                                 REFIID riid, 
	                                                 LCID lcid, 
	                                                 WORD wFlags, 
	                                                 DISPPARAMS __RPC_FAR *pDispParams, 
	                                                 VARIANT __RPC_FAR *pVarResult, 
	                                                 EXCEPINFO __RPC_FAR *pExcepInfo, 
	                                                 UINT __RPC_FAR *puArgErr);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFormat_) (SpeechLib_ISpeechBaseStream_Interface __RPC_FAR *This, 
	                                                    LPDISPATCH *audioFormat);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetByRefFormat_) (SpeechLib_ISpeechBaseStream_Interface __RPC_FAR *This, 
	                                                         LPDISPATCH audioFormat);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Read_) (SpeechLib_ISpeechBaseStream_Interface __RPC_FAR *This, 
	                                               VARIANT *buffer, 
	                                               long numberOfBytes, 
	                                               long *bytesRead);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Write_) (SpeechLib_ISpeechBaseStream_Interface __RPC_FAR *This, 
	                                                VARIANT buffer, 
	                                                long *bytesWritten);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Seek_) (SpeechLib_ISpeechBaseStream_Interface __RPC_FAR *This, 
	                                               VARIANT position, 
	                                               long origin, 
	                                               VARIANT *newPosition);

} SpeechLib_ISpeechBaseStream_VTable;

typedef interface tagSpeechLib_ISpeechBaseStream_Interface
{
	CONST_VTBL SpeechLib_ISpeechBaseStream_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpeechBaseStream_Interface;

typedef interface tagSpeechLib_ISpeechAudio_Interface SpeechLib_ISpeechAudio_Interface;

typedef struct tagSpeechLib_ISpeechAudio_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpeechAudio_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpeechAudio_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpeechAudio_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( SpeechLib_ISpeechAudio_Interface __RPC_FAR * This, 
	                                                           UINT __RPC_FAR *pctinfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( SpeechLib_ISpeechAudio_Interface __RPC_FAR * This, 
	                                                      UINT iTInfo, 
	                                                      LCID lcid, 
	                                                      ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( SpeechLib_ISpeechAudio_Interface __RPC_FAR * This, 
	                                                        REFIID riid, 
	                                                        LPOLESTR __RPC_FAR *rgszNames, 
	                                                        UINT cNames, 
	                                                        LCID lcid, 
	                                                        DISPID __RPC_FAR *rgDispId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( SpeechLib_ISpeechAudio_Interface __RPC_FAR * This, 
	                                                 DISPID dispIdMember, 
	                                                 REFIID riid, 
	                                                 LCID lcid, 
	                                                 WORD wFlags, 
	                                                 DISPPARAMS __RPC_FAR *pDispParams, 
	                                                 VARIANT __RPC_FAR *pVarResult, 
	                                                 EXCEPINFO __RPC_FAR *pExcepInfo, 
	                                                 UINT __RPC_FAR *puArgErr);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFormat_) (SpeechLib_ISpeechAudio_Interface __RPC_FAR *This, 
	                                                    LPDISPATCH *audioFormat);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetByRefFormat_) (SpeechLib_ISpeechAudio_Interface __RPC_FAR *This, 
	                                                         LPDISPATCH audioFormat);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Read_) (SpeechLib_ISpeechAudio_Interface __RPC_FAR *This, 
	                                               VARIANT *buffer, 
	                                               long numberOfBytes, 
	                                               long *bytesRead);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Write_) (SpeechLib_ISpeechAudio_Interface __RPC_FAR *This, 
	                                                VARIANT buffer, 
	                                                long *bytesWritten);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Seek_) (SpeechLib_ISpeechAudio_Interface __RPC_FAR *This, 
	                                               VARIANT position, 
	                                               long origin, 
	                                               VARIANT *newPosition);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatus_) (SpeechLib_ISpeechAudio_Interface __RPC_FAR *This, 
	                                                    LPDISPATCH *status);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBufferInfo_) (SpeechLib_ISpeechAudio_Interface __RPC_FAR *This, 
	                                                        LPDISPATCH *bufferInfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDefaultFormat_) (SpeechLib_ISpeechAudio_Interface __RPC_FAR *This, 
	                                                           LPDISPATCH *streamFormat);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetVolume_) (SpeechLib_ISpeechAudio_Interface __RPC_FAR *This, 
	                                                    long *volume);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetVolume_) (SpeechLib_ISpeechAudio_Interface __RPC_FAR *This, 
	                                                    long volume);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBufferNotifySize_) (SpeechLib_ISpeechAudio_Interface __RPC_FAR *This, 
	                                                              long *bufferNotifySize);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBufferNotifySize_) (SpeechLib_ISpeechAudio_Interface __RPC_FAR *This, 
	                                                              long bufferNotifySize);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEventHandle_) (SpeechLib_ISpeechAudio_Interface __RPC_FAR *This, 
	                                                         long *eventHandle);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetState_) (SpeechLib_ISpeechAudio_Interface __RPC_FAR *This, 
	                                                   long state);

} SpeechLib_ISpeechAudio_VTable;

typedef interface tagSpeechLib_ISpeechAudio_Interface
{
	CONST_VTBL SpeechLib_ISpeechAudio_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpeechAudio_Interface;

typedef interface tagSpeechLib_ISpeechVoiceStatus_Interface SpeechLib_ISpeechVoiceStatus_Interface;

typedef struct tagSpeechLib_ISpeechVoiceStatus_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpeechVoiceStatus_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpeechVoiceStatus_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpeechVoiceStatus_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( SpeechLib_ISpeechVoiceStatus_Interface __RPC_FAR * This, 
	                                                           UINT __RPC_FAR *pctinfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( SpeechLib_ISpeechVoiceStatus_Interface __RPC_FAR * This, 
	                                                      UINT iTInfo, 
	                                                      LCID lcid, 
	                                                      ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( SpeechLib_ISpeechVoiceStatus_Interface __RPC_FAR * This, 
	                                                        REFIID riid, 
	                                                        LPOLESTR __RPC_FAR *rgszNames, 
	                                                        UINT cNames, 
	                                                        LCID lcid, 
	                                                        DISPID __RPC_FAR *rgDispId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( SpeechLib_ISpeechVoiceStatus_Interface __RPC_FAR * This, 
	                                                 DISPID dispIdMember, 
	                                                 REFIID riid, 
	                                                 LCID lcid, 
	                                                 WORD wFlags, 
	                                                 DISPPARAMS __RPC_FAR *pDispParams, 
	                                                 VARIANT __RPC_FAR *pVarResult, 
	                                                 EXCEPINFO __RPC_FAR *pExcepInfo, 
	                                                 UINT __RPC_FAR *puArgErr);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCurrentStreamNumber_) (SpeechLib_ISpeechVoiceStatus_Interface __RPC_FAR *This, 
	                                                                 long *streamNumber);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLastStreamNumberQueued_) (SpeechLib_ISpeechVoiceStatus_Interface __RPC_FAR *This, 
	                                                                    long *streamNumber);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLastHResult_) (SpeechLib_ISpeechVoiceStatus_Interface __RPC_FAR *This, 
	                                                         long *HResult);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRunningState_) (SpeechLib_ISpeechVoiceStatus_Interface __RPC_FAR *This, 
	                                                          long *state);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInputWordPosition_) (SpeechLib_ISpeechVoiceStatus_Interface __RPC_FAR *This, 
	                                                               long *position);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInputWordLength_) (SpeechLib_ISpeechVoiceStatus_Interface __RPC_FAR *This, 
	                                                             long *length);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInputSentencePosition_) (SpeechLib_ISpeechVoiceStatus_Interface __RPC_FAR *This, 
	                                                                   long *position);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInputSentenceLength_) (SpeechLib_ISpeechVoiceStatus_Interface __RPC_FAR *This, 
	                                                                 long *length);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLastBookmark_) (SpeechLib_ISpeechVoiceStatus_Interface __RPC_FAR *This, 
	                                                          BSTR *bookmark);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLastBookmarkId_) (SpeechLib_ISpeechVoiceStatus_Interface __RPC_FAR *This, 
	                                                            long *bookmarkId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPhonemeId_) (SpeechLib_ISpeechVoiceStatus_Interface __RPC_FAR *This, 
	                                                       short *phoneId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetVisemeId_) (SpeechLib_ISpeechVoiceStatus_Interface __RPC_FAR *This, 
	                                                      short *visemeId);

} SpeechLib_ISpeechVoiceStatus_VTable;

typedef interface tagSpeechLib_ISpeechVoiceStatus_Interface
{
	CONST_VTBL SpeechLib_ISpeechVoiceStatus_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpeechVoiceStatus_Interface;

typedef interface tagSpeechLib_ISpeechRecognizerStatus_Interface SpeechLib_ISpeechRecognizerStatus_Interface;

typedef struct tagSpeechLib_ISpeechRecognizerStatus_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpeechRecognizerStatus_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpeechRecognizerStatus_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpeechRecognizerStatus_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( SpeechLib_ISpeechRecognizerStatus_Interface __RPC_FAR * This, 
	                                                           UINT __RPC_FAR *pctinfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( SpeechLib_ISpeechRecognizerStatus_Interface __RPC_FAR * This, 
	                                                      UINT iTInfo, 
	                                                      LCID lcid, 
	                                                      ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( SpeechLib_ISpeechRecognizerStatus_Interface __RPC_FAR * This, 
	                                                        REFIID riid, 
	                                                        LPOLESTR __RPC_FAR *rgszNames, 
	                                                        UINT cNames, 
	                                                        LCID lcid, 
	                                                        DISPID __RPC_FAR *rgDispId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( SpeechLib_ISpeechRecognizerStatus_Interface __RPC_FAR * This, 
	                                                 DISPID dispIdMember, 
	                                                 REFIID riid, 
	                                                 LCID lcid, 
	                                                 WORD wFlags, 
	                                                 DISPPARAMS __RPC_FAR *pDispParams, 
	                                                 VARIANT __RPC_FAR *pVarResult, 
	                                                 EXCEPINFO __RPC_FAR *pExcepInfo, 
	                                                 UINT __RPC_FAR *puArgErr);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAudioStatus_) (SpeechLib_ISpeechRecognizerStatus_Interface __RPC_FAR *This, 
	                                                         LPDISPATCH *audioStatus);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCurrentStreamPosition_) (SpeechLib_ISpeechRecognizerStatus_Interface __RPC_FAR *This, 
	                                                                   VARIANT *pCurrentStreamPos);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCurrentStreamNumber_) (SpeechLib_ISpeechRecognizerStatus_Interface __RPC_FAR *This, 
	                                                                 long *streamNumber);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNumberOfActiveRules_) (SpeechLib_ISpeechRecognizerStatus_Interface __RPC_FAR *This, 
	                                                                 long *numberOfActiveRules);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetClsidEngine_) (SpeechLib_ISpeechRecognizerStatus_Interface __RPC_FAR *This, 
	                                                         BSTR *clsidEngine);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSupportedLanguages_) (SpeechLib_ISpeechRecognizerStatus_Interface __RPC_FAR *This, 
	                                                                VARIANT *supportedLanguages);

} SpeechLib_ISpeechRecognizerStatus_VTable;

typedef interface tagSpeechLib_ISpeechRecognizerStatus_Interface
{
	CONST_VTBL SpeechLib_ISpeechRecognizerStatus_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpeechRecognizerStatus_Interface;

typedef interface tagSpeechLib_ISpeechRecoGrammar_Interface SpeechLib_ISpeechRecoGrammar_Interface;

typedef struct tagSpeechLib_ISpeechRecoGrammar_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpeechRecoGrammar_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpeechRecoGrammar_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpeechRecoGrammar_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( SpeechLib_ISpeechRecoGrammar_Interface __RPC_FAR * This, 
	                                                           UINT __RPC_FAR *pctinfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( SpeechLib_ISpeechRecoGrammar_Interface __RPC_FAR * This, 
	                                                      UINT iTInfo, 
	                                                      LCID lcid, 
	                                                      ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( SpeechLib_ISpeechRecoGrammar_Interface __RPC_FAR * This, 
	                                                        REFIID riid, 
	                                                        LPOLESTR __RPC_FAR *rgszNames, 
	                                                        UINT cNames, 
	                                                        LCID lcid, 
	                                                        DISPID __RPC_FAR *rgDispId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( SpeechLib_ISpeechRecoGrammar_Interface __RPC_FAR * This, 
	                                                 DISPID dispIdMember, 
	                                                 REFIID riid, 
	                                                 LCID lcid, 
	                                                 WORD wFlags, 
	                                                 DISPPARAMS __RPC_FAR *pDispParams, 
	                                                 VARIANT __RPC_FAR *pVarResult, 
	                                                 EXCEPINFO __RPC_FAR *pExcepInfo, 
	                                                 UINT __RPC_FAR *puArgErr);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetId_) (SpeechLib_ISpeechRecoGrammar_Interface __RPC_FAR *This, 
	                                                VARIANT *id);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRecoContext_) (SpeechLib_ISpeechRecoGrammar_Interface __RPC_FAR *This, 
	                                                         LPDISPATCH *recoContext);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetState_) (SpeechLib_ISpeechRecoGrammar_Interface __RPC_FAR *This, 
	                                                   long state);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetState_) (SpeechLib_ISpeechRecoGrammar_Interface __RPC_FAR *This, 
	                                                   long *state);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRules_) (SpeechLib_ISpeechRecoGrammar_Interface __RPC_FAR *This, 
	                                                   LPDISPATCH *rules);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset_) (SpeechLib_ISpeechRecoGrammar_Interface __RPC_FAR *This, 
	                                                long newLanguage);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CmdLoadFromFile_) (SpeechLib_ISpeechRecoGrammar_Interface __RPC_FAR *This, 
	                                                          BSTR fileName, 
	                                                          long loadOption);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CmdLoadFromObject_) (SpeechLib_ISpeechRecoGrammar_Interface __RPC_FAR *This, 
	                                                            BSTR classId, 
	                                                            BSTR grammarName, 
	                                                            long loadOption);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CmdLoadFromResource_) (SpeechLib_ISpeechRecoGrammar_Interface __RPC_FAR *This, 
	                                                              long hModule, 
	                                                              VARIANT resourceName, 
	                                                              VARIANT resourceType, 
	                                                              long languageId, 
	                                                              long loadOption);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CmdLoadFromMemory_) (SpeechLib_ISpeechRecoGrammar_Interface __RPC_FAR *This, 
	                                                            VARIANT grammarData, 
	                                                            long loadOption);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CmdLoadFromProprietaryGrammar_) (SpeechLib_ISpeechRecoGrammar_Interface __RPC_FAR *This, 
	                                                                        BSTR proprietaryGuid, 
	                                                                        BSTR proprietaryString, 
	                                                                        VARIANT proprietaryData, 
	                                                                        long loadOption);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CmdSetRuleState_) (SpeechLib_ISpeechRecoGrammar_Interface __RPC_FAR *This, 
	                                                          BSTR name, 
	                                                          long state);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CmdSetRuleIdState_) (SpeechLib_ISpeechRecoGrammar_Interface __RPC_FAR *This, 
	                                                            long ruleId, 
	                                                            long state);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DictationLoad_) (SpeechLib_ISpeechRecoGrammar_Interface __RPC_FAR *This, 
	                                                        BSTR topicName, 
	                                                        long loadOption);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DictationUnload_) (SpeechLib_ISpeechRecoGrammar_Interface __RPC_FAR *This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DictationSetState_) (SpeechLib_ISpeechRecoGrammar_Interface __RPC_FAR *This, 
	                                                            long state);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetWordSequenceData_) (SpeechLib_ISpeechRecoGrammar_Interface __RPC_FAR *This, 
	                                                              BSTR text, 
	                                                              long textLength, 
	                                                              LPDISPATCH info);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTextSelection_) (SpeechLib_ISpeechRecoGrammar_Interface __RPC_FAR *This, 
	                                                           LPDISPATCH info);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsPronounceable_) (SpeechLib_ISpeechRecoGrammar_Interface __RPC_FAR *This, 
	                                                          BSTR word, 
	                                                          long *wordPronounceable);

} SpeechLib_ISpeechRecoGrammar_VTable;

typedef interface tagSpeechLib_ISpeechRecoGrammar_Interface
{
	CONST_VTBL SpeechLib_ISpeechRecoGrammar_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpeechRecoGrammar_Interface;

typedef interface tagSpeechLib_ISpeechGrammarRules_Interface SpeechLib_ISpeechGrammarRules_Interface;

typedef struct tagSpeechLib_ISpeechGrammarRules_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpeechGrammarRules_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpeechGrammarRules_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpeechGrammarRules_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( SpeechLib_ISpeechGrammarRules_Interface __RPC_FAR * This, 
	                                                           UINT __RPC_FAR *pctinfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( SpeechLib_ISpeechGrammarRules_Interface __RPC_FAR * This, 
	                                                      UINT iTInfo, 
	                                                      LCID lcid, 
	                                                      ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( SpeechLib_ISpeechGrammarRules_Interface __RPC_FAR * This, 
	                                                        REFIID riid, 
	                                                        LPOLESTR __RPC_FAR *rgszNames, 
	                                                        UINT cNames, 
	                                                        LCID lcid, 
	                                                        DISPID __RPC_FAR *rgDispId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( SpeechLib_ISpeechGrammarRules_Interface __RPC_FAR * This, 
	                                                 DISPID dispIdMember, 
	                                                 REFIID riid, 
	                                                 LCID lcid, 
	                                                 WORD wFlags, 
	                                                 DISPPARAMS __RPC_FAR *pDispParams, 
	                                                 VARIANT __RPC_FAR *pVarResult, 
	                                                 EXCEPINFO __RPC_FAR *pExcepInfo, 
	                                                 UINT __RPC_FAR *puArgErr);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount_) (SpeechLib_ISpeechGrammarRules_Interface __RPC_FAR *This, 
	                                                   long *count);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindRule_) (SpeechLib_ISpeechGrammarRules_Interface __RPC_FAR *This, 
	                                                   VARIANT ruleNameOrId, 
	                                                   LPDISPATCH *rule);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Item_) (SpeechLib_ISpeechGrammarRules_Interface __RPC_FAR *This, 
	                                               long index, 
	                                               LPDISPATCH *rule);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get_NewEnum_) (SpeechLib_ISpeechGrammarRules_Interface __RPC_FAR *This, 
	                                                      LPUNKNOWN *enumVARIANT);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDynamic_) (SpeechLib_ISpeechGrammarRules_Interface __RPC_FAR *This, 
	                                                     VBOOL *dynamic);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Add_) (SpeechLib_ISpeechGrammarRules_Interface __RPC_FAR *This, 
	                                              BSTR ruleName, 
	                                              long attributes, 
	                                              long ruleId, 
	                                              LPDISPATCH *rule);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Commit_) (SpeechLib_ISpeechGrammarRules_Interface __RPC_FAR *This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CommitAndSave_) (SpeechLib_ISpeechGrammarRules_Interface __RPC_FAR *This, 
	                                                        BSTR *errorText, 
	                                                        VARIANT *saveStream);

} SpeechLib_ISpeechGrammarRules_VTable;

typedef interface tagSpeechLib_ISpeechGrammarRules_Interface
{
	CONST_VTBL SpeechLib_ISpeechGrammarRules_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpeechGrammarRules_Interface;

typedef interface tagSpeechLib_ISpeechGrammarRule_Interface SpeechLib_ISpeechGrammarRule_Interface;

typedef struct tagSpeechLib_ISpeechGrammarRule_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpeechGrammarRule_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpeechGrammarRule_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpeechGrammarRule_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( SpeechLib_ISpeechGrammarRule_Interface __RPC_FAR * This, 
	                                                           UINT __RPC_FAR *pctinfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( SpeechLib_ISpeechGrammarRule_Interface __RPC_FAR * This, 
	                                                      UINT iTInfo, 
	                                                      LCID lcid, 
	                                                      ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( SpeechLib_ISpeechGrammarRule_Interface __RPC_FAR * This, 
	                                                        REFIID riid, 
	                                                        LPOLESTR __RPC_FAR *rgszNames, 
	                                                        UINT cNames, 
	                                                        LCID lcid, 
	                                                        DISPID __RPC_FAR *rgDispId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( SpeechLib_ISpeechGrammarRule_Interface __RPC_FAR * This, 
	                                                 DISPID dispIdMember, 
	                                                 REFIID riid, 
	                                                 LCID lcid, 
	                                                 WORD wFlags, 
	                                                 DISPPARAMS __RPC_FAR *pDispParams, 
	                                                 VARIANT __RPC_FAR *pVarResult, 
	                                                 EXCEPINFO __RPC_FAR *pExcepInfo, 
	                                                 UINT __RPC_FAR *puArgErr);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAttributes_) (SpeechLib_ISpeechGrammarRule_Interface __RPC_FAR *This, 
	                                                        long *attributes);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInitialState_) (SpeechLib_ISpeechGrammarRule_Interface __RPC_FAR *This, 
	                                                          LPDISPATCH *state);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName_) (SpeechLib_ISpeechGrammarRule_Interface __RPC_FAR *This, 
	                                                  BSTR *name);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetId_) (SpeechLib_ISpeechGrammarRule_Interface __RPC_FAR *This, 
	                                                long *id);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clear_) (SpeechLib_ISpeechGrammarRule_Interface __RPC_FAR *This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddResource_) (SpeechLib_ISpeechGrammarRule_Interface __RPC_FAR *This, 
	                                                      BSTR resourceName, 
	                                                      BSTR resourceValue);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddState_) (SpeechLib_ISpeechGrammarRule_Interface __RPC_FAR *This, 
	                                                   LPDISPATCH *state);

} SpeechLib_ISpeechGrammarRule_VTable;

typedef interface tagSpeechLib_ISpeechGrammarRule_Interface
{
	CONST_VTBL SpeechLib_ISpeechGrammarRule_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpeechGrammarRule_Interface;

typedef interface tagSpeechLib_ISpeechGrammarRuleState_Interface SpeechLib_ISpeechGrammarRuleState_Interface;

typedef struct tagSpeechLib_ISpeechGrammarRuleState_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpeechGrammarRuleState_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpeechGrammarRuleState_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpeechGrammarRuleState_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( SpeechLib_ISpeechGrammarRuleState_Interface __RPC_FAR * This, 
	                                                           UINT __RPC_FAR *pctinfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( SpeechLib_ISpeechGrammarRuleState_Interface __RPC_FAR * This, 
	                                                      UINT iTInfo, 
	                                                      LCID lcid, 
	                                                      ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( SpeechLib_ISpeechGrammarRuleState_Interface __RPC_FAR * This, 
	                                                        REFIID riid, 
	                                                        LPOLESTR __RPC_FAR *rgszNames, 
	                                                        UINT cNames, 
	                                                        LCID lcid, 
	                                                        DISPID __RPC_FAR *rgDispId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( SpeechLib_ISpeechGrammarRuleState_Interface __RPC_FAR * This, 
	                                                 DISPID dispIdMember, 
	                                                 REFIID riid, 
	                                                 LCID lcid, 
	                                                 WORD wFlags, 
	                                                 DISPPARAMS __RPC_FAR *pDispParams, 
	                                                 VARIANT __RPC_FAR *pVarResult, 
	                                                 EXCEPINFO __RPC_FAR *pExcepInfo, 
	                                                 UINT __RPC_FAR *puArgErr);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRule_) (SpeechLib_ISpeechGrammarRuleState_Interface __RPC_FAR *This, 
	                                                  LPDISPATCH *rule);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTransitions_) (SpeechLib_ISpeechGrammarRuleState_Interface __RPC_FAR *This, 
	                                                         LPDISPATCH *transitions);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddWordTransition_) (SpeechLib_ISpeechGrammarRuleState_Interface __RPC_FAR *This, 
	                                                            LPDISPATCH destState, 
	                                                            BSTR words, 
	                                                            BSTR separators, 
	                                                            long type, 
	                                                            BSTR propertyName, 
	                                                            long propertyId, 
	                                                            VARIANT *propertyValue, 
	                                                            float weight);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddRuleTransition_) (SpeechLib_ISpeechGrammarRuleState_Interface __RPC_FAR *This, 
	                                                            LPDISPATCH destinationState, 
	                                                            LPDISPATCH rule, 
	                                                            BSTR propertyName, 
	                                                            long propertyId, 
	                                                            VARIANT *propertyValue, 
	                                                            float weight);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddSpecialTransition_) (SpeechLib_ISpeechGrammarRuleState_Interface __RPC_FAR *This, 
	                                                               LPDISPATCH destinationState, 
	                                                               long type, 
	                                                               BSTR propertyName, 
	                                                               long propertyId, 
	                                                               VARIANT *propertyValue, 
	                                                               float weight);

} SpeechLib_ISpeechGrammarRuleState_VTable;

typedef interface tagSpeechLib_ISpeechGrammarRuleState_Interface
{
	CONST_VTBL SpeechLib_ISpeechGrammarRuleState_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpeechGrammarRuleState_Interface;

typedef interface tagSpeechLib_ISpeechGrammarRuleStateTransitions_Interface SpeechLib_ISpeechGrammarRuleStateTransitions_Interface;

typedef struct tagSpeechLib_ISpeechGrammarRuleStateTransitions_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpeechGrammarRuleStateTransitions_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpeechGrammarRuleStateTransitions_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpeechGrammarRuleStateTransitions_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( SpeechLib_ISpeechGrammarRuleStateTransitions_Interface __RPC_FAR * This, 
	                                                           UINT __RPC_FAR *pctinfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( SpeechLib_ISpeechGrammarRuleStateTransitions_Interface __RPC_FAR * This, 
	                                                      UINT iTInfo, 
	                                                      LCID lcid, 
	                                                      ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( SpeechLib_ISpeechGrammarRuleStateTransitions_Interface __RPC_FAR * This, 
	                                                        REFIID riid, 
	                                                        LPOLESTR __RPC_FAR *rgszNames, 
	                                                        UINT cNames, 
	                                                        LCID lcid, 
	                                                        DISPID __RPC_FAR *rgDispId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( SpeechLib_ISpeechGrammarRuleStateTransitions_Interface __RPC_FAR * This, 
	                                                 DISPID dispIdMember, 
	                                                 REFIID riid, 
	                                                 LCID lcid, 
	                                                 WORD wFlags, 
	                                                 DISPPARAMS __RPC_FAR *pDispParams, 
	                                                 VARIANT __RPC_FAR *pVarResult, 
	                                                 EXCEPINFO __RPC_FAR *pExcepInfo, 
	                                                 UINT __RPC_FAR *puArgErr);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount_) (SpeechLib_ISpeechGrammarRuleStateTransitions_Interface __RPC_FAR *This, 
	                                                   long *count);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Item_) (SpeechLib_ISpeechGrammarRuleStateTransitions_Interface __RPC_FAR *This, 
	                                               long index, 
	                                               LPDISPATCH *transition);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get_NewEnum_) (SpeechLib_ISpeechGrammarRuleStateTransitions_Interface __RPC_FAR *This, 
	                                                      LPUNKNOWN *enumVARIANT);

} SpeechLib_ISpeechGrammarRuleStateTransitions_VTable;

typedef interface tagSpeechLib_ISpeechGrammarRuleStateTransitions_Interface
{
	CONST_VTBL SpeechLib_ISpeechGrammarRuleStateTransitions_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpeechGrammarRuleStateTransitions_Interface;

typedef interface tagSpeechLib_ISpeechGrammarRuleStateTransition_Interface SpeechLib_ISpeechGrammarRuleStateTransition_Interface;

typedef struct tagSpeechLib_ISpeechGrammarRuleStateTransition_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpeechGrammarRuleStateTransition_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpeechGrammarRuleStateTransition_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpeechGrammarRuleStateTransition_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( SpeechLib_ISpeechGrammarRuleStateTransition_Interface __RPC_FAR * This, 
	                                                           UINT __RPC_FAR *pctinfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( SpeechLib_ISpeechGrammarRuleStateTransition_Interface __RPC_FAR * This, 
	                                                      UINT iTInfo, 
	                                                      LCID lcid, 
	                                                      ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( SpeechLib_ISpeechGrammarRuleStateTransition_Interface __RPC_FAR * This, 
	                                                        REFIID riid, 
	                                                        LPOLESTR __RPC_FAR *rgszNames, 
	                                                        UINT cNames, 
	                                                        LCID lcid, 
	                                                        DISPID __RPC_FAR *rgDispId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( SpeechLib_ISpeechGrammarRuleStateTransition_Interface __RPC_FAR * This, 
	                                                 DISPID dispIdMember, 
	                                                 REFIID riid, 
	                                                 LCID lcid, 
	                                                 WORD wFlags, 
	                                                 DISPPARAMS __RPC_FAR *pDispParams, 
	                                                 VARIANT __RPC_FAR *pVarResult, 
	                                                 EXCEPINFO __RPC_FAR *pExcepInfo, 
	                                                 UINT __RPC_FAR *puArgErr);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType_) (SpeechLib_ISpeechGrammarRuleStateTransition_Interface __RPC_FAR *This, 
	                                                  long *type);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetText_) (SpeechLib_ISpeechGrammarRuleStateTransition_Interface __RPC_FAR *This, 
	                                                  BSTR *text);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRule_) (SpeechLib_ISpeechGrammarRuleStateTransition_Interface __RPC_FAR *This, 
	                                                  LPDISPATCH *rule);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetWeight_) (SpeechLib_ISpeechGrammarRuleStateTransition_Interface __RPC_FAR *This, 
	                                                    VARIANT *weight);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropertyName_) (SpeechLib_ISpeechGrammarRuleStateTransition_Interface __RPC_FAR *This, 
	                                                          BSTR *propertyName);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropertyId_) (SpeechLib_ISpeechGrammarRuleStateTransition_Interface __RPC_FAR *This, 
	                                                        long *propertyId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropertyValue_) (SpeechLib_ISpeechGrammarRuleStateTransition_Interface __RPC_FAR *This, 
	                                                           VARIANT *propertyValue);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNextState_) (SpeechLib_ISpeechGrammarRuleStateTransition_Interface __RPC_FAR *This, 
	                                                       LPDISPATCH *nextState);

} SpeechLib_ISpeechGrammarRuleStateTransition_VTable;

typedef interface tagSpeechLib_ISpeechGrammarRuleStateTransition_Interface
{
	CONST_VTBL SpeechLib_ISpeechGrammarRuleStateTransition_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpeechGrammarRuleStateTransition_Interface;

typedef interface tagSpeechLib_ISpeechRecoResult_Interface SpeechLib_ISpeechRecoResult_Interface;

typedef struct tagSpeechLib_ISpeechRecoResult_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpeechRecoResult_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpeechRecoResult_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpeechRecoResult_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( SpeechLib_ISpeechRecoResult_Interface __RPC_FAR * This, 
	                                                           UINT __RPC_FAR *pctinfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( SpeechLib_ISpeechRecoResult_Interface __RPC_FAR * This, 
	                                                      UINT iTInfo, 
	                                                      LCID lcid, 
	                                                      ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( SpeechLib_ISpeechRecoResult_Interface __RPC_FAR * This, 
	                                                        REFIID riid, 
	                                                        LPOLESTR __RPC_FAR *rgszNames, 
	                                                        UINT cNames, 
	                                                        LCID lcid, 
	                                                        DISPID __RPC_FAR *rgDispId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( SpeechLib_ISpeechRecoResult_Interface __RPC_FAR * This, 
	                                                 DISPID dispIdMember, 
	                                                 REFIID riid, 
	                                                 LCID lcid, 
	                                                 WORD wFlags, 
	                                                 DISPPARAMS __RPC_FAR *pDispParams, 
	                                                 VARIANT __RPC_FAR *pVarResult, 
	                                                 EXCEPINFO __RPC_FAR *pExcepInfo, 
	                                                 UINT __RPC_FAR *puArgErr);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRecoContext_) (SpeechLib_ISpeechRecoResult_Interface __RPC_FAR *This, 
	                                                         LPDISPATCH *recoContext);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTimes_) (SpeechLib_ISpeechRecoResult_Interface __RPC_FAR *This, 
	                                                   LPDISPATCH *times);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetByRefAudioFormat_) (SpeechLib_ISpeechRecoResult_Interface __RPC_FAR *This, 
	                                                              LPDISPATCH format);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAudioFormat_) (SpeechLib_ISpeechRecoResult_Interface __RPC_FAR *This, 
	                                                         LPDISPATCH *format);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPhraseInfo_) (SpeechLib_ISpeechRecoResult_Interface __RPC_FAR *This, 
	                                                        LPDISPATCH *phraseInfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Alternates_) (SpeechLib_ISpeechRecoResult_Interface __RPC_FAR *This, 
	                                                     long requestCount, 
	                                                     long startElement, 
	                                                     long elements, 
	                                                     LPDISPATCH *alternates);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Audio_) (SpeechLib_ISpeechRecoResult_Interface __RPC_FAR *This, 
	                                                long startElement, 
	                                                long elements, 
	                                                LPDISPATCH *stream);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SpeakAudio_) (SpeechLib_ISpeechRecoResult_Interface __RPC_FAR *This, 
	                                                     long startElement, 
	                                                     long elements, 
	                                                     long flags, 
	                                                     long *streamNumber);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveToMemory_) (SpeechLib_ISpeechRecoResult_Interface __RPC_FAR *This, 
	                                                       VARIANT *resultBlock);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DiscardResultInfo_) (SpeechLib_ISpeechRecoResult_Interface __RPC_FAR *This, 
	                                                            long valueTypes);

} SpeechLib_ISpeechRecoResult_VTable;

typedef interface tagSpeechLib_ISpeechRecoResult_Interface
{
	CONST_VTBL SpeechLib_ISpeechRecoResult_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpeechRecoResult_Interface;

typedef interface tagSpeechLib_ISpeechRecoResultTimes_Interface SpeechLib_ISpeechRecoResultTimes_Interface;

typedef struct tagSpeechLib_ISpeechRecoResultTimes_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpeechRecoResultTimes_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpeechRecoResultTimes_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpeechRecoResultTimes_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( SpeechLib_ISpeechRecoResultTimes_Interface __RPC_FAR * This, 
	                                                           UINT __RPC_FAR *pctinfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( SpeechLib_ISpeechRecoResultTimes_Interface __RPC_FAR * This, 
	                                                      UINT iTInfo, 
	                                                      LCID lcid, 
	                                                      ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( SpeechLib_ISpeechRecoResultTimes_Interface __RPC_FAR * This, 
	                                                        REFIID riid, 
	                                                        LPOLESTR __RPC_FAR *rgszNames, 
	                                                        UINT cNames, 
	                                                        LCID lcid, 
	                                                        DISPID __RPC_FAR *rgDispId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( SpeechLib_ISpeechRecoResultTimes_Interface __RPC_FAR * This, 
	                                                 DISPID dispIdMember, 
	                                                 REFIID riid, 
	                                                 LCID lcid, 
	                                                 WORD wFlags, 
	                                                 DISPPARAMS __RPC_FAR *pDispParams, 
	                                                 VARIANT __RPC_FAR *pVarResult, 
	                                                 EXCEPINFO __RPC_FAR *pExcepInfo, 
	                                                 UINT __RPC_FAR *puArgErr);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamTime_) (SpeechLib_ISpeechRecoResultTimes_Interface __RPC_FAR *This, 
	                                                        VARIANT *time);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLength_) (SpeechLib_ISpeechRecoResultTimes_Interface __RPC_FAR *This, 
	                                                    VARIANT *length);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTickCount_) (SpeechLib_ISpeechRecoResultTimes_Interface __RPC_FAR *This, 
	                                                       long *tickCount);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOffsetFromStart_) (SpeechLib_ISpeechRecoResultTimes_Interface __RPC_FAR *This, 
	                                                             VARIANT *offsetFromStart);

} SpeechLib_ISpeechRecoResultTimes_VTable;

typedef interface tagSpeechLib_ISpeechRecoResultTimes_Interface
{
	CONST_VTBL SpeechLib_ISpeechRecoResultTimes_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpeechRecoResultTimes_Interface;

typedef interface tagSpeechLib_ISpeechPhraseInfo_Interface SpeechLib_ISpeechPhraseInfo_Interface;

typedef struct tagSpeechLib_ISpeechPhraseInfo_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpeechPhraseInfo_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpeechPhraseInfo_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpeechPhraseInfo_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( SpeechLib_ISpeechPhraseInfo_Interface __RPC_FAR * This, 
	                                                           UINT __RPC_FAR *pctinfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( SpeechLib_ISpeechPhraseInfo_Interface __RPC_FAR * This, 
	                                                      UINT iTInfo, 
	                                                      LCID lcid, 
	                                                      ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( SpeechLib_ISpeechPhraseInfo_Interface __RPC_FAR * This, 
	                                                        REFIID riid, 
	                                                        LPOLESTR __RPC_FAR *rgszNames, 
	                                                        UINT cNames, 
	                                                        LCID lcid, 
	                                                        DISPID __RPC_FAR *rgDispId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( SpeechLib_ISpeechPhraseInfo_Interface __RPC_FAR * This, 
	                                                 DISPID dispIdMember, 
	                                                 REFIID riid, 
	                                                 LCID lcid, 
	                                                 WORD wFlags, 
	                                                 DISPPARAMS __RPC_FAR *pDispParams, 
	                                                 VARIANT __RPC_FAR *pVarResult, 
	                                                 EXCEPINFO __RPC_FAR *pExcepInfo, 
	                                                 UINT __RPC_FAR *puArgErr);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLanguageId_) (SpeechLib_ISpeechPhraseInfo_Interface __RPC_FAR *This, 
	                                                        long *languageId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetGrammarId_) (SpeechLib_ISpeechPhraseInfo_Interface __RPC_FAR *This, 
	                                                       VARIANT *grammarId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStartTime_) (SpeechLib_ISpeechPhraseInfo_Interface __RPC_FAR *This, 
	                                                       VARIANT *startTime);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAudioStreamPosition_) (SpeechLib_ISpeechPhraseInfo_Interface __RPC_FAR *This, 
	                                                                 VARIANT *audioStreamPosition);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAudioSizeBytes_) (SpeechLib_ISpeechPhraseInfo_Interface __RPC_FAR *This, 
	                                                            long *pAudioSizeBytes);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRetainedSizeBytes_) (SpeechLib_ISpeechPhraseInfo_Interface __RPC_FAR *This, 
	                                                               long *retainedSizeBytes);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAudioSizeTime_) (SpeechLib_ISpeechPhraseInfo_Interface __RPC_FAR *This, 
	                                                           long *audioSizeTime);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRule_) (SpeechLib_ISpeechPhraseInfo_Interface __RPC_FAR *This, 
	                                                  LPDISPATCH *rule);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProperties_) (SpeechLib_ISpeechPhraseInfo_Interface __RPC_FAR *This, 
	                                                        LPDISPATCH *properties);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetElements_) (SpeechLib_ISpeechPhraseInfo_Interface __RPC_FAR *This, 
	                                                      LPDISPATCH *elements);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetReplacements_) (SpeechLib_ISpeechPhraseInfo_Interface __RPC_FAR *This, 
	                                                          LPDISPATCH *replacements);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEngineId_) (SpeechLib_ISpeechPhraseInfo_Interface __RPC_FAR *This, 
	                                                      BSTR *engineIdGuid);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEnginePrivateData_) (SpeechLib_ISpeechPhraseInfo_Interface __RPC_FAR *This, 
	                                                               VARIANT *privateData);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveToMemory_) (SpeechLib_ISpeechPhraseInfo_Interface __RPC_FAR *This, 
	                                                       VARIANT *phraseBlock);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetText_) (SpeechLib_ISpeechPhraseInfo_Interface __RPC_FAR *This, 
	                                                  long startElement, 
	                                                  long elements, 
	                                                  VBOOL useReplacements, 
	                                                  BSTR *text);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDisplayAttributes_) (SpeechLib_ISpeechPhraseInfo_Interface __RPC_FAR *This, 
	                                                               long startElement, 
	                                                               long elements, 
	                                                               VBOOL useReplacements, 
	                                                               long *displayAttributes);

} SpeechLib_ISpeechPhraseInfo_VTable;

typedef interface tagSpeechLib_ISpeechPhraseInfo_Interface
{
	CONST_VTBL SpeechLib_ISpeechPhraseInfo_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpeechPhraseInfo_Interface;

typedef interface tagSpeechLib_ISpeechPhraseRule_Interface SpeechLib_ISpeechPhraseRule_Interface;

typedef struct tagSpeechLib_ISpeechPhraseRule_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpeechPhraseRule_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpeechPhraseRule_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpeechPhraseRule_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( SpeechLib_ISpeechPhraseRule_Interface __RPC_FAR * This, 
	                                                           UINT __RPC_FAR *pctinfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( SpeechLib_ISpeechPhraseRule_Interface __RPC_FAR * This, 
	                                                      UINT iTInfo, 
	                                                      LCID lcid, 
	                                                      ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( SpeechLib_ISpeechPhraseRule_Interface __RPC_FAR * This, 
	                                                        REFIID riid, 
	                                                        LPOLESTR __RPC_FAR *rgszNames, 
	                                                        UINT cNames, 
	                                                        LCID lcid, 
	                                                        DISPID __RPC_FAR *rgDispId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( SpeechLib_ISpeechPhraseRule_Interface __RPC_FAR * This, 
	                                                 DISPID dispIdMember, 
	                                                 REFIID riid, 
	                                                 LCID lcid, 
	                                                 WORD wFlags, 
	                                                 DISPPARAMS __RPC_FAR *pDispParams, 
	                                                 VARIANT __RPC_FAR *pVarResult, 
	                                                 EXCEPINFO __RPC_FAR *pExcepInfo, 
	                                                 UINT __RPC_FAR *puArgErr);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName_) (SpeechLib_ISpeechPhraseRule_Interface __RPC_FAR *This, 
	                                                  BSTR *name);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetId_) (SpeechLib_ISpeechPhraseRule_Interface __RPC_FAR *This, 
	                                                long *id);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFirstElement_) (SpeechLib_ISpeechPhraseRule_Interface __RPC_FAR *This, 
	                                                          long *firstElement);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNumberOfElements_) (SpeechLib_ISpeechPhraseRule_Interface __RPC_FAR *This, 
	                                                              long *numberOfElements);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetParent_) (SpeechLib_ISpeechPhraseRule_Interface __RPC_FAR *This, 
	                                                    LPDISPATCH *parent);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetChildren_) (SpeechLib_ISpeechPhraseRule_Interface __RPC_FAR *This, 
	                                                      LPDISPATCH *children);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConfidence_) (SpeechLib_ISpeechPhraseRule_Interface __RPC_FAR *This, 
	                                                        long *actualConfidence);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEngineConfidence_) (SpeechLib_ISpeechPhraseRule_Interface __RPC_FAR *This, 
	                                                              float *engineConfidence);

} SpeechLib_ISpeechPhraseRule_VTable;

typedef interface tagSpeechLib_ISpeechPhraseRule_Interface
{
	CONST_VTBL SpeechLib_ISpeechPhraseRule_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpeechPhraseRule_Interface;

typedef interface tagSpeechLib_ISpeechPhraseRules_Interface SpeechLib_ISpeechPhraseRules_Interface;

typedef struct tagSpeechLib_ISpeechPhraseRules_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpeechPhraseRules_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpeechPhraseRules_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpeechPhraseRules_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( SpeechLib_ISpeechPhraseRules_Interface __RPC_FAR * This, 
	                                                           UINT __RPC_FAR *pctinfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( SpeechLib_ISpeechPhraseRules_Interface __RPC_FAR * This, 
	                                                      UINT iTInfo, 
	                                                      LCID lcid, 
	                                                      ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( SpeechLib_ISpeechPhraseRules_Interface __RPC_FAR * This, 
	                                                        REFIID riid, 
	                                                        LPOLESTR __RPC_FAR *rgszNames, 
	                                                        UINT cNames, 
	                                                        LCID lcid, 
	                                                        DISPID __RPC_FAR *rgDispId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( SpeechLib_ISpeechPhraseRules_Interface __RPC_FAR * This, 
	                                                 DISPID dispIdMember, 
	                                                 REFIID riid, 
	                                                 LCID lcid, 
	                                                 WORD wFlags, 
	                                                 DISPPARAMS __RPC_FAR *pDispParams, 
	                                                 VARIANT __RPC_FAR *pVarResult, 
	                                                 EXCEPINFO __RPC_FAR *pExcepInfo, 
	                                                 UINT __RPC_FAR *puArgErr);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount_) (SpeechLib_ISpeechPhraseRules_Interface __RPC_FAR *This, 
	                                                   long *count);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Item_) (SpeechLib_ISpeechPhraseRules_Interface __RPC_FAR *This, 
	                                               long index, 
	                                               LPDISPATCH *rule);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get_NewEnum_) (SpeechLib_ISpeechPhraseRules_Interface __RPC_FAR *This, 
	                                                      LPUNKNOWN *enumVARIANT);

} SpeechLib_ISpeechPhraseRules_VTable;

typedef interface tagSpeechLib_ISpeechPhraseRules_Interface
{
	CONST_VTBL SpeechLib_ISpeechPhraseRules_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpeechPhraseRules_Interface;

typedef interface tagSpeechLib_ISpeechPhraseProperties_Interface SpeechLib_ISpeechPhraseProperties_Interface;

typedef struct tagSpeechLib_ISpeechPhraseProperties_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpeechPhraseProperties_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpeechPhraseProperties_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpeechPhraseProperties_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( SpeechLib_ISpeechPhraseProperties_Interface __RPC_FAR * This, 
	                                                           UINT __RPC_FAR *pctinfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( SpeechLib_ISpeechPhraseProperties_Interface __RPC_FAR * This, 
	                                                      UINT iTInfo, 
	                                                      LCID lcid, 
	                                                      ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( SpeechLib_ISpeechPhraseProperties_Interface __RPC_FAR * This, 
	                                                        REFIID riid, 
	                                                        LPOLESTR __RPC_FAR *rgszNames, 
	                                                        UINT cNames, 
	                                                        LCID lcid, 
	                                                        DISPID __RPC_FAR *rgDispId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( SpeechLib_ISpeechPhraseProperties_Interface __RPC_FAR * This, 
	                                                 DISPID dispIdMember, 
	                                                 REFIID riid, 
	                                                 LCID lcid, 
	                                                 WORD wFlags, 
	                                                 DISPPARAMS __RPC_FAR *pDispParams, 
	                                                 VARIANT __RPC_FAR *pVarResult, 
	                                                 EXCEPINFO __RPC_FAR *pExcepInfo, 
	                                                 UINT __RPC_FAR *puArgErr);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount_) (SpeechLib_ISpeechPhraseProperties_Interface __RPC_FAR *This, 
	                                                   long *count);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Item_) (SpeechLib_ISpeechPhraseProperties_Interface __RPC_FAR *This, 
	                                               long index, 
	                                               LPDISPATCH *property);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get_NewEnum_) (SpeechLib_ISpeechPhraseProperties_Interface __RPC_FAR *This, 
	                                                      LPUNKNOWN *enumVARIANT);

} SpeechLib_ISpeechPhraseProperties_VTable;

typedef interface tagSpeechLib_ISpeechPhraseProperties_Interface
{
	CONST_VTBL SpeechLib_ISpeechPhraseProperties_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpeechPhraseProperties_Interface;

typedef interface tagSpeechLib_ISpeechPhraseProperty_Interface SpeechLib_ISpeechPhraseProperty_Interface;

typedef struct tagSpeechLib_ISpeechPhraseProperty_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpeechPhraseProperty_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpeechPhraseProperty_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpeechPhraseProperty_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( SpeechLib_ISpeechPhraseProperty_Interface __RPC_FAR * This, 
	                                                           UINT __RPC_FAR *pctinfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( SpeechLib_ISpeechPhraseProperty_Interface __RPC_FAR * This, 
	                                                      UINT iTInfo, 
	                                                      LCID lcid, 
	                                                      ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( SpeechLib_ISpeechPhraseProperty_Interface __RPC_FAR * This, 
	                                                        REFIID riid, 
	                                                        LPOLESTR __RPC_FAR *rgszNames, 
	                                                        UINT cNames, 
	                                                        LCID lcid, 
	                                                        DISPID __RPC_FAR *rgDispId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( SpeechLib_ISpeechPhraseProperty_Interface __RPC_FAR * This, 
	                                                 DISPID dispIdMember, 
	                                                 REFIID riid, 
	                                                 LCID lcid, 
	                                                 WORD wFlags, 
	                                                 DISPPARAMS __RPC_FAR *pDispParams, 
	                                                 VARIANT __RPC_FAR *pVarResult, 
	                                                 EXCEPINFO __RPC_FAR *pExcepInfo, 
	                                                 UINT __RPC_FAR *puArgErr);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName_) (SpeechLib_ISpeechPhraseProperty_Interface __RPC_FAR *This, 
	                                                  BSTR *name);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetId_) (SpeechLib_ISpeechPhraseProperty_Interface __RPC_FAR *This, 
	                                                long *id);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetValue_) (SpeechLib_ISpeechPhraseProperty_Interface __RPC_FAR *This, 
	                                                   VARIANT *value);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFirstElement_) (SpeechLib_ISpeechPhraseProperty_Interface __RPC_FAR *This, 
	                                                          long *firstElement);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNumberOfElements_) (SpeechLib_ISpeechPhraseProperty_Interface __RPC_FAR *This, 
	                                                              long *numberOfElements);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEngineConfidence_) (SpeechLib_ISpeechPhraseProperty_Interface __RPC_FAR *This, 
	                                                              float *confidence);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConfidence_) (SpeechLib_ISpeechPhraseProperty_Interface __RPC_FAR *This, 
	                                                        long *confidence);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetParent_) (SpeechLib_ISpeechPhraseProperty_Interface __RPC_FAR *This, 
	                                                    LPDISPATCH *parentProperty);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetChildren_) (SpeechLib_ISpeechPhraseProperty_Interface __RPC_FAR *This, 
	                                                      LPDISPATCH *children);

} SpeechLib_ISpeechPhraseProperty_VTable;

typedef interface tagSpeechLib_ISpeechPhraseProperty_Interface
{
	CONST_VTBL SpeechLib_ISpeechPhraseProperty_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpeechPhraseProperty_Interface;

typedef interface tagSpeechLib_ISpeechPhraseElements_Interface SpeechLib_ISpeechPhraseElements_Interface;

typedef struct tagSpeechLib_ISpeechPhraseElements_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpeechPhraseElements_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpeechPhraseElements_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpeechPhraseElements_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( SpeechLib_ISpeechPhraseElements_Interface __RPC_FAR * This, 
	                                                           UINT __RPC_FAR *pctinfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( SpeechLib_ISpeechPhraseElements_Interface __RPC_FAR * This, 
	                                                      UINT iTInfo, 
	                                                      LCID lcid, 
	                                                      ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( SpeechLib_ISpeechPhraseElements_Interface __RPC_FAR * This, 
	                                                        REFIID riid, 
	                                                        LPOLESTR __RPC_FAR *rgszNames, 
	                                                        UINT cNames, 
	                                                        LCID lcid, 
	                                                        DISPID __RPC_FAR *rgDispId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( SpeechLib_ISpeechPhraseElements_Interface __RPC_FAR * This, 
	                                                 DISPID dispIdMember, 
	                                                 REFIID riid, 
	                                                 LCID lcid, 
	                                                 WORD wFlags, 
	                                                 DISPPARAMS __RPC_FAR *pDispParams, 
	                                                 VARIANT __RPC_FAR *pVarResult, 
	                                                 EXCEPINFO __RPC_FAR *pExcepInfo, 
	                                                 UINT __RPC_FAR *puArgErr);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount_) (SpeechLib_ISpeechPhraseElements_Interface __RPC_FAR *This, 
	                                                   long *count);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Item_) (SpeechLib_ISpeechPhraseElements_Interface __RPC_FAR *This, 
	                                               long index, 
	                                               LPDISPATCH *element);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get_NewEnum_) (SpeechLib_ISpeechPhraseElements_Interface __RPC_FAR *This, 
	                                                      LPUNKNOWN *enumVARIANT);

} SpeechLib_ISpeechPhraseElements_VTable;

typedef interface tagSpeechLib_ISpeechPhraseElements_Interface
{
	CONST_VTBL SpeechLib_ISpeechPhraseElements_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpeechPhraseElements_Interface;

typedef interface tagSpeechLib_ISpeechPhraseElement_Interface SpeechLib_ISpeechPhraseElement_Interface;

typedef struct tagSpeechLib_ISpeechPhraseElement_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpeechPhraseElement_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpeechPhraseElement_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpeechPhraseElement_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( SpeechLib_ISpeechPhraseElement_Interface __RPC_FAR * This, 
	                                                           UINT __RPC_FAR *pctinfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( SpeechLib_ISpeechPhraseElement_Interface __RPC_FAR * This, 
	                                                      UINT iTInfo, 
	                                                      LCID lcid, 
	                                                      ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( SpeechLib_ISpeechPhraseElement_Interface __RPC_FAR * This, 
	                                                        REFIID riid, 
	                                                        LPOLESTR __RPC_FAR *rgszNames, 
	                                                        UINT cNames, 
	                                                        LCID lcid, 
	                                                        DISPID __RPC_FAR *rgDispId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( SpeechLib_ISpeechPhraseElement_Interface __RPC_FAR * This, 
	                                                 DISPID dispIdMember, 
	                                                 REFIID riid, 
	                                                 LCID lcid, 
	                                                 WORD wFlags, 
	                                                 DISPPARAMS __RPC_FAR *pDispParams, 
	                                                 VARIANT __RPC_FAR *pVarResult, 
	                                                 EXCEPINFO __RPC_FAR *pExcepInfo, 
	                                                 UINT __RPC_FAR *puArgErr);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAudioTimeOffset_) (SpeechLib_ISpeechPhraseElement_Interface __RPC_FAR *This, 
	                                                             long *audioTimeOffset);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAudioSizeTime_) (SpeechLib_ISpeechPhraseElement_Interface __RPC_FAR *This, 
	                                                           long *audioSizeTime);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAudioStreamOffset_) (SpeechLib_ISpeechPhraseElement_Interface __RPC_FAR *This, 
	                                                               long *audioStreamOffset);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAudioSizeBytes_) (SpeechLib_ISpeechPhraseElement_Interface __RPC_FAR *This, 
	                                                            long *audioSizeBytes);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRetainedStreamOffset_) (SpeechLib_ISpeechPhraseElement_Interface __RPC_FAR *This, 
	                                                                  long *retainedStreamOffset);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRetainedSizeBytes_) (SpeechLib_ISpeechPhraseElement_Interface __RPC_FAR *This, 
	                                                               long *retainedSizeBytes);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDisplayText_) (SpeechLib_ISpeechPhraseElement_Interface __RPC_FAR *This, 
	                                                         BSTR *displayText);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLexicalForm_) (SpeechLib_ISpeechPhraseElement_Interface __RPC_FAR *This, 
	                                                         BSTR *lexicalForm);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPronunciation_) (SpeechLib_ISpeechPhraseElement_Interface __RPC_FAR *This, 
	                                                           VARIANT *pronunciation);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDisplayAttributes_) (SpeechLib_ISpeechPhraseElement_Interface __RPC_FAR *This, 
	                                                               long *displayAttributes);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRequiredConfidence_) (SpeechLib_ISpeechPhraseElement_Interface __RPC_FAR *This, 
	                                                                long *requiredConfidence);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetActualConfidence_) (SpeechLib_ISpeechPhraseElement_Interface __RPC_FAR *This, 
	                                                              long *actualConfidence);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEngineConfidence_) (SpeechLib_ISpeechPhraseElement_Interface __RPC_FAR *This, 
	                                                              float *engineConfidence);

} SpeechLib_ISpeechPhraseElement_VTable;

typedef interface tagSpeechLib_ISpeechPhraseElement_Interface
{
	CONST_VTBL SpeechLib_ISpeechPhraseElement_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpeechPhraseElement_Interface;

typedef interface tagSpeechLib_ISpeechPhraseReplacements_Interface SpeechLib_ISpeechPhraseReplacements_Interface;

typedef struct tagSpeechLib_ISpeechPhraseReplacements_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpeechPhraseReplacements_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpeechPhraseReplacements_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpeechPhraseReplacements_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( SpeechLib_ISpeechPhraseReplacements_Interface __RPC_FAR * This, 
	                                                           UINT __RPC_FAR *pctinfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( SpeechLib_ISpeechPhraseReplacements_Interface __RPC_FAR * This, 
	                                                      UINT iTInfo, 
	                                                      LCID lcid, 
	                                                      ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( SpeechLib_ISpeechPhraseReplacements_Interface __RPC_FAR * This, 
	                                                        REFIID riid, 
	                                                        LPOLESTR __RPC_FAR *rgszNames, 
	                                                        UINT cNames, 
	                                                        LCID lcid, 
	                                                        DISPID __RPC_FAR *rgDispId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( SpeechLib_ISpeechPhraseReplacements_Interface __RPC_FAR * This, 
	                                                 DISPID dispIdMember, 
	                                                 REFIID riid, 
	                                                 LCID lcid, 
	                                                 WORD wFlags, 
	                                                 DISPPARAMS __RPC_FAR *pDispParams, 
	                                                 VARIANT __RPC_FAR *pVarResult, 
	                                                 EXCEPINFO __RPC_FAR *pExcepInfo, 
	                                                 UINT __RPC_FAR *puArgErr);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount_) (SpeechLib_ISpeechPhraseReplacements_Interface __RPC_FAR *This, 
	                                                   long *count);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Item_) (SpeechLib_ISpeechPhraseReplacements_Interface __RPC_FAR *This, 
	                                               long index, 
	                                               LPDISPATCH *reps);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get_NewEnum_) (SpeechLib_ISpeechPhraseReplacements_Interface __RPC_FAR *This, 
	                                                      LPUNKNOWN *enumVARIANT);

} SpeechLib_ISpeechPhraseReplacements_VTable;

typedef interface tagSpeechLib_ISpeechPhraseReplacements_Interface
{
	CONST_VTBL SpeechLib_ISpeechPhraseReplacements_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpeechPhraseReplacements_Interface;

typedef interface tagSpeechLib_ISpeechPhraseReplacement_Interface SpeechLib_ISpeechPhraseReplacement_Interface;

typedef struct tagSpeechLib_ISpeechPhraseReplacement_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpeechPhraseReplacement_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpeechPhraseReplacement_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpeechPhraseReplacement_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( SpeechLib_ISpeechPhraseReplacement_Interface __RPC_FAR * This, 
	                                                           UINT __RPC_FAR *pctinfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( SpeechLib_ISpeechPhraseReplacement_Interface __RPC_FAR * This, 
	                                                      UINT iTInfo, 
	                                                      LCID lcid, 
	                                                      ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( SpeechLib_ISpeechPhraseReplacement_Interface __RPC_FAR * This, 
	                                                        REFIID riid, 
	                                                        LPOLESTR __RPC_FAR *rgszNames, 
	                                                        UINT cNames, 
	                                                        LCID lcid, 
	                                                        DISPID __RPC_FAR *rgDispId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( SpeechLib_ISpeechPhraseReplacement_Interface __RPC_FAR * This, 
	                                                 DISPID dispIdMember, 
	                                                 REFIID riid, 
	                                                 LCID lcid, 
	                                                 WORD wFlags, 
	                                                 DISPPARAMS __RPC_FAR *pDispParams, 
	                                                 VARIANT __RPC_FAR *pVarResult, 
	                                                 EXCEPINFO __RPC_FAR *pExcepInfo, 
	                                                 UINT __RPC_FAR *puArgErr);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDisplayAttributes_) (SpeechLib_ISpeechPhraseReplacement_Interface __RPC_FAR *This, 
	                                                               long *displayAttributes);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetText_) (SpeechLib_ISpeechPhraseReplacement_Interface __RPC_FAR *This, 
	                                                  BSTR *text);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFirstElement_) (SpeechLib_ISpeechPhraseReplacement_Interface __RPC_FAR *This, 
	                                                          long *firstElement);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNumberOfElements_) (SpeechLib_ISpeechPhraseReplacement_Interface __RPC_FAR *This, 
	                                                              long *numberOfElements);

} SpeechLib_ISpeechPhraseReplacement_VTable;

typedef interface tagSpeechLib_ISpeechPhraseReplacement_Interface
{
	CONST_VTBL SpeechLib_ISpeechPhraseReplacement_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpeechPhraseReplacement_Interface;

typedef interface tagSpeechLib_ISpeechPhraseAlternates_Interface SpeechLib_ISpeechPhraseAlternates_Interface;

typedef struct tagSpeechLib_ISpeechPhraseAlternates_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpeechPhraseAlternates_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpeechPhraseAlternates_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpeechPhraseAlternates_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( SpeechLib_ISpeechPhraseAlternates_Interface __RPC_FAR * This, 
	                                                           UINT __RPC_FAR *pctinfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( SpeechLib_ISpeechPhraseAlternates_Interface __RPC_FAR * This, 
	                                                      UINT iTInfo, 
	                                                      LCID lcid, 
	                                                      ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( SpeechLib_ISpeechPhraseAlternates_Interface __RPC_FAR * This, 
	                                                        REFIID riid, 
	                                                        LPOLESTR __RPC_FAR *rgszNames, 
	                                                        UINT cNames, 
	                                                        LCID lcid, 
	                                                        DISPID __RPC_FAR *rgDispId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( SpeechLib_ISpeechPhraseAlternates_Interface __RPC_FAR * This, 
	                                                 DISPID dispIdMember, 
	                                                 REFIID riid, 
	                                                 LCID lcid, 
	                                                 WORD wFlags, 
	                                                 DISPPARAMS __RPC_FAR *pDispParams, 
	                                                 VARIANT __RPC_FAR *pVarResult, 
	                                                 EXCEPINFO __RPC_FAR *pExcepInfo, 
	                                                 UINT __RPC_FAR *puArgErr);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount_) (SpeechLib_ISpeechPhraseAlternates_Interface __RPC_FAR *This, 
	                                                   long *count);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Item_) (SpeechLib_ISpeechPhraseAlternates_Interface __RPC_FAR *This, 
	                                               long index, 
	                                               LPDISPATCH *phraseAlternate);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get_NewEnum_) (SpeechLib_ISpeechPhraseAlternates_Interface __RPC_FAR *This, 
	                                                      LPUNKNOWN *enumVARIANT);

} SpeechLib_ISpeechPhraseAlternates_VTable;

typedef interface tagSpeechLib_ISpeechPhraseAlternates_Interface
{
	CONST_VTBL SpeechLib_ISpeechPhraseAlternates_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpeechPhraseAlternates_Interface;

typedef interface tagSpeechLib_ISpeechPhraseAlternate_Interface SpeechLib_ISpeechPhraseAlternate_Interface;

typedef struct tagSpeechLib_ISpeechPhraseAlternate_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpeechPhraseAlternate_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpeechPhraseAlternate_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpeechPhraseAlternate_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( SpeechLib_ISpeechPhraseAlternate_Interface __RPC_FAR * This, 
	                                                           UINT __RPC_FAR *pctinfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( SpeechLib_ISpeechPhraseAlternate_Interface __RPC_FAR * This, 
	                                                      UINT iTInfo, 
	                                                      LCID lcid, 
	                                                      ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( SpeechLib_ISpeechPhraseAlternate_Interface __RPC_FAR * This, 
	                                                        REFIID riid, 
	                                                        LPOLESTR __RPC_FAR *rgszNames, 
	                                                        UINT cNames, 
	                                                        LCID lcid, 
	                                                        DISPID __RPC_FAR *rgDispId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( SpeechLib_ISpeechPhraseAlternate_Interface __RPC_FAR * This, 
	                                                 DISPID dispIdMember, 
	                                                 REFIID riid, 
	                                                 LCID lcid, 
	                                                 WORD wFlags, 
	                                                 DISPPARAMS __RPC_FAR *pDispParams, 
	                                                 VARIANT __RPC_FAR *pVarResult, 
	                                                 EXCEPINFO __RPC_FAR *pExcepInfo, 
	                                                 UINT __RPC_FAR *puArgErr);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRecoResult_) (SpeechLib_ISpeechPhraseAlternate_Interface __RPC_FAR *This, 
	                                                        LPDISPATCH *recoResult);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStartElementInResult_) (SpeechLib_ISpeechPhraseAlternate_Interface __RPC_FAR *This, 
	                                                                  long *startElement);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNumberOfElementsInResult_) (SpeechLib_ISpeechPhraseAlternate_Interface __RPC_FAR *This, 
	                                                                      long *numberOfElements);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPhraseInfo_) (SpeechLib_ISpeechPhraseAlternate_Interface __RPC_FAR *This, 
	                                                        LPDISPATCH *phraseInfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Commit_) (SpeechLib_ISpeechPhraseAlternate_Interface __RPC_FAR *This);

} SpeechLib_ISpeechPhraseAlternate_VTable;

typedef interface tagSpeechLib_ISpeechPhraseAlternate_Interface
{
	CONST_VTBL SpeechLib_ISpeechPhraseAlternate_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpeechPhraseAlternate_Interface;

typedef interface tagSpeechLib_ISpeechRecoResult2_Interface SpeechLib_ISpeechRecoResult2_Interface;

typedef struct tagSpeechLib_ISpeechRecoResult2_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpeechRecoResult2_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpeechRecoResult2_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpeechRecoResult2_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( SpeechLib_ISpeechRecoResult2_Interface __RPC_FAR * This, 
	                                                           UINT __RPC_FAR *pctinfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( SpeechLib_ISpeechRecoResult2_Interface __RPC_FAR * This, 
	                                                      UINT iTInfo, 
	                                                      LCID lcid, 
	                                                      ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( SpeechLib_ISpeechRecoResult2_Interface __RPC_FAR * This, 
	                                                        REFIID riid, 
	                                                        LPOLESTR __RPC_FAR *rgszNames, 
	                                                        UINT cNames, 
	                                                        LCID lcid, 
	                                                        DISPID __RPC_FAR *rgDispId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( SpeechLib_ISpeechRecoResult2_Interface __RPC_FAR * This, 
	                                                 DISPID dispIdMember, 
	                                                 REFIID riid, 
	                                                 LCID lcid, 
	                                                 WORD wFlags, 
	                                                 DISPPARAMS __RPC_FAR *pDispParams, 
	                                                 VARIANT __RPC_FAR *pVarResult, 
	                                                 EXCEPINFO __RPC_FAR *pExcepInfo, 
	                                                 UINT __RPC_FAR *puArgErr);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRecoContext_) (SpeechLib_ISpeechRecoResult2_Interface __RPC_FAR *This, 
	                                                         LPDISPATCH *recoContext);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTimes_) (SpeechLib_ISpeechRecoResult2_Interface __RPC_FAR *This, 
	                                                   LPDISPATCH *times);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetByRefAudioFormat_) (SpeechLib_ISpeechRecoResult2_Interface __RPC_FAR *This, 
	                                                              LPDISPATCH format);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAudioFormat_) (SpeechLib_ISpeechRecoResult2_Interface __RPC_FAR *This, 
	                                                         LPDISPATCH *format);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPhraseInfo_) (SpeechLib_ISpeechRecoResult2_Interface __RPC_FAR *This, 
	                                                        LPDISPATCH *phraseInfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Alternates_) (SpeechLib_ISpeechRecoResult2_Interface __RPC_FAR *This, 
	                                                     long requestCount, 
	                                                     long startElement, 
	                                                     long elements, 
	                                                     LPDISPATCH *alternates);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Audio_) (SpeechLib_ISpeechRecoResult2_Interface __RPC_FAR *This, 
	                                                long startElement, 
	                                                long elements, 
	                                                LPDISPATCH *stream);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SpeakAudio_) (SpeechLib_ISpeechRecoResult2_Interface __RPC_FAR *This, 
	                                                     long startElement, 
	                                                     long elements, 
	                                                     long flags, 
	                                                     long *streamNumber);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveToMemory_) (SpeechLib_ISpeechRecoResult2_Interface __RPC_FAR *This, 
	                                                       VARIANT *resultBlock);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DiscardResultInfo_) (SpeechLib_ISpeechRecoResult2_Interface __RPC_FAR *This, 
	                                                            long valueTypes);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTextFeedback_) (SpeechLib_ISpeechRecoResult2_Interface __RPC_FAR *This, 
	                                                          BSTR feedback, 
	                                                          VBOOL wasSuccessful);

} SpeechLib_ISpeechRecoResult2_VTable;

typedef interface tagSpeechLib_ISpeechRecoResult2_Interface
{
	CONST_VTBL SpeechLib_ISpeechRecoResult2_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpeechRecoResult2_Interface;

typedef interface tagSpeechLib_ISpeechLexiconWords_Interface SpeechLib_ISpeechLexiconWords_Interface;

typedef struct tagSpeechLib_ISpeechLexiconWords_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpeechLexiconWords_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpeechLexiconWords_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpeechLexiconWords_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( SpeechLib_ISpeechLexiconWords_Interface __RPC_FAR * This, 
	                                                           UINT __RPC_FAR *pctinfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( SpeechLib_ISpeechLexiconWords_Interface __RPC_FAR * This, 
	                                                      UINT iTInfo, 
	                                                      LCID lcid, 
	                                                      ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( SpeechLib_ISpeechLexiconWords_Interface __RPC_FAR * This, 
	                                                        REFIID riid, 
	                                                        LPOLESTR __RPC_FAR *rgszNames, 
	                                                        UINT cNames, 
	                                                        LCID lcid, 
	                                                        DISPID __RPC_FAR *rgDispId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( SpeechLib_ISpeechLexiconWords_Interface __RPC_FAR * This, 
	                                                 DISPID dispIdMember, 
	                                                 REFIID riid, 
	                                                 LCID lcid, 
	                                                 WORD wFlags, 
	                                                 DISPPARAMS __RPC_FAR *pDispParams, 
	                                                 VARIANT __RPC_FAR *pVarResult, 
	                                                 EXCEPINFO __RPC_FAR *pExcepInfo, 
	                                                 UINT __RPC_FAR *puArgErr);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount_) (SpeechLib_ISpeechLexiconWords_Interface __RPC_FAR *This, 
	                                                   long *count);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Item_) (SpeechLib_ISpeechLexiconWords_Interface __RPC_FAR *This, 
	                                               long index, 
	                                               LPDISPATCH *word);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get_NewEnum_) (SpeechLib_ISpeechLexiconWords_Interface __RPC_FAR *This, 
	                                                      LPUNKNOWN *enumVARIANT);

} SpeechLib_ISpeechLexiconWords_VTable;

typedef interface tagSpeechLib_ISpeechLexiconWords_Interface
{
	CONST_VTBL SpeechLib_ISpeechLexiconWords_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpeechLexiconWords_Interface;

typedef interface tagSpeechLib_ISpeechLexiconWord_Interface SpeechLib_ISpeechLexiconWord_Interface;

typedef struct tagSpeechLib_ISpeechLexiconWord_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpeechLexiconWord_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpeechLexiconWord_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpeechLexiconWord_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( SpeechLib_ISpeechLexiconWord_Interface __RPC_FAR * This, 
	                                                           UINT __RPC_FAR *pctinfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( SpeechLib_ISpeechLexiconWord_Interface __RPC_FAR * This, 
	                                                      UINT iTInfo, 
	                                                      LCID lcid, 
	                                                      ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( SpeechLib_ISpeechLexiconWord_Interface __RPC_FAR * This, 
	                                                        REFIID riid, 
	                                                        LPOLESTR __RPC_FAR *rgszNames, 
	                                                        UINT cNames, 
	                                                        LCID lcid, 
	                                                        DISPID __RPC_FAR *rgDispId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( SpeechLib_ISpeechLexiconWord_Interface __RPC_FAR * This, 
	                                                 DISPID dispIdMember, 
	                                                 REFIID riid, 
	                                                 LCID lcid, 
	                                                 WORD wFlags, 
	                                                 DISPPARAMS __RPC_FAR *pDispParams, 
	                                                 VARIANT __RPC_FAR *pVarResult, 
	                                                 EXCEPINFO __RPC_FAR *pExcepInfo, 
	                                                 UINT __RPC_FAR *puArgErr);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLangId_) (SpeechLib_ISpeechLexiconWord_Interface __RPC_FAR *This, 
	                                                    long *langId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType_) (SpeechLib_ISpeechLexiconWord_Interface __RPC_FAR *This, 
	                                                  long *wordType);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetWord_) (SpeechLib_ISpeechLexiconWord_Interface __RPC_FAR *This, 
	                                                  BSTR *word);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPronunciations_) (SpeechLib_ISpeechLexiconWord_Interface __RPC_FAR *This, 
	                                                            LPDISPATCH *pronunciations);

} SpeechLib_ISpeechLexiconWord_VTable;

typedef interface tagSpeechLib_ISpeechLexiconWord_Interface
{
	CONST_VTBL SpeechLib_ISpeechLexiconWord_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpeechLexiconWord_Interface;

typedef interface tagSpeechLib_ISpeechLexiconPronunciations_Interface SpeechLib_ISpeechLexiconPronunciations_Interface;

typedef struct tagSpeechLib_ISpeechLexiconPronunciations_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpeechLexiconPronunciations_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpeechLexiconPronunciations_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpeechLexiconPronunciations_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( SpeechLib_ISpeechLexiconPronunciations_Interface __RPC_FAR * This, 
	                                                           UINT __RPC_FAR *pctinfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( SpeechLib_ISpeechLexiconPronunciations_Interface __RPC_FAR * This, 
	                                                      UINT iTInfo, 
	                                                      LCID lcid, 
	                                                      ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( SpeechLib_ISpeechLexiconPronunciations_Interface __RPC_FAR * This, 
	                                                        REFIID riid, 
	                                                        LPOLESTR __RPC_FAR *rgszNames, 
	                                                        UINT cNames, 
	                                                        LCID lcid, 
	                                                        DISPID __RPC_FAR *rgDispId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( SpeechLib_ISpeechLexiconPronunciations_Interface __RPC_FAR * This, 
	                                                 DISPID dispIdMember, 
	                                                 REFIID riid, 
	                                                 LCID lcid, 
	                                                 WORD wFlags, 
	                                                 DISPPARAMS __RPC_FAR *pDispParams, 
	                                                 VARIANT __RPC_FAR *pVarResult, 
	                                                 EXCEPINFO __RPC_FAR *pExcepInfo, 
	                                                 UINT __RPC_FAR *puArgErr);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount_) (SpeechLib_ISpeechLexiconPronunciations_Interface __RPC_FAR *This, 
	                                                   long *count);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Item_) (SpeechLib_ISpeechLexiconPronunciations_Interface __RPC_FAR *This, 
	                                               long index, 
	                                               LPDISPATCH *pronunciation);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get_NewEnum_) (SpeechLib_ISpeechLexiconPronunciations_Interface __RPC_FAR *This, 
	                                                      LPUNKNOWN *enumVARIANT);

} SpeechLib_ISpeechLexiconPronunciations_VTable;

typedef interface tagSpeechLib_ISpeechLexiconPronunciations_Interface
{
	CONST_VTBL SpeechLib_ISpeechLexiconPronunciations_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpeechLexiconPronunciations_Interface;

typedef interface tagSpeechLib_ISpeechLexiconPronunciation_Interface SpeechLib_ISpeechLexiconPronunciation_Interface;

typedef struct tagSpeechLib_ISpeechLexiconPronunciation_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpeechLexiconPronunciation_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpeechLexiconPronunciation_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpeechLexiconPronunciation_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( SpeechLib_ISpeechLexiconPronunciation_Interface __RPC_FAR * This, 
	                                                           UINT __RPC_FAR *pctinfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( SpeechLib_ISpeechLexiconPronunciation_Interface __RPC_FAR * This, 
	                                                      UINT iTInfo, 
	                                                      LCID lcid, 
	                                                      ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( SpeechLib_ISpeechLexiconPronunciation_Interface __RPC_FAR * This, 
	                                                        REFIID riid, 
	                                                        LPOLESTR __RPC_FAR *rgszNames, 
	                                                        UINT cNames, 
	                                                        LCID lcid, 
	                                                        DISPID __RPC_FAR *rgDispId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( SpeechLib_ISpeechLexiconPronunciation_Interface __RPC_FAR * This, 
	                                                 DISPID dispIdMember, 
	                                                 REFIID riid, 
	                                                 LCID lcid, 
	                                                 WORD wFlags, 
	                                                 DISPPARAMS __RPC_FAR *pDispParams, 
	                                                 VARIANT __RPC_FAR *pVarResult, 
	                                                 EXCEPINFO __RPC_FAR *pExcepInfo, 
	                                                 UINT __RPC_FAR *puArgErr);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType_) (SpeechLib_ISpeechLexiconPronunciation_Interface __RPC_FAR *This, 
	                                                  long *lexiconType);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLangId_) (SpeechLib_ISpeechLexiconPronunciation_Interface __RPC_FAR *This, 
	                                                    long *langId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPartOfSpeech_) (SpeechLib_ISpeechLexiconPronunciation_Interface __RPC_FAR *This, 
	                                                          long *partOfSpeech);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPhoneIds_) (SpeechLib_ISpeechLexiconPronunciation_Interface __RPC_FAR *This, 
	                                                      VARIANT *phoneIds);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSymbolic_) (SpeechLib_ISpeechLexiconPronunciation_Interface __RPC_FAR *This, 
	                                                      BSTR *symbolic);

} SpeechLib_ISpeechLexiconPronunciation_VTable;

typedef interface tagSpeechLib_ISpeechLexiconPronunciation_Interface
{
	CONST_VTBL SpeechLib_ISpeechLexiconPronunciation_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpeechLexiconPronunciation_Interface;

typedef interface tagSpeechLib_ISpeechXMLRecoResult_Interface SpeechLib_ISpeechXMLRecoResult_Interface;

typedef struct tagSpeechLib_ISpeechXMLRecoResult_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpeechXMLRecoResult_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpeechXMLRecoResult_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpeechXMLRecoResult_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( SpeechLib_ISpeechXMLRecoResult_Interface __RPC_FAR * This, 
	                                                           UINT __RPC_FAR *pctinfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( SpeechLib_ISpeechXMLRecoResult_Interface __RPC_FAR * This, 
	                                                      UINT iTInfo, 
	                                                      LCID lcid, 
	                                                      ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( SpeechLib_ISpeechXMLRecoResult_Interface __RPC_FAR * This, 
	                                                        REFIID riid, 
	                                                        LPOLESTR __RPC_FAR *rgszNames, 
	                                                        UINT cNames, 
	                                                        LCID lcid, 
	                                                        DISPID __RPC_FAR *rgDispId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( SpeechLib_ISpeechXMLRecoResult_Interface __RPC_FAR * This, 
	                                                 DISPID dispIdMember, 
	                                                 REFIID riid, 
	                                                 LCID lcid, 
	                                                 WORD wFlags, 
	                                                 DISPPARAMS __RPC_FAR *pDispParams, 
	                                                 VARIANT __RPC_FAR *pVarResult, 
	                                                 EXCEPINFO __RPC_FAR *pExcepInfo, 
	                                                 UINT __RPC_FAR *puArgErr);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRecoContext_) (SpeechLib_ISpeechXMLRecoResult_Interface __RPC_FAR *This, 
	                                                         LPDISPATCH *recoContext);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTimes_) (SpeechLib_ISpeechXMLRecoResult_Interface __RPC_FAR *This, 
	                                                   LPDISPATCH *times);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetByRefAudioFormat_) (SpeechLib_ISpeechXMLRecoResult_Interface __RPC_FAR *This, 
	                                                              LPDISPATCH format);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAudioFormat_) (SpeechLib_ISpeechXMLRecoResult_Interface __RPC_FAR *This, 
	                                                         LPDISPATCH *format);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPhraseInfo_) (SpeechLib_ISpeechXMLRecoResult_Interface __RPC_FAR *This, 
	                                                        LPDISPATCH *phraseInfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Alternates_) (SpeechLib_ISpeechXMLRecoResult_Interface __RPC_FAR *This, 
	                                                     long requestCount, 
	                                                     long startElement, 
	                                                     long elements, 
	                                                     LPDISPATCH *alternates);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Audio_) (SpeechLib_ISpeechXMLRecoResult_Interface __RPC_FAR *This, 
	                                                long startElement, 
	                                                long elements, 
	                                                LPDISPATCH *stream);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SpeakAudio_) (SpeechLib_ISpeechXMLRecoResult_Interface __RPC_FAR *This, 
	                                                     long startElement, 
	                                                     long elements, 
	                                                     long flags, 
	                                                     long *streamNumber);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveToMemory_) (SpeechLib_ISpeechXMLRecoResult_Interface __RPC_FAR *This, 
	                                                       VARIANT *resultBlock);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DiscardResultInfo_) (SpeechLib_ISpeechXMLRecoResult_Interface __RPC_FAR *This, 
	                                                            long valueTypes);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetXMLResult_) (SpeechLib_ISpeechXMLRecoResult_Interface __RPC_FAR *This, 
	                                                       long options, 
	                                                       BSTR *pResult);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetXMLErrorInfo_) (SpeechLib_ISpeechXMLRecoResult_Interface __RPC_FAR *This, 
	                                                          long *lineNumber, 
	                                                          BSTR *scriptLine, 
	                                                          BSTR *source, 
	                                                          BSTR *description, 
	                                                          long *resultCode, 
	                                                          VBOOL *isError);

} SpeechLib_ISpeechXMLRecoResult_VTable;

typedef interface tagSpeechLib_ISpeechXMLRecoResult_Interface
{
	CONST_VTBL SpeechLib_ISpeechXMLRecoResult_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpeechXMLRecoResult_Interface;

typedef interface tagSpeechLib_ISpeechRecoResultDispatch_Interface SpeechLib_ISpeechRecoResultDispatch_Interface;

typedef struct tagSpeechLib_ISpeechRecoResultDispatch_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpeechRecoResultDispatch_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpeechRecoResultDispatch_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpeechRecoResultDispatch_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( SpeechLib_ISpeechRecoResultDispatch_Interface __RPC_FAR * This, 
	                                                           UINT __RPC_FAR *pctinfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( SpeechLib_ISpeechRecoResultDispatch_Interface __RPC_FAR * This, 
	                                                      UINT iTInfo, 
	                                                      LCID lcid, 
	                                                      ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( SpeechLib_ISpeechRecoResultDispatch_Interface __RPC_FAR * This, 
	                                                        REFIID riid, 
	                                                        LPOLESTR __RPC_FAR *rgszNames, 
	                                                        UINT cNames, 
	                                                        LCID lcid, 
	                                                        DISPID __RPC_FAR *rgDispId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( SpeechLib_ISpeechRecoResultDispatch_Interface __RPC_FAR * This, 
	                                                 DISPID dispIdMember, 
	                                                 REFIID riid, 
	                                                 LCID lcid, 
	                                                 WORD wFlags, 
	                                                 DISPPARAMS __RPC_FAR *pDispParams, 
	                                                 VARIANT __RPC_FAR *pVarResult, 
	                                                 EXCEPINFO __RPC_FAR *pExcepInfo, 
	                                                 UINT __RPC_FAR *puArgErr);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRecoContext_) (SpeechLib_ISpeechRecoResultDispatch_Interface __RPC_FAR *This, 
	                                                         LPDISPATCH *recoContext);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTimes_) (SpeechLib_ISpeechRecoResultDispatch_Interface __RPC_FAR *This, 
	                                                   LPDISPATCH *times);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetByRefAudioFormat_) (SpeechLib_ISpeechRecoResultDispatch_Interface __RPC_FAR *This, 
	                                                              LPDISPATCH format);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAudioFormat_) (SpeechLib_ISpeechRecoResultDispatch_Interface __RPC_FAR *This, 
	                                                         LPDISPATCH *format);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPhraseInfo_) (SpeechLib_ISpeechRecoResultDispatch_Interface __RPC_FAR *This, 
	                                                        LPDISPATCH *phraseInfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Alternates_) (SpeechLib_ISpeechRecoResultDispatch_Interface __RPC_FAR *This, 
	                                                     long requestCount, 
	                                                     long startElement, 
	                                                     long elements, 
	                                                     LPDISPATCH *alternates);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Audio_) (SpeechLib_ISpeechRecoResultDispatch_Interface __RPC_FAR *This, 
	                                                long startElement, 
	                                                long elements, 
	                                                LPDISPATCH *stream);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SpeakAudio_) (SpeechLib_ISpeechRecoResultDispatch_Interface __RPC_FAR *This, 
	                                                     long startElement, 
	                                                     long elements, 
	                                                     long flags, 
	                                                     long *streamNumber);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveToMemory_) (SpeechLib_ISpeechRecoResultDispatch_Interface __RPC_FAR *This, 
	                                                       VARIANT *resultBlock);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DiscardResultInfo_) (SpeechLib_ISpeechRecoResultDispatch_Interface __RPC_FAR *This, 
	                                                            long valueTypes);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetXMLResult_) (SpeechLib_ISpeechRecoResultDispatch_Interface __RPC_FAR *This, 
	                                                       long options, 
	                                                       BSTR *pResult);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetXMLErrorInfo_) (SpeechLib_ISpeechRecoResultDispatch_Interface __RPC_FAR *This, 
	                                                          long *lineNumber, 
	                                                          BSTR *scriptLine, 
	                                                          BSTR *source, 
	                                                          BSTR *description, 
	                                                          long *resultCode, 
	                                                          VBOOL *isError);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetTextFeedback_) (SpeechLib_ISpeechRecoResultDispatch_Interface __RPC_FAR *This, 
	                                                          BSTR feedback, 
	                                                          VBOOL wasSuccessful);

} SpeechLib_ISpeechRecoResultDispatch_VTable;

typedef interface tagSpeechLib_ISpeechRecoResultDispatch_Interface
{
	CONST_VTBL SpeechLib_ISpeechRecoResultDispatch_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpeechRecoResultDispatch_Interface;

typedef interface tagSpeechLib_ISpNotifySink_Interface SpeechLib_ISpNotifySink_Interface;

typedef struct tagSpeechLib_ISpNotifySink_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpNotifySink_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpNotifySink_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpNotifySink_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Notify_) (SpeechLib_ISpNotifySink_Interface __RPC_FAR *This);

} SpeechLib_ISpNotifySink_VTable;

typedef interface tagSpeechLib_ISpNotifySink_Interface
{
	CONST_VTBL SpeechLib_ISpNotifySink_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpNotifySink_Interface;

typedef interface tagSpeechLib_ISpStreamFormat_Interface SpeechLib_ISpStreamFormat_Interface;

typedef struct tagSpeechLib_ISpStreamFormat_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpStreamFormat_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpStreamFormat_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpStreamFormat_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoteRead_) (SpeechLib_ISpStreamFormat_Interface __RPC_FAR *This, 
	                                                     unsigned char *pv, 
	                                                     unsigned long cb, 
	                                                     unsigned long *pcbRead);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoteWrite_) (SpeechLib_ISpStreamFormat_Interface __RPC_FAR *This, 
	                                                      unsigned char *pv, 
	                                                      unsigned long cb, 
	                                                      unsigned long *pcbWritten);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder3) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder4) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder5) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Commit_) (SpeechLib_ISpStreamFormat_Interface __RPC_FAR *This, 
	                                                 unsigned long grfCommitFlags);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Revert_) (SpeechLib_ISpStreamFormat_Interface __RPC_FAR *This);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder8) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder9) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder10) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone_) (SpeechLib_ISpStreamFormat_Interface __RPC_FAR *This, 
	                                                LPUNKNOWN *ppstm);

} SpeechLib_ISpStreamFormat_VTable;

typedef interface tagSpeechLib_ISpStreamFormat_Interface
{
	CONST_VTBL SpeechLib_ISpStreamFormat_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpStreamFormat_Interface;

typedef interface tagSpeechLib_IStream_Interface SpeechLib_IStream_Interface;

typedef struct tagSpeechLib_IStream_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_IStream_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_IStream_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_IStream_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoteRead_) (SpeechLib_IStream_Interface __RPC_FAR *This, 
	                                                     unsigned char *pv, 
	                                                     unsigned long cb, 
	                                                     unsigned long *pcbRead);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoteWrite_) (SpeechLib_IStream_Interface __RPC_FAR *This, 
	                                                      unsigned char *pv, 
	                                                      unsigned long cb, 
	                                                      unsigned long *pcbWritten);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder3) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder4) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder5) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Commit_) (SpeechLib_IStream_Interface __RPC_FAR *This, 
	                                                 unsigned long grfCommitFlags);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Revert_) (SpeechLib_IStream_Interface __RPC_FAR *This);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder8) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder9) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder10) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone_) (SpeechLib_IStream_Interface __RPC_FAR *This, 
	                                                LPUNKNOWN *ppstm);

} SpeechLib_IStream_VTable;

typedef interface tagSpeechLib_IStream_Interface
{
	CONST_VTBL SpeechLib_IStream_VTable __RPC_FAR *lpVtbl;
} SpeechLib_IStream_Interface;

typedef interface tagSpeechLib_ISequentialStream_Interface SpeechLib_ISequentialStream_Interface;

typedef struct tagSpeechLib_ISequentialStream_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISequentialStream_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISequentialStream_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISequentialStream_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoteRead_) (SpeechLib_ISequentialStream_Interface __RPC_FAR *This, 
	                                                     unsigned char *pv, 
	                                                     unsigned long cb, 
	                                                     unsigned long *pcbRead);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoteWrite_) (SpeechLib_ISequentialStream_Interface __RPC_FAR *This, 
	                                                      unsigned char *pv, 
	                                                      unsigned long cb, 
	                                                      unsigned long *pcbWritten);

} SpeechLib_ISequentialStream_VTable;

typedef interface tagSpeechLib_ISequentialStream_Interface
{
	CONST_VTBL SpeechLib_ISequentialStream_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISequentialStream_Interface;

typedef interface tagSpeechLib_ISpNotifySource_Interface SpeechLib_ISpNotifySource_Interface;

typedef struct tagSpeechLib_ISpNotifySource_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpNotifySource_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpNotifySource_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpNotifySource_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetNotifySink_) (SpeechLib_ISpNotifySource_Interface __RPC_FAR *This, 
	                                                        LPUNKNOWN pNotifySink);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder2) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder3) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder4) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetNotifyWin32Event_) (SpeechLib_ISpNotifySource_Interface __RPC_FAR *This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WaitForNotifyEvent_) (SpeechLib_ISpNotifySource_Interface __RPC_FAR *This, 
	                                                             unsigned long dwMilliseconds);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNotifyEventHandle_) (SpeechLib_ISpNotifySource_Interface __RPC_FAR *This);

} SpeechLib_ISpNotifySource_VTable;

typedef interface tagSpeechLib_ISpNotifySource_Interface
{
	CONST_VTBL SpeechLib_ISpNotifySource_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpNotifySource_Interface;

typedef interface tagSpeechLib_ISpAudio_Interface SpeechLib_ISpAudio_Interface;

typedef struct tagSpeechLib_ISpAudio_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpAudio_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpAudio_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpAudio_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoteRead_) (SpeechLib_ISpAudio_Interface __RPC_FAR *This, 
	                                                     unsigned char *pv, 
	                                                     unsigned long cb, 
	                                                     unsigned long *pcbRead);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoteWrite_) (SpeechLib_ISpAudio_Interface __RPC_FAR *This, 
	                                                      unsigned char *pv, 
	                                                      unsigned long cb, 
	                                                      unsigned long *pcbWritten);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder3) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder4) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder5) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Commit_) (SpeechLib_ISpAudio_Interface __RPC_FAR *This, 
	                                                 unsigned long grfCommitFlags);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Revert_) (SpeechLib_ISpAudio_Interface __RPC_FAR *This);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder8) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder9) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder10) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone_) (SpeechLib_ISpAudio_Interface __RPC_FAR *This, 
	                                                LPUNKNOWN *ppstm);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder12) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder13) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder14) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder15) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder16) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder17) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder18) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EventHandle_) (SpeechLib_ISpAudio_Interface __RPC_FAR *This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetVolumeLevel_) (SpeechLib_ISpAudio_Interface __RPC_FAR *This, 
	                                                         unsigned long *pLevel);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetVolumeLevel_) (SpeechLib_ISpAudio_Interface __RPC_FAR *This, 
	                                                         unsigned long level);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBufferNotifySize_) (SpeechLib_ISpAudio_Interface __RPC_FAR *This, 
	                                                              unsigned long *pcbSize);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBufferNotifySize_) (SpeechLib_ISpAudio_Interface __RPC_FAR *This, 
	                                                              unsigned long cbSize);

} SpeechLib_ISpAudio_VTable;

typedef interface tagSpeechLib_ISpAudio_Interface
{
	CONST_VTBL SpeechLib_ISpAudio_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpAudio_Interface;

typedef interface tagSpeechLib_ISpPhrase_Interface SpeechLib_ISpPhrase_Interface;

typedef struct tagSpeechLib_ISpPhrase_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpPhrase_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpPhrase_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpPhrase_Interface __RPC_FAR * This);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder1) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder2) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder3) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Discard_) (SpeechLib_ISpPhrase_Interface __RPC_FAR *This, 
	                                                  unsigned long dwValueTypes);

} SpeechLib_ISpPhrase_VTable;

typedef interface tagSpeechLib_ISpPhrase_Interface
{
	CONST_VTBL SpeechLib_ISpPhrase_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpPhrase_Interface;

typedef interface tagSpeechLib_ISpRecoGrammar_Interface SpeechLib_ISpRecoGrammar_Interface;

typedef struct tagSpeechLib_ISpRecoGrammar_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpRecoGrammar_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpRecoGrammar_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpRecoGrammar_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResetGrammar_) (SpeechLib_ISpRecoGrammar_Interface __RPC_FAR *This, 
	                                                       unsigned short newLanguage);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder2) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClearRule_) (SpeechLib_ISpRecoGrammar_Interface __RPC_FAR *This, 
	                                                    void *hState);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder4) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder5) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder6) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder7) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Commit_) (SpeechLib_ISpRecoGrammar_Interface __RPC_FAR *This, 
	                                                 unsigned long dwReserved);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder9) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRecoContext_) (SpeechLib_ISpRecoGrammar_Interface __RPC_FAR *This, 
	                                                         LPUNKNOWN *ppRecoCtxt);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder11) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder12) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder13) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder14) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder15) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder16) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRuleIdState_) (SpeechLib_ISpRecoGrammar_Interface __RPC_FAR *This, 
	                                                         unsigned long ulRuleId, 
	                                                         long newState);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder18) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnloadDictation_) (SpeechLib_ISpRecoGrammar_Interface __RPC_FAR *This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDictationState_) (SpeechLib_ISpRecoGrammar_Interface __RPC_FAR *This, 
	                                                            long newState);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder21) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder22) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder23) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetGrammarState_) (SpeechLib_ISpRecoGrammar_Interface __RPC_FAR *This, 
	                                                          long eGrammarState);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder25) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetGrammarState_) (SpeechLib_ISpRecoGrammar_Interface __RPC_FAR *This, 
	                                                          long *peGrammarState);

} SpeechLib_ISpRecoGrammar_VTable;

typedef interface tagSpeechLib_ISpRecoGrammar_Interface
{
	CONST_VTBL SpeechLib_ISpRecoGrammar_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpRecoGrammar_Interface;

typedef interface tagSpeechLib_ISpGrammarBuilder_Interface SpeechLib_ISpGrammarBuilder_Interface;

typedef struct tagSpeechLib_ISpGrammarBuilder_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpGrammarBuilder_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpGrammarBuilder_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpGrammarBuilder_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResetGrammar_) (SpeechLib_ISpGrammarBuilder_Interface __RPC_FAR *This, 
	                                                       unsigned short newLanguage);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder2) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClearRule_) (SpeechLib_ISpGrammarBuilder_Interface __RPC_FAR *This, 
	                                                    void *hState);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder4) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder5) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder6) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder7) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Commit_) (SpeechLib_ISpGrammarBuilder_Interface __RPC_FAR *This, 
	                                                 unsigned long dwReserved);

} SpeechLib_ISpGrammarBuilder_VTable;

typedef interface tagSpeechLib_ISpGrammarBuilder_Interface
{
	CONST_VTBL SpeechLib_ISpGrammarBuilder_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpGrammarBuilder_Interface;

typedef interface tagSpeechLib_ISpRecoResult_Interface SpeechLib_ISpRecoResult_Interface;

typedef struct tagSpeechLib_ISpRecoResult_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpRecoResult_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpRecoResult_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpRecoResult_Interface __RPC_FAR * This);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder1) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder2) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder3) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Discard_) (SpeechLib_ISpRecoResult_Interface __RPC_FAR *This, 
	                                                  unsigned long dwValueTypes);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder5) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAlternates_) (SpeechLib_ISpRecoResult_Interface __RPC_FAR *This, 
	                                                        unsigned long ulStartElement, 
	                                                        unsigned long cElements, 
	                                                        unsigned long ulRequestCount, 
	                                                        LPUNKNOWN *ppPhrases, 
	                                                        unsigned long *pcPhrasesReturned);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAudio_) (SpeechLib_ISpRecoResult_Interface __RPC_FAR *This, 
	                                                   unsigned long ulStartElement, 
	                                                   unsigned long cElements, 
	                                                   LPUNKNOWN *ppStream);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SpeakAudio_) (SpeechLib_ISpRecoResult_Interface __RPC_FAR *This, 
	                                                     unsigned long ulStartElement, 
	                                                     unsigned long cElements, 
	                                                     unsigned long dwFlags, 
	                                                     unsigned long *pulStreamNumber);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder9) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder10) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRecoContext_) (SpeechLib_ISpRecoResult_Interface __RPC_FAR *This, 
	                                                         LPUNKNOWN *ppRecoContext);

} SpeechLib_ISpRecoResult_VTable;

typedef interface tagSpeechLib_ISpRecoResult_Interface
{
	CONST_VTBL SpeechLib_ISpRecoResult_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpRecoResult_Interface;

typedef interface tagSpeechLib_ISpPhraseAlt_Interface SpeechLib_ISpPhraseAlt_Interface;

typedef struct tagSpeechLib_ISpPhraseAlt_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpPhraseAlt_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpPhraseAlt_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpPhraseAlt_Interface __RPC_FAR * This);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder1) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder2) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder3) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Discard_) (SpeechLib_ISpPhraseAlt_Interface __RPC_FAR *This, 
	                                                  unsigned long dwValueTypes);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAltInfo_) (SpeechLib_ISpPhraseAlt_Interface __RPC_FAR *This, 
	                                                     LPUNKNOWN *ppParent, 
	                                                     unsigned long *pulStartElementInParent, 
	                                                     unsigned long *pcElementsInParent, 
	                                                     unsigned long *pcElementsInAlt);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Commit_) (SpeechLib_ISpPhraseAlt_Interface __RPC_FAR *This);

} SpeechLib_ISpPhraseAlt_VTable;

typedef interface tagSpeechLib_ISpPhraseAlt_Interface
{
	CONST_VTBL SpeechLib_ISpPhraseAlt_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpPhraseAlt_Interface;

typedef interface tagSpeechLib_ISpRecoCategory_Interface SpeechLib_ISpRecoCategory_Interface;

typedef struct tagSpeechLib_ISpRecoCategory_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpRecoCategory_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpRecoCategory_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpRecoCategory_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType_) (SpeechLib_ISpRecoCategory_Interface __RPC_FAR *This, 
	                                                  long *peCategoryType);

} SpeechLib_ISpRecoCategory_VTable;

typedef interface tagSpeechLib_ISpRecoCategory_Interface
{
	CONST_VTBL SpeechLib_ISpRecoCategory_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpRecoCategory_Interface;

typedef interface tagSpeechLib_ISpXMLRecoResult_Interface SpeechLib_ISpXMLRecoResult_Interface;

typedef struct tagSpeechLib_ISpXMLRecoResult_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpXMLRecoResult_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpXMLRecoResult_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpXMLRecoResult_Interface __RPC_FAR * This);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder1) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder2) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder3) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Discard_) (SpeechLib_ISpXMLRecoResult_Interface __RPC_FAR *This, 
	                                                  unsigned long dwValueTypes);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder5) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAlternates_) (SpeechLib_ISpXMLRecoResult_Interface __RPC_FAR *This, 
	                                                        unsigned long ulStartElement, 
	                                                        unsigned long cElements, 
	                                                        unsigned long ulRequestCount, 
	                                                        LPUNKNOWN *ppPhrases, 
	                                                        unsigned long *pcPhrasesReturned);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAudio_) (SpeechLib_ISpXMLRecoResult_Interface __RPC_FAR *This, 
	                                                   unsigned long ulStartElement, 
	                                                   unsigned long cElements, 
	                                                   LPUNKNOWN *ppStream);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SpeakAudio_) (SpeechLib_ISpXMLRecoResult_Interface __RPC_FAR *This, 
	                                                     unsigned long ulStartElement, 
	                                                     unsigned long cElements, 
	                                                     unsigned long dwFlags, 
	                                                     unsigned long *pulStreamNumber);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder9) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder10) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRecoContext_) (SpeechLib_ISpXMLRecoResult_Interface __RPC_FAR *This, 
	                                                         LPUNKNOWN *ppRecoContext);

} SpeechLib_ISpXMLRecoResult_VTable;

typedef interface tagSpeechLib_ISpXMLRecoResult_Interface
{
	CONST_VTBL SpeechLib_ISpXMLRecoResult_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpXMLRecoResult_Interface;

typedef interface tagSpeechLib_ISpRecoGrammar2_Interface SpeechLib_ISpRecoGrammar2_Interface;

typedef struct tagSpeechLib_ISpRecoGrammar2_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpRecoGrammar2_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpRecoGrammar2_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpRecoGrammar2_Interface __RPC_FAR * This);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder1) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder2) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder3) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder4) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder5) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDictationWeight_) (SpeechLib_ISpRecoGrammar2_Interface __RPC_FAR *This, 
	                                                             float flWeight);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetGrammarLoader_) (SpeechLib_ISpRecoGrammar2_Interface __RPC_FAR *This, 
	                                                           LPDISPATCH pLoader);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSMLSecurityManager_) (SpeechLib_ISpRecoGrammar2_Interface __RPC_FAR *This, 
	                                                                LPUNKNOWN pSMLSecurityManager);

} SpeechLib_ISpRecoGrammar2_VTable;

typedef interface tagSpeechLib_ISpRecoGrammar2_Interface
{
	CONST_VTBL SpeechLib_ISpRecoGrammar2_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpRecoGrammar2_Interface;

typedef interface tagSpeechLib_ISpeechResourceLoader_Interface SpeechLib_ISpeechResourceLoader_Interface;

typedef struct tagSpeechLib_ISpeechResourceLoader_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_ISpeechResourceLoader_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_ISpeechResourceLoader_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_ISpeechResourceLoader_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( SpeechLib_ISpeechResourceLoader_Interface __RPC_FAR * This, 
	                                                           UINT __RPC_FAR *pctinfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( SpeechLib_ISpeechResourceLoader_Interface __RPC_FAR * This, 
	                                                      UINT iTInfo, 
	                                                      LCID lcid, 
	                                                      ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( SpeechLib_ISpeechResourceLoader_Interface __RPC_FAR * This, 
	                                                        REFIID riid, 
	                                                        LPOLESTR __RPC_FAR *rgszNames, 
	                                                        UINT cNames, 
	                                                        LCID lcid, 
	                                                        DISPID __RPC_FAR *rgDispId);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( SpeechLib_ISpeechResourceLoader_Interface __RPC_FAR * This, 
	                                                 DISPID dispIdMember, 
	                                                 REFIID riid, 
	                                                 LCID lcid, 
	                                                 WORD wFlags, 
	                                                 DISPPARAMS __RPC_FAR *pDispParams, 
	                                                 VARIANT __RPC_FAR *pVarResult, 
	                                                 EXCEPINFO __RPC_FAR *pExcepInfo, 
	                                                 UINT __RPC_FAR *puArgErr);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadResource_) (SpeechLib_ISpeechResourceLoader_Interface __RPC_FAR *This, 
	                                                       BSTR bstrResourceUri, 
	                                                       VBOOL fAlwaysReload, 
	                                                       LPUNKNOWN *pStream, 
	                                                       BSTR *pbstrMIMEType, 
	                                                       VBOOL *pfModified, 
	                                                       BSTR *pbstrRedirectUrl);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLocalCopy_) (SpeechLib_ISpeechResourceLoader_Interface __RPC_FAR *This, 
	                                                       BSTR bstrResourceUri, 
	                                                       BSTR *pbstrLocalPath, 
	                                                       BSTR *pbstrMIMEType, 
	                                                       BSTR *pbstrRedirectUrl);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReleaseLocalCopy_) (SpeechLib_ISpeechResourceLoader_Interface __RPC_FAR *This, 
	                                                           BSTR pbstrLocalPath);

} SpeechLib_ISpeechResourceLoader_VTable;

typedef interface tagSpeechLib_ISpeechResourceLoader_Interface
{
	CONST_VTBL SpeechLib_ISpeechResourceLoader_VTable __RPC_FAR *lpVtbl;
} SpeechLib_ISpeechResourceLoader_Interface;

typedef interface tagSpeechLib_IInternetSecurityManager_Interface SpeechLib_IInternetSecurityManager_Interface;

typedef struct tagSpeechLib_IInternetSecurityManager_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_IInternetSecurityManager_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_IInternetSecurityManager_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_IInternetSecurityManager_Interface __RPC_FAR * This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSecuritySite_) (SpeechLib_IInternetSecurityManager_Interface __RPC_FAR *This, 
	                                                          LPUNKNOWN pSite);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSecuritySite_) (SpeechLib_IInternetSecurityManager_Interface __RPC_FAR *This, 
	                                                          LPUNKNOWN *ppSite);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder3) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder4) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder5) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder6) (void);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder7) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetZoneMappings_) (SpeechLib_IInternetSecurityManager_Interface __RPC_FAR *This, 
	                                                          unsigned long dwZone, 
	                                                          LPUNKNOWN *ppenumString, 
	                                                          unsigned long dwFlags);

} SpeechLib_IInternetSecurityManager_VTable;

typedef interface tagSpeechLib_IInternetSecurityManager_Interface
{
	CONST_VTBL SpeechLib_IInternetSecurityManager_VTable __RPC_FAR *lpVtbl;
} SpeechLib_IInternetSecurityManager_Interface;

typedef interface tagSpeechLib_IInternetSecurityMgrSite_Interface SpeechLib_IInternetSecurityMgrSite_Interface;

typedef struct tagSpeechLib_IInternetSecurityMgrSite_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_IInternetSecurityMgrSite_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_IInternetSecurityMgrSite_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_IInternetSecurityMgrSite_Interface __RPC_FAR * This);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder1) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnableModeless_) (SpeechLib_IInternetSecurityMgrSite_Interface __RPC_FAR *This, 
	                                                         long fEnable);

} SpeechLib_IInternetSecurityMgrSite_VTable;

typedef interface tagSpeechLib_IInternetSecurityMgrSite_Interface
{
	CONST_VTBL SpeechLib_IInternetSecurityMgrSite_VTable __RPC_FAR *lpVtbl;
} SpeechLib_IInternetSecurityMgrSite_Interface;

typedef interface tagSpeechLib_IEnumString_Interface SpeechLib_IEnumString_Interface;

typedef struct tagSpeechLib_IEnumString_VTable
{
	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( SpeechLib_IEnumString_Interface __RPC_FAR * This, 
	                                                         REFIID riid, 
	                                                         void __RPC_FAR *__RPC_FAR *ppvObject);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( SpeechLib_IEnumString_Interface __RPC_FAR * This);

	ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( SpeechLib_IEnumString_Interface __RPC_FAR * This);

	void ( STDMETHODCALLTYPE __RPC_FAR *VtblPlaceHolder1) (void);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip_) (SpeechLib_IEnumString_Interface __RPC_FAR *This, 
	                                               unsigned long celt);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset_) (SpeechLib_IEnumString_Interface __RPC_FAR *This);

	HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone_) (SpeechLib_IEnumString_Interface __RPC_FAR *This, 
	                                                LPUNKNOWN *ppEnum);

} SpeechLib_IEnumString_VTable;

typedef interface tagSpeechLib_IEnumString_Interface
{
	CONST_VTBL SpeechLib_IEnumString_VTable __RPC_FAR *lpVtbl;
} SpeechLib_IEnumString_Interface;

static CA_PARAMDATA __ISpeechVoiceEvents_RegOnStartStream_CA_PARAMDATA[] =
	{
		{"streamNumber", VT_I4},
        {"streamPosition", VT_VARIANT}
	};

static CA_PARAMDATA __ISpeechVoiceEvents_RegOnEndStream_CA_PARAMDATA[] =
	{
		{"streamNumber", VT_I4},
        {"streamPosition", VT_VARIANT}
	};

static CA_PARAMDATA __ISpeechVoiceEvents_RegOnVoiceChange_CA_PARAMDATA[] =
	{
		{"streamNumber", VT_I4},
        {"streamPosition", VT_VARIANT},
        {"voiceObjectToken", VT_DISPATCH}
	};

static CA_PARAMDATA __ISpeechVoiceEvents_RegOnBookmark_CA_PARAMDATA[] =
	{
		{"streamNumber", VT_I4},
        {"streamPosition", VT_VARIANT},
        {"bookmark", VT_BSTR},
        {"bookmarkId", VT_I4}
	};

static CA_PARAMDATA __ISpeechVoiceEvents_RegOnWord_CA_PARAMDATA[] =
	{
		{"streamNumber", VT_I4},
        {"streamPosition", VT_VARIANT},
        {"characterPosition", VT_I4},
        {"length", VT_I4}
	};

static CA_PARAMDATA __ISpeechVoiceEvents_RegOnSentence_CA_PARAMDATA[] =
	{
		{"streamNumber", VT_I4},
        {"streamPosition", VT_VARIANT},
        {"characterPosition", VT_I4},
        {"length", VT_I4}
	};

static CA_PARAMDATA __ISpeechVoiceEvents_RegOnPhoneme_CA_PARAMDATA[] =
	{
		{"streamNumber", VT_I4},
        {"streamPosition", VT_VARIANT},
        {"duration", VT_I4},
        {"nextPhoneId", VT_I2},
        {"feature", VT_I4},
        {"currentPhoneId", VT_I2}
	};

static CA_PARAMDATA __ISpeechVoiceEvents_RegOnViseme_CA_PARAMDATA[] =
	{
		{"streamNumber", VT_I4},
        {"streamPosition", VT_VARIANT},
        {"duration", VT_I4},
        {"nextVisemeId", VT_I4},
        {"feature", VT_I4},
        {"currentVisemeId", VT_I4}
	};

static CA_PARAMDATA __ISpeechVoiceEvents_RegOnAudioLevel_CA_PARAMDATA[] =
	{
		{"streamNumber", VT_I4},
        {"streamPosition", VT_VARIANT},
        {"audioLevel", VT_I4}
	};

static CA_PARAMDATA __ISpeechVoiceEvents_RegOnEnginePrivate_CA_PARAMDATA[] =
	{
		{"streamNumber", VT_I4},
        {"streamPosition", VT_I4},
        {"engineData", VT_VARIANT}
	};

static CA_METHODDATA __ISpeechVoiceEvents_CA_METHODDATA[] =
	{
		{"StartStream", __ISpeechVoiceEvents_RegOnStartStream_CA_PARAMDATA, 1, 0, CC_STDCALL, 2, DISPATCH_METHOD, VT_EMPTY},
        {"EndStream", __ISpeechVoiceEvents_RegOnEndStream_CA_PARAMDATA, 2, 1, CC_STDCALL, 2, DISPATCH_METHOD, VT_EMPTY},
        {"VoiceChange", __ISpeechVoiceEvents_RegOnVoiceChange_CA_PARAMDATA, 3, 2, CC_STDCALL, 3, DISPATCH_METHOD, VT_EMPTY},
        {"Bookmark", __ISpeechVoiceEvents_RegOnBookmark_CA_PARAMDATA, 4, 3, CC_STDCALL, 4, DISPATCH_METHOD, VT_EMPTY},
        {"Word", __ISpeechVoiceEvents_RegOnWord_CA_PARAMDATA, 5, 4, CC_STDCALL, 4, DISPATCH_METHOD, VT_EMPTY},
        {"Sentence", __ISpeechVoiceEvents_RegOnSentence_CA_PARAMDATA, 7, 5, CC_STDCALL, 4, DISPATCH_METHOD, VT_EMPTY},
        {"Phoneme", __ISpeechVoiceEvents_RegOnPhoneme_CA_PARAMDATA, 6, 6, CC_STDCALL, 6, DISPATCH_METHOD, VT_EMPTY},
        {"Viseme", __ISpeechVoiceEvents_RegOnViseme_CA_PARAMDATA, 8, 7, CC_STDCALL, 6, DISPATCH_METHOD, VT_EMPTY},
        {"AudioLevel", __ISpeechVoiceEvents_RegOnAudioLevel_CA_PARAMDATA, 9, 8, CC_STDCALL, 3, DISPATCH_METHOD, VT_EMPTY},
        {"EnginePrivate", __ISpeechVoiceEvents_RegOnEnginePrivate_CA_PARAMDATA, 10, 9, CC_STDCALL, 3, DISPATCH_METHOD, VT_EMPTY}
	};

static CA_INTERFACEDATA __ISpeechVoiceEvents_CA_INTERFACEDATA =
	{
		__ISpeechVoiceEvents_CA_METHODDATA,
        (unsigned int)(sizeof (__ISpeechVoiceEvents_CA_METHODDATA) / sizeof (*__ISpeechVoiceEvents_CA_METHODDATA))
	};

static void * __ISpeechVoiceEvents_EventVTable[] =
	{
		_ISpeechVoiceEventsRegOnStartStream_EventVTableFunc,
        _ISpeechVoiceEventsRegOnEndStream_EventVTableFunc,
        _ISpeechVoiceEventsRegOnVoiceChange_EventVTableFunc,
        _ISpeechVoiceEventsRegOnBookmark_EventVTableFunc,
        _ISpeechVoiceEventsRegOnWord_EventVTableFunc,
        _ISpeechVoiceEventsRegOnSentence_EventVTableFunc,
        _ISpeechVoiceEventsRegOnPhoneme_EventVTableFunc,
        _ISpeechVoiceEventsRegOnViseme_EventVTableFunc,
        _ISpeechVoiceEventsRegOnAudioLevel_EventVTableFunc,
        _ISpeechVoiceEventsRegOnEnginePrivate_EventVTableFunc
	};

static CAEventClassDefn __ISpeechVoiceEvents_CAEventClassDefn =
	{
		(int)sizeof(CAEventClassDefn),
        &SpeechLib_IID__ISpeechVoiceEvents,
        __ISpeechVoiceEvents_EventVTable,
        &__ISpeechVoiceEvents_CA_INTERFACEDATA,
        0
	};

static CA_PARAMDATA __ISpeechRecoContextEvents_RegOnStartStream_CA_PARAMDATA[] =
	{
		{"streamNumber", VT_I4},
        {"streamPosition", VT_VARIANT}
	};

static CA_PARAMDATA __ISpeechRecoContextEvents_RegOnEndStream_CA_PARAMDATA[] =
	{
		{"streamNumber", VT_I4},
        {"streamPosition", VT_VARIANT},
        {"streamReleased", VT_BOOL}
	};

static CA_PARAMDATA __ISpeechRecoContextEvents_RegOnBookmark_CA_PARAMDATA[] =
	{
		{"streamNumber", VT_I4},
        {"streamPosition", VT_VARIANT},
        {"bookmarkId", VT_VARIANT},
        {"options", VT_I4}
	};

static CA_PARAMDATA __ISpeechRecoContextEvents_RegOnSoundStart_CA_PARAMDATA[] =
	{
		{"streamNumber", VT_I4},
        {"streamPosition", VT_VARIANT}
	};

static CA_PARAMDATA __ISpeechRecoContextEvents_RegOnSoundEnd_CA_PARAMDATA[] =
	{
		{"streamNumber", VT_I4},
        {"streamPosition", VT_VARIANT}
	};

static CA_PARAMDATA __ISpeechRecoContextEvents_RegOnPhraseStart_CA_PARAMDATA[] =
	{
		{"streamNumber", VT_I4},
        {"streamPosition", VT_VARIANT}
	};

static CA_PARAMDATA __ISpeechRecoContextEvents_RegOnRecognition_CA_PARAMDATA[] =
	{
		{"streamNumber", VT_I4},
        {"streamPosition", VT_VARIANT},
        {"recognitionType", VT_I4},
        {"result", VT_DISPATCH}
	};

static CA_PARAMDATA __ISpeechRecoContextEvents_RegOnHypothesis_CA_PARAMDATA[] =
	{
		{"streamNumber", VT_I4},
        {"streamPosition", VT_VARIANT},
        {"result", VT_DISPATCH}
	};

static CA_PARAMDATA __ISpeechRecoContextEvents_RegOnPropertyNumberChange_CA_PARAMDATA[] =
	{
		{"streamNumber", VT_I4},
        {"streamPosition", VT_VARIANT},
        {"propertyName", VT_BSTR},
        {"newNumberValue", VT_I4}
	};

static CA_PARAMDATA __ISpeechRecoContextEvents_RegOnPropertyStringChange_CA_PARAMDATA[] =
	{
		{"streamNumber", VT_I4},
        {"streamPosition", VT_VARIANT},
        {"propertyName", VT_BSTR},
        {"newStringValue", VT_BSTR}
	};

static CA_PARAMDATA __ISpeechRecoContextEvents_RegOnFalseRecognition_CA_PARAMDATA[] =
	{
		{"streamNumber", VT_I4},
        {"streamPosition", VT_VARIANT},
        {"result", VT_DISPATCH}
	};

static CA_PARAMDATA __ISpeechRecoContextEvents_RegOnInterference_CA_PARAMDATA[] =
	{
		{"streamNumber", VT_I4},
        {"streamPosition", VT_VARIANT},
        {"interference", VT_I4}
	};

static CA_PARAMDATA __ISpeechRecoContextEvents_RegOnRequestUI_CA_PARAMDATA[] =
	{
		{"streamNumber", VT_I4},
        {"streamPosition", VT_VARIANT},
        {"UIType", VT_BSTR}
	};

static CA_PARAMDATA __ISpeechRecoContextEvents_RegOnRecognizerStateChange_CA_PARAMDATA[] =
	{
		{"streamNumber", VT_I4},
        {"streamPosition", VT_VARIANT},
        {"newState", VT_I4}
	};

static CA_PARAMDATA __ISpeechRecoContextEvents_RegOnAdaptation_CA_PARAMDATA[] =
	{
		{"streamNumber", VT_I4},
        {"streamPosition", VT_VARIANT}
	};

static CA_PARAMDATA __ISpeechRecoContextEvents_RegOnRecognitionForOtherContext_CA_PARAMDATA[] =
	{
		{"streamNumber", VT_I4},
        {"streamPosition", VT_VARIANT}
	};

static CA_PARAMDATA __ISpeechRecoContextEvents_RegOnAudioLevel_CA_PARAMDATA[] =
	{
		{"streamNumber", VT_I4},
        {"streamPosition", VT_VARIANT},
        {"audioLevel", VT_I4}
	};

static CA_PARAMDATA __ISpeechRecoContextEvents_RegOnEnginePrivate_CA_PARAMDATA[] =
	{
		{"streamNumber", VT_I4},
        {"streamPosition", VT_VARIANT},
        {"engineData", VT_VARIANT}
	};

static CA_METHODDATA __ISpeechRecoContextEvents_CA_METHODDATA[] =
	{
		{"StartStream", __ISpeechRecoContextEvents_RegOnStartStream_CA_PARAMDATA, 1, 0, CC_STDCALL, 2, DISPATCH_METHOD, VT_EMPTY},
        {"EndStream", __ISpeechRecoContextEvents_RegOnEndStream_CA_PARAMDATA, 2, 1, CC_STDCALL, 3, DISPATCH_METHOD, VT_EMPTY},
        {"Bookmark", __ISpeechRecoContextEvents_RegOnBookmark_CA_PARAMDATA, 3, 2, CC_STDCALL, 4, DISPATCH_METHOD, VT_EMPTY},
        {"SoundStart", __ISpeechRecoContextEvents_RegOnSoundStart_CA_PARAMDATA, 4, 3, CC_STDCALL, 2, DISPATCH_METHOD, VT_EMPTY},
        {"SoundEnd", __ISpeechRecoContextEvents_RegOnSoundEnd_CA_PARAMDATA, 5, 4, CC_STDCALL, 2, DISPATCH_METHOD, VT_EMPTY},
        {"PhraseStart", __ISpeechRecoContextEvents_RegOnPhraseStart_CA_PARAMDATA, 6, 5, CC_STDCALL, 2, DISPATCH_METHOD, VT_EMPTY},
        {"Recognition", __ISpeechRecoContextEvents_RegOnRecognition_CA_PARAMDATA, 7, 6, CC_STDCALL, 4, DISPATCH_METHOD, VT_EMPTY},
        {"Hypothesis", __ISpeechRecoContextEvents_RegOnHypothesis_CA_PARAMDATA, 8, 7, CC_STDCALL, 3, DISPATCH_METHOD, VT_EMPTY},
        {"PropertyNumberChange", __ISpeechRecoContextEvents_RegOnPropertyNumberChange_CA_PARAMDATA, 9, 8, CC_STDCALL, 4, DISPATCH_METHOD, VT_EMPTY},
        {"PropertyStringChange", __ISpeechRecoContextEvents_RegOnPropertyStringChange_CA_PARAMDATA, 10, 9, CC_STDCALL, 4, DISPATCH_METHOD, VT_EMPTY},
        {"FalseRecognition", __ISpeechRecoContextEvents_RegOnFalseRecognition_CA_PARAMDATA, 11, 10, CC_STDCALL, 3, DISPATCH_METHOD, VT_EMPTY},
        {"Interference", __ISpeechRecoContextEvents_RegOnInterference_CA_PARAMDATA, 12, 11, CC_STDCALL, 3, DISPATCH_METHOD, VT_EMPTY},
        {"RequestUI", __ISpeechRecoContextEvents_RegOnRequestUI_CA_PARAMDATA, 13, 12, CC_STDCALL, 3, DISPATCH_METHOD, VT_EMPTY},
        {"RecognizerStateChange", __ISpeechRecoContextEvents_RegOnRecognizerStateChange_CA_PARAMDATA, 14, 13, CC_STDCALL, 3, DISPATCH_METHOD, VT_EMPTY},
        {"Adaptation", __ISpeechRecoContextEvents_RegOnAdaptation_CA_PARAMDATA, 15, 14, CC_STDCALL, 2, DISPATCH_METHOD, VT_EMPTY},
        {"RecognitionForOtherContext", __ISpeechRecoContextEvents_RegOnRecognitionForOtherContext_CA_PARAMDATA, 16, 15, CC_STDCALL, 2, DISPATCH_METHOD, VT_EMPTY},
        {"AudioLevel", __ISpeechRecoContextEvents_RegOnAudioLevel_CA_PARAMDATA, 17, 16, CC_STDCALL, 3, DISPATCH_METHOD, VT_EMPTY},
        {"EnginePrivate", __ISpeechRecoContextEvents_RegOnEnginePrivate_CA_PARAMDATA, 18, 17, CC_STDCALL, 3, DISPATCH_METHOD, VT_EMPTY}
	};

static CA_INTERFACEDATA __ISpeechRecoContextEvents_CA_INTERFACEDATA =
	{
		__ISpeechRecoContextEvents_CA_METHODDATA,
        (unsigned int)(sizeof (__ISpeechRecoContextEvents_CA_METHODDATA) / sizeof (*__ISpeechRecoContextEvents_CA_METHODDATA))
	};

static void * __ISpeechRecoContextEvents_EventVTable[] =
	{
		_ISpeechRecoContextEventsRegOnStartStream_EventVTableFunc,
        _ISpeechRecoContextEventsRegOnEndStream_EventVTableFunc,
        _ISpeechRecoContextEventsRegOnBookmark_EventVTableFunc,
        _ISpeechRecoContextEventsRegOnSoundStart_EventVTableFunc,
        _ISpeechRecoContextEventsRegOnSoundEnd_EventVTableFunc,
        _ISpeechRecoContextEventsRegOnPhraseStart_EventVTableFunc,
        _ISpeechRecoContextEventsRegOnRecognition_EventVTableFunc,
        _ISpeechRecoContextEventsRegOnHypothesis_EventVTableFunc,
        _ISpeechRecoContextEventsRegOnPropertyNumberChange_EventVTableFunc,
        _ISpeechRecoContextEventsRegOnPropertyStringChange_EventVTableFunc,
        _ISpeechRecoContextEventsRegOnFalseRecognition_EventVTableFunc,
        _ISpeechRecoContextEventsRegOnInterference_EventVTableFunc,
        _ISpeechRecoContextEventsRegOnRequestUI_EventVTableFunc,
        _ISpeechRecoContextEventsRegOnRecognizerStateChange_EventVTableFunc,
        _ISpeechRecoContextEventsRegOnAdaptation_EventVTableFunc,
        _ISpeechRecoContextEventsRegOnRecognitionForOtherContext_EventVTableFunc,
        _ISpeechRecoContextEventsRegOnAudioLevel_EventVTableFunc,
        _ISpeechRecoContextEventsRegOnEnginePrivate_EventVTableFunc
	};

static CAEventClassDefn __ISpeechRecoContextEvents_CAEventClassDefn =
	{
		(int)sizeof(CAEventClassDefn),
        &SpeechLib_IID__ISpeechRecoContextEvents,
        __ISpeechRecoContextEvents_EventVTable,
        &__ISpeechRecoContextEvents_CA_INTERFACEDATA,
        0
	};

const IID SpeechLib_IID_ISpNotifyTranslator =
	{
		0xACA16614, 0x5D3D, 0x11D2, 0x96, 0xE, 0x0, 0xC0, 0x4F, 0x8E, 0xE6, 0x28
	};

const IID SpeechLib_IID_ISpeechObjectTokenCategory =
	{
		0xCA7EAC50, 0x2D01, 0x4145, 0x86, 0xD4, 0x5A, 0xE7, 0xD7, 0xF, 0x44, 0x69
	};

const IID SpeechLib_IID_ISpObjectTokenCategory =
	{
		0x2D3D3845, 0x39AF, 0x4850, 0xBB, 0xF9, 0x40, 0xB4, 0x97, 0x80, 0x1, 0x1D
	};

const IID SpeechLib_IID_ISpeechObjectToken =
	{
		0xC74A3ADC, 0xB727, 0x4500, 0xA8, 0x4A, 0xB5, 0x26, 0x72, 0x1C, 0x8B, 0x8C
	};

const IID SpeechLib_IID_ISpObjectToken =
	{
		0x14056589, 0xE16C, 0x11D2, 0xBB, 0x90, 0x0, 0xC0, 0x4F, 0x8E, 0xE6, 0xC0
	};

const IID SpeechLib_IID_ISpStreamFormatConverter =
	{
		0x678A932C, 0xEA71, 0x4446, 0x9B, 0x41, 0x78, 0xFD, 0xA6, 0x28, 0xA, 0x29
	};

const IID SpeechLib_IID_IEnumSpObjectTokens =
	{
		0x6B64F9E, 0x7FDA, 0x11D2, 0xB4, 0xF2, 0x0, 0xC0, 0x4F, 0x79, 0x73, 0x96
	};

const IID SpeechLib_IID_ISpeechMMSysAudio =
	{
		0x3C76AF6D, 0x1FD7, 0x4831, 0x81, 0xD1, 0x3B, 0x71, 0xD5, 0xA1, 0x3C, 0x44
	};

const IID SpeechLib_IID_ISpEventSource =
	{
		0xBE7A9CCE, 0x5F9E, 0x11D2, 0x96, 0xF, 0x0, 0xC0, 0x4F, 0x8E, 0xE6, 0x28
	};

const IID SpeechLib_IID_ISpObjectWithToken =
	{
		0x5B559F40, 0xE952, 0x11D2, 0xBB, 0x91, 0x0, 0xC0, 0x4F, 0x8E, 0xE6, 0xC0
	};

const IID SpeechLib_IID_ISpMMSysAudio =
	{
		0x15806F6E, 0x1D70, 0x4B48, 0x98, 0xE6, 0x3B, 0x1A, 0x0, 0x75, 0x9, 0xAB
	};

const IID SpeechLib_IID_ISpStream =
	{
		0x12E3CCA9, 0x7518, 0x44C5, 0xA5, 0xE7, 0xBA, 0x5A, 0x79, 0xCB, 0x92, 0x9E
	};

const IID SpeechLib_IID_ISpeechVoice =
	{
		0x269316D8, 0x57BD, 0x11D2, 0x9E, 0xEE, 0x0, 0xC0, 0x4F, 0x79, 0x73, 0x96
	};

const IID SpeechLib_IID_ISpVoice =
	{
		0x6C44DF74, 0x72B9, 0x4992, 0xA1, 0xEC, 0xEF, 0x99, 0x6E, 0x4, 0x22, 0xD4
	};

const IID SpeechLib_IID_ISpPhoneticAlphabetSelection =
	{
		0xB2745EFD, 0x42CE, 0x48CA, 0x81, 0xF1, 0xA9, 0x6E, 0x2, 0x53, 0x8A, 0x90
	};

const IID SpeechLib_IID_ISpeechRecoContext =
	{
		0x580AA49D, 0x7E1E, 0x4809, 0xB8, 0xE2, 0x57, 0xDA, 0x80, 0x61, 0x4, 0xB8
	};

const IID SpeechLib_IID_ISpRecoContext =
	{
		0xF740A62F, 0x7C15, 0x489E, 0x82, 0x34, 0x94, 0xA, 0x33, 0xD9, 0x27, 0x2D
	};

const IID SpeechLib_IID_ISpRecoContext2 =
	{
		0xBEAD311C, 0x52FF, 0x437F, 0x94, 0x64, 0x6B, 0x21, 0x5, 0x4C, 0xA7, 0x3D
	};

const IID SpeechLib_IID_ISpeechRecognizer =
	{
		0x2D5F1C0C, 0xBD75, 0x4B08, 0x94, 0x78, 0x3B, 0x11, 0xFE, 0xA2, 0x58, 0x6C
	};

const IID SpeechLib_IID_ISpRecognizer =
	{
		0xC2B5F241, 0xDAA0, 0x4507, 0x9E, 0x16, 0x5A, 0x1E, 0xAA, 0x2B, 0x7A, 0x5C
	};

const IID SpeechLib_IID_ISpRecognizer2 =
	{
		0x8FC6D974, 0xC81E, 0x4098, 0x93, 0xC5, 0x1, 0x47, 0xF6, 0x1E, 0xD4, 0xD3
	};

const IID SpeechLib_IID_ISpRecognizer3 =
	{
		0xDF1B943C, 0x5838, 0x4AA2, 0x87, 0x6, 0xD7, 0xCD, 0x5B, 0x33, 0x34, 0x99
	};

const IID SpeechLib_IID_ISpSerializeState =
	{
		0x21B501A0, 0xEC7, 0x46C9, 0x92, 0xC3, 0xA2, 0xBC, 0x78, 0x4C, 0x54, 0xB9
	};

const IID SpeechLib_IID_ISpeechLexicon =
	{
		0x3DA7627A, 0xC7AE, 0x4B23, 0x87, 0x8, 0x63, 0x8C, 0x50, 0x36, 0x2C, 0x25
	};

const IID SpeechLib_IID_ISpLexicon =
	{
		0xDA41A7C2, 0x5383, 0x4DB2, 0x91, 0x6B, 0x6C, 0x17, 0x19, 0xE3, 0xDB, 0x58
	};

const IID SpeechLib_IID_ISpShortcut =
	{
		0x3DF681E2, 0xEA56, 0x11D9, 0x8B, 0xDE, 0xF6, 0x6B, 0xAD, 0x1E, 0x3F, 0x3A
	};

const IID SpeechLib_IID_ISpeechPhoneConverter =
	{
		0xC3E4F353, 0x433F, 0x43D6, 0x89, 0xA1, 0x6A, 0x62, 0xA7, 0x5, 0x4C, 0x3D
	};

const IID SpeechLib_IID_ISpPhoneConverter =
	{
		0x8445C581, 0xCAC, 0x4A38, 0xAB, 0xFE, 0x9B, 0x2C, 0xE2, 0x82, 0x64, 0x55
	};

const IID SpeechLib_IID_ISpPhoneticAlphabetConverter =
	{
		0x133ADCD4, 0x19B4, 0x4020, 0x9F, 0xDC, 0x84, 0x2E, 0x78, 0x25, 0x3B, 0x17
	};

const IID SpeechLib_IID_ISpeechTextSelectionInformation =
	{
		0x3B9C7E7A, 0x6EEE, 0x4DED, 0x90, 0x92, 0x11, 0x65, 0x72, 0x79, 0xAD, 0xBE
	};

const IID SpeechLib_IID_ISpeechPhraseInfoBuilder =
	{
		0x3B151836, 0xDF3A, 0x4E0A, 0x84, 0x6C, 0xD2, 0xAD, 0xC9, 0x33, 0x43, 0x33
	};

const IID SpeechLib_IID_ISpeechAudioFormat =
	{
		0xE6E9C590, 0x3E18, 0x40E3, 0x82, 0x99, 0x6, 0x1F, 0x98, 0xBD, 0xE7, 0xC7
	};

const IID SpeechLib_IID_ISpeechWaveFormatEx =
	{
		0x7A1EF0D5, 0x1581, 0x4741, 0x88, 0xE4, 0x20, 0x9A, 0x49, 0xF1, 0x1A, 0x10
	};

const IID SpeechLib_IID_ISpeechCustomStream =
	{
		0x1A9E9F4F, 0x104F, 0x4DB8, 0xA1, 0x15, 0xEF, 0xD7, 0xFD, 0xC, 0x97, 0xAE
	};

const IID SpeechLib_IID_ISpeechFileStream =
	{
		0xAF67F125, 0xAB39, 0x4E93, 0xB4, 0xA2, 0xCC, 0x2E, 0x66, 0xE1, 0x82, 0xA7
	};

const IID SpeechLib_IID_ISpeechMemoryStream =
	{
		0xEEB14B68, 0x808B, 0x4ABE, 0xA5, 0xEA, 0xB5, 0x1D, 0xA7, 0x58, 0x80, 0x8
	};

const IID SpeechLib_IID__ISpeechVoiceEvents =
	{
		0xA372ACD1, 0x3BEF, 0x4BBD, 0x8F, 0xFB, 0xCB, 0x3E, 0x2B, 0x41, 0x6A, 0xF8
	};

const IID SpeechLib_IID__ISpeechRecoContextEvents =
	{
		0x7B8FCB42, 0xE9D, 0x4F00, 0xA0, 0x48, 0x7B, 0x4, 0xD6, 0x17, 0x9D, 0x3D
	};

const IID SpeechLib_IID_ISpeechDataKey =
	{
		0xCE17C09B, 0x4EFA, 0x44D5, 0xA4, 0xC9, 0x59, 0xD9, 0x58, 0x5A, 0xB0, 0xCD
	};

const IID SpeechLib_IID_ISpeechObjectTokens =
	{
		0x9285B776, 0x2E7B, 0x4BC0, 0xB5, 0x3E, 0x58, 0xE, 0xB6, 0xFA, 0x96, 0x7F
	};

const IID SpeechLib_IID_ISpeechAudioBufferInfo =
	{
		0x11B103D8, 0x1142, 0x4EDF, 0xA0, 0x93, 0x82, 0xFB, 0x39, 0x15, 0xF8, 0xCC
	};

const IID SpeechLib_IID_ISpeechAudioStatus =
	{
		0xC62D9C91, 0x7458, 0x47F6, 0x86, 0x2D, 0x1E, 0xF8, 0x6F, 0xB0, 0xB2, 0x78
	};

const IID SpeechLib_IID_ISpeechBaseStream =
	{
		0x6450336F, 0x7D49, 0x4CED, 0x80, 0x97, 0x49, 0xD6, 0xDE, 0xE3, 0x72, 0x94
	};

const IID SpeechLib_IID_ISpeechAudio =
	{
		0xCFF8E175, 0x19E, 0x11D3, 0xA0, 0x8E, 0x0, 0xC0, 0x4F, 0x8E, 0xF9, 0xB5
	};

const IID SpeechLib_IID_ISpeechVoiceStatus =
	{
		0x8BE47B07, 0x57F6, 0x11D2, 0x9E, 0xEE, 0x0, 0xC0, 0x4F, 0x79, 0x73, 0x96
	};

const IID SpeechLib_IID_ISpeechRecognizerStatus =
	{
		0xBFF9E781, 0x53EC, 0x484E, 0xBB, 0x8A, 0xE, 0x1B, 0x55, 0x51, 0xE3, 0x5C
	};

const IID SpeechLib_IID_ISpeechRecoGrammar =
	{
		0xB6D6F79F, 0x2158, 0x4E50, 0xB5, 0xBC, 0x9A, 0x9C, 0xCD, 0x85, 0x2A, 0x9
	};

const IID SpeechLib_IID_ISpeechGrammarRules =
	{
		0x6FFA3B44, 0xFC2D, 0x40D1, 0x8A, 0xFC, 0x32, 0x91, 0x1C, 0x7F, 0x1A, 0xD1
	};

const IID SpeechLib_IID_ISpeechGrammarRule =
	{
		0xAFE719CF, 0x5DD1, 0x44F2, 0x99, 0x9C, 0x7A, 0x39, 0x9F, 0x1C, 0xFC, 0xCC
	};

const IID SpeechLib_IID_ISpeechGrammarRuleState =
	{
		0xD4286F2C, 0xEE67, 0x45AE, 0xB9, 0x28, 0x28, 0xD6, 0x95, 0x36, 0x2E, 0xDA
	};

const IID SpeechLib_IID_ISpeechGrammarRuleStateTransitions =
	{
		0xEABCE657, 0x75BC, 0x44A2, 0xAA, 0x7F, 0xC5, 0x64, 0x76, 0x74, 0x29, 0x63
	};

const IID SpeechLib_IID_ISpeechGrammarRuleStateTransition =
	{
		0xCAFD1DB1, 0x41D1, 0x4A06, 0x98, 0x63, 0xE2, 0xE8, 0x1D, 0xA1, 0x7A, 0x9A
	};

const IID SpeechLib_IID_ISpeechRecoResult =
	{
		0xED2879CF, 0xCED9, 0x4EE6, 0xA5, 0x34, 0xDE, 0x1, 0x91, 0xD5, 0x46, 0x8D
	};

const IID SpeechLib_IID_ISpeechRecoResultTimes =
	{
		0x62B3B8FB, 0xF6E7, 0x41BE, 0xBD, 0xCB, 0x5, 0x6B, 0x1C, 0x29, 0xEF, 0xC0
	};

const IID SpeechLib_IID_ISpeechPhraseInfo =
	{
		0x961559CF, 0x4E67, 0x4662, 0x8B, 0xF0, 0xD9, 0x3F, 0x1F, 0xCD, 0x61, 0xB3
	};

const IID SpeechLib_IID_ISpeechPhraseRule =
	{
		0xA7BFE112, 0xA4A0, 0x48D9, 0xB6, 0x2, 0xC3, 0x13, 0x84, 0x3F, 0x69, 0x64
	};

const IID SpeechLib_IID_ISpeechPhraseRules =
	{
		0x9047D593, 0x1DD, 0x4B72, 0x81, 0xA3, 0xE4, 0xA0, 0xCA, 0x69, 0xF4, 0x7
	};

const IID SpeechLib_IID_ISpeechPhraseProperties =
	{
		0x8166B47, 0x102E, 0x4B23, 0xA5, 0x99, 0xBD, 0xB9, 0x8D, 0xBF, 0xD1, 0xF4
	};

const IID SpeechLib_IID_ISpeechPhraseProperty =
	{
		0xCE563D48, 0x961E, 0x4732, 0xA2, 0xE1, 0x37, 0x8A, 0x42, 0xB4, 0x30, 0xBE
	};

const IID SpeechLib_IID_ISpeechPhraseElements =
	{
		0x626B328, 0x3478, 0x467D, 0xA0, 0xB3, 0xD0, 0x85, 0x3B, 0x93, 0xDD, 0xA3
	};

const IID SpeechLib_IID_ISpeechPhraseElement =
	{
		0xE6176F96, 0xE373, 0x4801, 0xB2, 0x23, 0x3B, 0x62, 0xC0, 0x68, 0xC0, 0xB4
	};

const IID SpeechLib_IID_ISpeechPhraseReplacements =
	{
		0x38BC662F, 0x2257, 0x4525, 0x95, 0x9E, 0x20, 0x69, 0xD2, 0x59, 0x6C, 0x5
	};

const IID SpeechLib_IID_ISpeechPhraseReplacement =
	{
		0x2890A410, 0x53A7, 0x4FB5, 0x94, 0xEC, 0x6, 0xD4, 0x99, 0x8E, 0x3D, 0x2
	};

const IID SpeechLib_IID_ISpeechPhraseAlternates =
	{
		0xB238B6D5, 0xF276, 0x4C3D, 0xA6, 0xC1, 0x29, 0x74, 0x80, 0x1C, 0x3C, 0xC2
	};

const IID SpeechLib_IID_ISpeechPhraseAlternate =
	{
		0x27864A2A, 0x2B9F, 0x4CB8, 0x92, 0xD3, 0xD, 0x27, 0x22, 0xFD, 0x1E, 0x73
	};

const IID SpeechLib_IID_ISpeechRecoResult2 =
	{
		0x8E0A246D, 0xD3C8, 0x45DE, 0x86, 0x57, 0x4, 0x29, 0xC, 0x45, 0x8C, 0x3C
	};

const IID SpeechLib_IID_ISpeechLexiconWords =
	{
		0x8D199862, 0x415E, 0x47D5, 0xAC, 0x4F, 0xFA, 0xA6, 0x8, 0xB4, 0x24, 0xE6
	};

const IID SpeechLib_IID_ISpeechLexiconWord =
	{
		0x4E5B933C, 0xC9BE, 0x48ED, 0x88, 0x42, 0x1E, 0xE5, 0x1B, 0xB1, 0xD4, 0xFF
	};

const IID SpeechLib_IID_ISpeechLexiconPronunciations =
	{
		0x72829128, 0x5682, 0x4704, 0xA0, 0xD4, 0x3E, 0x2B, 0xB6, 0xF2, 0xEA, 0xD3
	};

const IID SpeechLib_IID_ISpeechLexiconPronunciation =
	{
		0x95252C5D, 0x9E43, 0x4F4A, 0x98, 0x99, 0x48, 0xEE, 0x73, 0x35, 0x2F, 0x9F
	};

const IID SpeechLib_IID_ISpeechXMLRecoResult =
	{
		0xAAEC54AF, 0x8F85, 0x4924, 0x94, 0x4D, 0xB7, 0x9D, 0x39, 0xD7, 0x2E, 0x19
	};

const IID SpeechLib_IID_ISpeechRecoResultDispatch =
	{
		0x6D60EB64, 0xACED, 0x40A6, 0xBB, 0xF3, 0x4E, 0x55, 0x7F, 0x71, 0xDE, 0xE2
	};

const IID SpeechLib_IID_ISpNotifySink =
	{
		0x259684DC, 0x37C3, 0x11D2, 0x96, 0x3, 0x0, 0xC0, 0x4F, 0x8E, 0xE6, 0x28
	};

const IID SpeechLib_IID_ISpStreamFormat =
	{
		0xBED530BE, 0x2606, 0x4F4D, 0xA1, 0xC0, 0x54, 0xC5, 0xCD, 0xA5, 0x56, 0x6F
	};

const IID SpeechLib_IID_IStream =
	{
		0xC, 0x0, 0x0, 0xC0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46
	};

const IID SpeechLib_IID_ISequentialStream =
	{
		0xC733A30, 0x2A1C, 0x11CE, 0xAD, 0xE5, 0x0, 0xAA, 0x0, 0x44, 0x77, 0x3D
	};

const IID SpeechLib_IID_ISpNotifySource =
	{
		0x5EFF4AEF, 0x8487, 0x11D2, 0x96, 0x1C, 0x0, 0xC0, 0x4F, 0x8E, 0xE6, 0x28
	};

const IID SpeechLib_IID_ISpAudio =
	{
		0xC05C768F, 0xFAE8, 0x4EC2, 0x8E, 0x7, 0x33, 0x83, 0x21, 0xC1, 0x24, 0x52
	};

const IID SpeechLib_IID_ISpPhrase =
	{
		0x1A5C0354, 0xB621, 0x4B5A, 0x87, 0x91, 0xD3, 0x6, 0xED, 0x37, 0x9E, 0x53
	};

const IID SpeechLib_IID_ISpRecoGrammar =
	{
		0x2177DB29, 0x7F45, 0x47D0, 0x85, 0x54, 0x6, 0x7E, 0x91, 0xC8, 0x5, 0x2
	};

const IID SpeechLib_IID_ISpGrammarBuilder =
	{
		0x8137828F, 0x591A, 0x4A42, 0xBE, 0x58, 0x49, 0xEA, 0x7E, 0xBA, 0xAC, 0x68
	};

const IID SpeechLib_IID_ISpRecoResult =
	{
		0x20B053BE, 0xE235, 0x43CD, 0x9A, 0x2A, 0x8D, 0x17, 0xA4, 0x8B, 0x78, 0x42
	};

const IID SpeechLib_IID_ISpPhraseAlt =
	{
		0x8FCEBC98, 0x4E49, 0x4067, 0x9C, 0x6C, 0xD8, 0x6A, 0xE, 0x9, 0x2E, 0x3D
	};

const IID SpeechLib_IID_ISpRecoCategory =
	{
		0xDA0CD0F9, 0x14A2, 0x4F09, 0x8C, 0x2A, 0x85, 0xCC, 0x48, 0x97, 0x93, 0x45
	};

const IID SpeechLib_IID_ISpXMLRecoResult =
	{
		0xAE39362B, 0x45A8, 0x4074, 0x9B, 0x9E, 0xCC, 0xF4, 0x9A, 0xA2, 0xD0, 0xB6
	};

const IID SpeechLib_IID_ISpRecoGrammar2 =
	{
		0x4B37BC9E, 0x9ED6, 0x44A3, 0x93, 0xD3, 0x18, 0xF0, 0x22, 0xB7, 0x9E, 0xC3
	};

const IID SpeechLib_IID_ISpeechResourceLoader =
	{
		0xB9AC5783, 0xFCD0, 0x4B21, 0xB1, 0x19, 0xB4, 0xF8, 0xDA, 0x8F, 0xD2, 0xC3
	};

const IID SpeechLib_IID_IInternetSecurityManager =
	{
		0x79EAC9EE, 0xBAF9, 0x11CE, 0x8C, 0x82, 0x0, 0xAA, 0x0, 0x4B, 0xA9, 0xB
	};

const IID SpeechLib_IID_IInternetSecurityMgrSite =
	{
		0x79EAC9ED, 0xBAF9, 0x11CE, 0x8C, 0x82, 0x0, 0xAA, 0x0, 0x4B, 0xA9, 0xB
	};

const IID SpeechLib_IID_IEnumString =
	{
		0x101, 0x0, 0x0, 0xC0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x46
	};

const IID SpeechLib_IID_ISpResourceManager =
	{
		0x93384E18, 0x5014, 0x43D5, 0xAD, 0xBB, 0xA7, 0x8E, 0x5, 0x59, 0x26, 0xBD
	};

const IID SpeechLib_IID_ISpEventSink =
	{
		0xBE7A9CC9, 0x5F9E, 0x11D2, 0x96, 0xF, 0x0, 0xC0, 0x4F, 0x8E, 0xE6, 0x28
	};

const IID SpeechLib_IID_ISpDataKey =
	{
		0x14056581, 0xE16C, 0x11D2, 0xBB, 0x90, 0x0, 0xC0, 0x4F, 0x8E, 0xE6, 0xC0
	};

const IID SpeechLib_IID_IServiceProvider =
	{
		0x6D5140C1, 0x7436, 0x11CE, 0x80, 0x34, 0x0, 0xAA, 0x0, 0x60, 0x9, 0xFA
	};

const IID SpeechLib_IID_ISpProperties =
	{
		0x5B4FB971, 0xB115, 0x4DE1, 0xAD, 0x97, 0xE4, 0x82, 0xE3, 0xBF, 0x6E, 0xE4
	};

HRESULT CVIFUNC SpeechLib_NewISpNotifyTranslator (const char *server,
                                                  int supportMultithreading,
                                                  LCID locale, int reserved,
                                                  CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xE2AE5372, 0x5D40, 0x11D2, 0x96, 0xE, 0x0, 0xC0, 0x4F, 0x8E,
	              0xE6, 0x28};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpNotifyTranslator,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenISpNotifyTranslator (const char *fileName,
                                                   const char *server,
                                                   int supportMultithreading,
                                                   LCID locale, int reserved,
                                                   CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xE2AE5372, 0x5D40, 0x11D2, 0x96, 0xE, 0x0, 0xC0, 0x4F, 0x8E,
	              0xE6, 0x28};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpNotifyTranslator,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveISpNotifyTranslator (const char *server,
                                                     int supportMultithreading,
                                                     LCID locale, int reserved,
                                                     CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xE2AE5372, 0x5D40, 0x11D2, 0x96, 0xE, 0x0, 0xC0, 0x4F, 0x8E,
	              0xE6, 0x28};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpNotifyTranslator,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpNotifyTranslatorNotify (CAObjHandle objectHandle,
                                                     ERRORINFO *errorInfo)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpNotifyTranslator_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpNotifyTranslator,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Notify_ (__vtblIFacePtr));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpNotifyTranslator,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpNotifyTranslatorInitWin32Event (CAObjHandle objectHandle,
                                                             ERRORINFO *errorInfo,
                                                             void *hEvent,
                                                             long fCloseHandleOnRelease)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpNotifyTranslator_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpNotifyTranslator,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->InitWin32Event_ (__vtblIFacePtr,
	                                                     hEvent,
	                                                     fCloseHandleOnRelease));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpNotifyTranslator,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpNotifyTranslatorWait (CAObjHandle objectHandle,
                                                   ERRORINFO *errorInfo,
                                                   unsigned long dwMilliseconds)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpNotifyTranslator_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpNotifyTranslator,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Wait_ (__vtblIFacePtr, dwMilliseconds));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpNotifyTranslator,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpNotifyTranslatorGetEventHandle (CAObjHandle objectHandle,
                                                             ERRORINFO *errorInfo)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpNotifyTranslator_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpNotifyTranslator,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetEventHandle_ (__vtblIFacePtr));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpNotifyTranslator,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_NewISpeechObjectTokenCategory (const char *server,
                                                         int supportMultithreading,
                                                         LCID locale,
                                                         int reserved,
                                                         CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xA910187F, 0xC7A, 0x45AC, 0x92, 0xCC, 0x59, 0xED, 0xAF,
	              0xB7, 0x7B, 0x53};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpeechObjectTokenCategory,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenISpeechObjectTokenCategory (const char *fileName,
                                                          const char *server,
                                                          int supportMultithreading,
                                                          LCID locale,
                                                          int reserved,
                                                          CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xA910187F, 0xC7A, 0x45AC, 0x92, 0xCC, 0x59, 0xED, 0xAF,
	              0xB7, 0x7B, 0x53};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpeechObjectTokenCategory,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveISpeechObjectTokenCategory (const char *server,
                                                            int supportMultithreading,
                                                            LCID locale,
                                                            int reserved,
                                                            CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xA910187F, 0xC7A, 0x45AC, 0x92, 0xCC, 0x59, 0xED, 0xAF,
	              0xB7, 0x7B, 0x53};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpeechObjectTokenCategory,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechObjectTokenCategoryGetId (CAObjHandle objectHandle,
                                                           ERRORINFO *errorInfo,
                                                           char **id)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechObjectTokenCategory_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR id__AutoType = 0;

	if (id)
		*id = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechObjectTokenCategory,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetId_ (__vtblIFacePtr, &id__AutoType));

	if (id)
		__caErrChk (CA_BSTRGetCString (id__AutoType, id));

Error:
	CA_FreeBSTR (id__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (id)
			{
			CA_FreeMemory (*id);
			*id = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle,
	                    &SpeechLib_IID_ISpeechObjectTokenCategory, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechObjectTokenCategorySetDefault (CAObjHandle objectHandle,
                                                                ERRORINFO *errorInfo,
                                                                const char *tokenId)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechObjectTokenCategory_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR tokenId__AutoType = 0;

	__caErrChk (CA_CStringToBSTR (tokenId, &tokenId__AutoType));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechObjectTokenCategory,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetDefault_ (__vtblIFacePtr,
	                                                 tokenId__AutoType));

Error:
	CA_FreeBSTR (tokenId__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle,
	                    &SpeechLib_IID_ISpeechObjectTokenCategory, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechObjectTokenCategoryGetDefault (CAObjHandle objectHandle,
                                                                ERRORINFO *errorInfo,
                                                                char **tokenId)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechObjectTokenCategory_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR tokenId__AutoType = 0;

	if (tokenId)
		*tokenId = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechObjectTokenCategory,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetDefault_ (__vtblIFacePtr,
	                                                 &tokenId__AutoType));

	if (tokenId)
		__caErrChk (CA_BSTRGetCString (tokenId__AutoType, tokenId));

Error:
	CA_FreeBSTR (tokenId__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (tokenId)
			{
			CA_FreeMemory (*tokenId);
			*tokenId = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle,
	                    &SpeechLib_IID_ISpeechObjectTokenCategory, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechObjectTokenCategorySetId (CAObjHandle objectHandle,
                                                           ERRORINFO *errorInfo,
                                                           const char *id,
                                                           VBOOL createIfNotExist)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechObjectTokenCategory_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR id__AutoType = 0;

	__caErrChk (CA_CStringToBSTR (id, &id__AutoType));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechObjectTokenCategory,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetId_ (__vtblIFacePtr, id__AutoType,
	                                            createIfNotExist));

Error:
	CA_FreeBSTR (id__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle,
	                    &SpeechLib_IID_ISpeechObjectTokenCategory, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechObjectTokenCategoryGetDataKey (CAObjHandle objectHandle,
                                                                ERRORINFO *errorInfo,
                                                                enum SpeechLibEnum_SpeechDataKeyLocation location,
                                                                SpeechLibObj_ISpeechDataKey *dataKey)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechObjectTokenCategory_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH dataKey__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (dataKey)
		*dataKey = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechObjectTokenCategory,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetDataKey_ (__vtblIFacePtr, location,
	                                                 &dataKey__AutoType));
	

	if (dataKey)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (dataKey__AutoType,
		                                             &SpeechLib_IID_ISpeechDataKey,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, dataKey));
		dataKey__AutoType = 0;
		}

Error:
	if (dataKey__AutoType)
		dataKey__AutoType->lpVtbl->Release (dataKey__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (dataKey)
			{
			CA_DiscardObjHandle (*dataKey);
			*dataKey = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle,
	                    &SpeechLib_IID_ISpeechObjectTokenCategory, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechObjectTokenCategoryEnumerateTokens (CAObjHandle objectHandle,
                                                                     ERRORINFO *errorInfo,
                                                                     const char *requiredAttributes,
                                                                     const char *optionalAttributes,
                                                                     SpeechLibObj_ISpeechObjectTokens *tokens)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechObjectTokenCategory_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR requiredAttributes__AutoType = 0;
	BSTR optionalAttributes__AutoType = 0;
	LPDISPATCH tokens__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (tokens)
		*tokens = 0;

	__caErrChk (CA_CStringToBSTR (requiredAttributes,
	                              &requiredAttributes__AutoType));
	__caErrChk (CA_CStringToBSTR (optionalAttributes,
	                              &optionalAttributes__AutoType));
	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechObjectTokenCategory,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->EnumerateTokens_ (__vtblIFacePtr,
	                                                      requiredAttributes__AutoType,
	                                                      optionalAttributes__AutoType,
	                                                      &tokens__AutoType));
	

	if (tokens)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (tokens__AutoType,
		                                             &SpeechLib_IID_ISpeechObjectTokens,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, tokens));
		tokens__AutoType = 0;
		}

Error:
	CA_FreeBSTR (requiredAttributes__AutoType);
	CA_FreeBSTR (optionalAttributes__AutoType);
	if (tokens__AutoType)
		tokens__AutoType->lpVtbl->Release (tokens__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (tokens)
			{
			CA_DiscardObjHandle (*tokens);
			*tokens = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle,
	                    &SpeechLib_IID_ISpeechObjectTokenCategory, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_NewISpObjectTokenCategory (const char *server,
                                                     int supportMultithreading,
                                                     LCID locale, int reserved,
                                                     CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xA910187F, 0xC7A, 0x45AC, 0x92, 0xCC, 0x59, 0xED, 0xAF,
	              0xB7, 0x7B, 0x53};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpObjectTokenCategory,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenISpObjectTokenCategory (const char *fileName,
                                                      const char *server,
                                                      int supportMultithreading,
                                                      LCID locale, int reserved,
                                                      CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xA910187F, 0xC7A, 0x45AC, 0x92, 0xCC, 0x59, 0xED, 0xAF,
	              0xB7, 0x7B, 0x53};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpObjectTokenCategory,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveISpObjectTokenCategory (const char *server,
                                                        int supportMultithreading,
                                                        LCID locale,
                                                        int reserved,
                                                        CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xA910187F, 0xC7A, 0x45AC, 0x92, 0xCC, 0x59, 0xED, 0xAF,
	              0xB7, 0x7B, 0x53};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpObjectTokenCategory,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpObjectTokenCategoryGetDataKey (CAObjHandle objectHandle,
                                                            ERRORINFO *errorInfo,
                                                            enum SpeechLibEnum_SPDATAKEYLOCATION spdkl,
                                                            SpeechLibObj_ISpDataKey *ppDataKey)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpObjectTokenCategory_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN ppDataKey__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (ppDataKey)
		*ppDataKey = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpObjectTokenCategory,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetDataKey_ (__vtblIFacePtr, spdkl,
	                                                 &ppDataKey__AutoType));
	

	if (ppDataKey)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (ppDataKey__AutoType,
		                                             &SpeechLib_IID_ISpDataKey,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, ppDataKey));
		ppDataKey__AutoType = 0;
		}

Error:
	if (ppDataKey__AutoType)
		ppDataKey__AutoType->lpVtbl->Release (ppDataKey__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (ppDataKey)
			{
			CA_DiscardObjHandle (*ppDataKey);
			*ppDataKey = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpObjectTokenCategory,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_NewISpeechObjectToken (const char *server,
                                                 int supportMultithreading,
                                                 LCID locale, int reserved,
                                                 CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xEF411752, 0x3736, 0x4CB4, 0x9C, 0x8C, 0x8E, 0xF4, 0xCC,
	              0xB5, 0x8E, 0xFE};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpeechObjectToken,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenISpeechObjectToken (const char *fileName,
                                                  const char *server,
                                                  int supportMultithreading,
                                                  LCID locale, int reserved,
                                                  CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xEF411752, 0x3736, 0x4CB4, 0x9C, 0x8C, 0x8E, 0xF4, 0xCC,
	              0xB5, 0x8E, 0xFE};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpeechObjectToken,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveISpeechObjectToken (const char *server,
                                                    int supportMultithreading,
                                                    LCID locale, int reserved,
                                                    CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xEF411752, 0x3736, 0x4CB4, 0x9C, 0x8C, 0x8E, 0xF4, 0xCC,
	              0xB5, 0x8E, 0xFE};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpeechObjectToken,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechObjectTokenGetId (CAObjHandle objectHandle,
                                                   ERRORINFO *errorInfo,
                                                   char **objectId)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechObjectToken_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR objectId__AutoType = 0;

	if (objectId)
		*objectId = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechObjectToken,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetId_ (__vtblIFacePtr,
	                                            &objectId__AutoType));

	if (objectId)
		__caErrChk (CA_BSTRGetCString (objectId__AutoType, objectId));

Error:
	CA_FreeBSTR (objectId__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (objectId)
			{
			CA_FreeMemory (*objectId);
			*objectId = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechObjectToken,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechObjectTokenGetDataKey (CAObjHandle objectHandle,
                                                        ERRORINFO *errorInfo,
                                                        SpeechLibObj_ISpeechDataKey *dataKey)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechObjectToken_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH dataKey__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (dataKey)
		*dataKey = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechObjectToken,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetDataKey_ (__vtblIFacePtr,
	                                                 &dataKey__AutoType));
	

	if (dataKey)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (dataKey__AutoType,
		                                             &SpeechLib_IID_ISpeechDataKey,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, dataKey));
		dataKey__AutoType = 0;
		}

Error:
	if (dataKey__AutoType)
		dataKey__AutoType->lpVtbl->Release (dataKey__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (dataKey)
			{
			CA_DiscardObjHandle (*dataKey);
			*dataKey = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechObjectToken,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechObjectTokenGetCategory (CAObjHandle objectHandle,
                                                         ERRORINFO *errorInfo,
                                                         SpeechLibObj_ISpeechObjectTokenCategory *category)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechObjectToken_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH category__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (category)
		*category = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechObjectToken,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetCategory_ (__vtblIFacePtr,
	                                                  &category__AutoType));
	

	if (category)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (category__AutoType,
		                                             &SpeechLib_IID_ISpeechObjectTokenCategory,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, category));
		category__AutoType = 0;
		}

Error:
	if (category__AutoType)
		category__AutoType->lpVtbl->Release (category__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (category)
			{
			CA_DiscardObjHandle (*category);
			*category = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechObjectToken,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechObjectTokenGetDescription (CAObjHandle objectHandle,
                                                            ERRORINFO *errorInfo,
                                                            long locale,
                                                            char **description)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechObjectToken_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR description__AutoType = 0;

	if (description)
		*description = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechObjectToken,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetDescription_ (__vtblIFacePtr,
	                                                     locale,
	                                                     &description__AutoType));

	if (description)
		__caErrChk (CA_BSTRGetCString (description__AutoType, description));

Error:
	CA_FreeBSTR (description__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (description)
			{
			CA_FreeMemory (*description);
			*description = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechObjectToken,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechObjectTokenSetId (CAObjHandle objectHandle,
                                                   ERRORINFO *errorInfo,
                                                   const char *id,
                                                   const char *categoryID,
                                                   VBOOL createIfNotExist)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechObjectToken_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR id__AutoType = 0;
	BSTR categoryID__AutoType = 0;

	__caErrChk (CA_CStringToBSTR (id, &id__AutoType));
	__caErrChk (CA_CStringToBSTR (categoryID, &categoryID__AutoType));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechObjectToken,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetId_ (__vtblIFacePtr, id__AutoType,
	                                            categoryID__AutoType,
	                                            createIfNotExist));

Error:
	CA_FreeBSTR (id__AutoType);
	CA_FreeBSTR (categoryID__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechObjectToken,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechObjectTokenGetAttribute (CAObjHandle objectHandle,
                                                          ERRORINFO *errorInfo,
                                                          const char *attributeName,
                                                          char **attributeValue)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechObjectToken_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR attributeName__AutoType = 0;
	BSTR attributeValue__AutoType = 0;

	if (attributeValue)
		*attributeValue = 0;

	__caErrChk (CA_CStringToBSTR (attributeName, &attributeName__AutoType));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechObjectToken,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetAttribute_ (__vtblIFacePtr,
	                                                   attributeName__AutoType,
	                                                   &attributeValue__AutoType));

	if (attributeValue)
		__caErrChk (CA_BSTRGetCString (attributeValue__AutoType, attributeValue));

Error:
	CA_FreeBSTR (attributeName__AutoType);
	CA_FreeBSTR (attributeValue__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (attributeValue)
			{
			CA_FreeMemory (*attributeValue);
			*attributeValue = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechObjectToken,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechObjectTokenCreateInstance (CAObjHandle objectHandle,
                                                            ERRORINFO *errorInfo,
                                                            LPUNKNOWN pUnkOuter,
                                                            enum SpeechLibEnum_SpeechTokenContext clsContext,
                                                            LPUNKNOWN *object)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechObjectToken_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN object__Temp = 0;

	if (object)
		*object = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechObjectToken,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->CreateInstance_ (__vtblIFacePtr,
	                                                     pUnkOuter, clsContext,
	                                                     &object__Temp));

	if (object)
		{
		*object = object__Temp;
		object__Temp = 0;
		}

Error:
	if (object__Temp)
		object__Temp->lpVtbl->Release (object__Temp);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (object)
			{
			if (*object)
				(*object)->lpVtbl->Release (*object);
			*object = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechObjectToken,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechObjectTokenRemove (CAObjHandle objectHandle,
                                                    ERRORINFO *errorInfo,
                                                    const char *objectStorageCLSID)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechObjectToken_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR objectStorageCLSID__AutoType = 0;

	__caErrChk (CA_CStringToBSTR (objectStorageCLSID,
	                              &objectStorageCLSID__AutoType));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechObjectToken,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Remove_ (__vtblIFacePtr,
	                                             objectStorageCLSID__AutoType));

Error:
	CA_FreeBSTR (objectStorageCLSID__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechObjectToken,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechObjectTokenGetStorageFileName (CAObjHandle objectHandle,
                                                                ERRORINFO *errorInfo,
                                                                const char *objectStorageCLSID,
                                                                const char *keyName,
                                                                const char *fileName,
                                                                enum SpeechLibEnum_SpeechTokenShellFolder folder,
                                                                char **filePath)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechObjectToken_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR objectStorageCLSID__AutoType = 0;
	BSTR keyName__AutoType = 0;
	BSTR fileName__AutoType = 0;
	BSTR filePath__AutoType = 0;

	if (filePath)
		*filePath = 0;

	__caErrChk (CA_CStringToBSTR (objectStorageCLSID,
	                              &objectStorageCLSID__AutoType));
	__caErrChk (CA_CStringToBSTR (keyName, &keyName__AutoType));
	__caErrChk (CA_CStringToBSTR (fileName, &fileName__AutoType));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechObjectToken,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetStorageFileName_ (__vtblIFacePtr,
	                                                         objectStorageCLSID__AutoType,
	                                                         keyName__AutoType,
	                                                         fileName__AutoType,
	                                                         folder,
	                                                         &filePath__AutoType));

	if (filePath)
		__caErrChk (CA_BSTRGetCString (filePath__AutoType, filePath));

Error:
	CA_FreeBSTR (objectStorageCLSID__AutoType);
	CA_FreeBSTR (keyName__AutoType);
	CA_FreeBSTR (fileName__AutoType);
	CA_FreeBSTR (filePath__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (filePath)
			{
			CA_FreeMemory (*filePath);
			*filePath = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechObjectToken,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechObjectTokenRemoveStorageFileName (CAObjHandle objectHandle,
                                                                   ERRORINFO *errorInfo,
                                                                   const char *objectStorageCLSID,
                                                                   const char *keyName,
                                                                   VBOOL deleteFile)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechObjectToken_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR objectStorageCLSID__AutoType = 0;
	BSTR keyName__AutoType = 0;

	__caErrChk (CA_CStringToBSTR (objectStorageCLSID,
	                              &objectStorageCLSID__AutoType));
	__caErrChk (CA_CStringToBSTR (keyName, &keyName__AutoType));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechObjectToken,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->RemoveStorageFileName_ (__vtblIFacePtr,
	                                                            objectStorageCLSID__AutoType,
	                                                            keyName__AutoType,
	                                                            deleteFile));

Error:
	CA_FreeBSTR (objectStorageCLSID__AutoType);
	CA_FreeBSTR (keyName__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechObjectToken,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechObjectTokenIsUISupported (CAObjHandle objectHandle,
                                                           ERRORINFO *errorInfo,
                                                           const char *typeOfUI,
                                                           VARIANT extraData,
                                                           LPUNKNOWN object,
                                                           VBOOL *supported)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechObjectToken_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR typeOfUI__AutoType = 0;
	VBOOL supported__Temp;

	__caErrChk (CA_CStringToBSTR (typeOfUI, &typeOfUI__AutoType));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechObjectToken,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->IsUISupported_ (__vtblIFacePtr,
	                                                    typeOfUI__AutoType,
	                                                    &extraData, object,
	                                                    &supported__Temp));

	if (supported)
		{
		*supported = supported__Temp;
		}

Error:
	CA_FreeBSTR (typeOfUI__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechObjectToken,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechObjectTokenDisplayUI (CAObjHandle objectHandle,
                                                       ERRORINFO *errorInfo,
                                                       long hWnd,
                                                       const char *title,
                                                       const char *typeOfUI,
                                                       VARIANT extraData,
                                                       LPUNKNOWN object)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechObjectToken_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR title__AutoType = 0;
	BSTR typeOfUI__AutoType = 0;

	__caErrChk (CA_CStringToBSTR (title, &title__AutoType));
	__caErrChk (CA_CStringToBSTR (typeOfUI, &typeOfUI__AutoType));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechObjectToken,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->DisplayUI_ (__vtblIFacePtr, hWnd,
	                                                title__AutoType,
	                                                typeOfUI__AutoType,
	                                                &extraData, object));

Error:
	CA_FreeBSTR (title__AutoType);
	CA_FreeBSTR (typeOfUI__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechObjectToken,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechObjectTokenMatchesAttributes (CAObjHandle objectHandle,
                                                               ERRORINFO *errorInfo,
                                                               const char *attributes,
                                                               VBOOL *matches)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechObjectToken_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR attributes__AutoType = 0;
	VBOOL matches__Temp;

	__caErrChk (CA_CStringToBSTR (attributes, &attributes__AutoType));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechObjectToken,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->MatchesAttributes_ (__vtblIFacePtr,
	                                                        attributes__AutoType,
	                                                        &matches__Temp));

	if (matches)
		{
		*matches = matches__Temp;
		}

Error:
	CA_FreeBSTR (attributes__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechObjectToken,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_NewISpObjectToken (const char *server,
                                             int supportMultithreading,
                                             LCID locale, int reserved,
                                             CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xEF411752, 0x3736, 0x4CB4, 0x9C, 0x8C, 0x8E, 0xF4, 0xCC,
	              0xB5, 0x8E, 0xFE};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpObjectToken,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenISpObjectToken (const char *fileName,
                                              const char *server,
                                              int supportMultithreading,
                                              LCID locale, int reserved,
                                              CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xEF411752, 0x3736, 0x4CB4, 0x9C, 0x8C, 0x8E, 0xF4, 0xCC,
	              0xB5, 0x8E, 0xFE};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpObjectToken,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveISpObjectToken (const char *server,
                                                int supportMultithreading,
                                                LCID locale, int reserved,
                                                CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xEF411752, 0x3736, 0x4CB4, 0x9C, 0x8C, 0x8E, 0xF4, 0xCC,
	              0xB5, 0x8E, 0xFE};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpObjectToken,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpObjectTokenGetCategory (CAObjHandle objectHandle,
                                                     ERRORINFO *errorInfo,
                                                     SpeechLibObj_ISpObjectTokenCategory *ppTokenCategory)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpObjectToken_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN ppTokenCategory__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (ppTokenCategory)
		*ppTokenCategory = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpObjectToken, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetCategory_ (__vtblIFacePtr,
	                                                  &ppTokenCategory__AutoType));
	

	if (ppTokenCategory)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (ppTokenCategory__AutoType,
		                                             &SpeechLib_IID_ISpObjectTokenCategory,
		                                             __supportMultithreading,
		                                             __locale, 0, 0,
		                                             ppTokenCategory));
		ppTokenCategory__AutoType = 0;
		}

Error:
	if (ppTokenCategory__AutoType)
		ppTokenCategory__AutoType->lpVtbl->Release (ppTokenCategory__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (ppTokenCategory)
			{
			CA_DiscardObjHandle (*ppTokenCategory);
			*ppTokenCategory = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpObjectToken, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_NewISpStreamFormatConverter (const char *server,
                                                       int supportMultithreading,
                                                       LCID locale, int reserved,
                                                       CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x7013943A, 0xE2EC, 0x11D2, 0xA0, 0x86, 0x0, 0xC0, 0x4F,
	              0x8E, 0xF9, 0xB5};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpStreamFormatConverter,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenISpStreamFormatConverter (const char *fileName,
                                                        const char *server,
                                                        int supportMultithreading,
                                                        LCID locale,
                                                        int reserved,
                                                        CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x7013943A, 0xE2EC, 0x11D2, 0xA0, 0x86, 0x0, 0xC0, 0x4F,
	              0x8E, 0xF9, 0xB5};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpStreamFormatConverter,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveISpStreamFormatConverter (const char *server,
                                                          int supportMultithreading,
                                                          LCID locale,
                                                          int reserved,
                                                          CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x7013943A, 0xE2EC, 0x11D2, 0xA0, 0x86, 0x0, 0xC0, 0x4F,
	              0x8E, 0xF9, 0xB5};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpStreamFormatConverter,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpStreamFormatConverterRemoteRead (CAObjHandle objectHandle,
                                                              ERRORINFO *errorInfo,
                                                              unsigned char *pv,
                                                              unsigned long cb,
                                                              unsigned long *pcbRead)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpStreamFormatConverter_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	unsigned char pv__Temp;
	unsigned long pcbRead__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpStreamFormatConverter,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->RemoteRead_ (__vtblIFacePtr, &pv__Temp,
	                                                 cb, &pcbRead__Temp));

	if (pv)
		{
		*pv = pv__Temp;
		}
	if (pcbRead)
		{
		*pcbRead = pcbRead__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpStreamFormatConverter,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpStreamFormatConverterRemoteWrite (CAObjHandle objectHandle,
                                                               ERRORINFO *errorInfo,
                                                               unsigned char *pv,
                                                               unsigned long cb,
                                                               unsigned long *pcbWritten)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpStreamFormatConverter_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	unsigned long pcbWritten__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpStreamFormatConverter,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->RemoteWrite_ (__vtblIFacePtr, pv, cb,
	                                                  &pcbWritten__Temp));

	if (pcbWritten)
		{
		*pcbWritten = pcbWritten__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpStreamFormatConverter,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpStreamFormatConverterCommit (CAObjHandle objectHandle,
                                                          ERRORINFO *errorInfo,
                                                          unsigned long grfCommitFlags)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpStreamFormatConverter_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpStreamFormatConverter,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Commit_ (__vtblIFacePtr,
	                                             grfCommitFlags));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpStreamFormatConverter,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpStreamFormatConverterRevert (CAObjHandle objectHandle,
                                                          ERRORINFO *errorInfo)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpStreamFormatConverter_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpStreamFormatConverter,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Revert_ (__vtblIFacePtr));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpStreamFormatConverter,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpStreamFormatConverterClone (CAObjHandle objectHandle,
                                                         ERRORINFO *errorInfo,
                                                         SpeechLibObj_IStream *ppstm)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpStreamFormatConverter_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN ppstm__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (ppstm)
		*ppstm = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpStreamFormatConverter,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Clone_ (__vtblIFacePtr,
	                                            &ppstm__AutoType));
	

	if (ppstm)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (ppstm__AutoType,
		                                             &SpeechLib_IID_IStream,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, ppstm));
		ppstm__AutoType = 0;
		}

Error:
	if (ppstm__AutoType)
		ppstm__AutoType->lpVtbl->Release (ppstm__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (ppstm)
			{
			CA_DiscardObjHandle (*ppstm);
			*ppstm = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpStreamFormatConverter,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpStreamFormatConverterSetBaseStream (CAObjHandle objectHandle,
                                                                 ERRORINFO *errorInfo,
                                                                 SpeechLibObj_ISpStreamFormat pStream,
                                                                 long fSetFormatToBaseStreamFormat,
                                                                 long fWriteToBaseStream)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpStreamFormatConverter_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN pStream__AutoType = 0;

	if (pStream)
		{
		__caErrChk (CA_GetInterfaceFromObjHandle (pStream,
	                                          &SpeechLib_IID_ISpStreamFormat,
	                                          1, &pStream__AutoType, NULL));
		}

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpStreamFormatConverter,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetBaseStream_ (__vtblIFacePtr,
	                                                    pStream__AutoType,
	                                                    fSetFormatToBaseStreamFormat,
	                                                    fWriteToBaseStream));

Error:
	if (pStream__AutoType)
		pStream__AutoType->lpVtbl->Release (pStream__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpStreamFormatConverter,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpStreamFormatConverterGetBaseStream (CAObjHandle objectHandle,
                                                                 ERRORINFO *errorInfo,
                                                                 SpeechLibObj_ISpStreamFormat *ppStream)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpStreamFormatConverter_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN ppStream__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (ppStream)
		*ppStream = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpStreamFormatConverter,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetBaseStream_ (__vtblIFacePtr,
	                                                    &ppStream__AutoType));
	

	if (ppStream)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (ppStream__AutoType,
		                                             &SpeechLib_IID_ISpStreamFormat,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, ppStream));
		ppStream__AutoType = 0;
		}

Error:
	if (ppStream__AutoType)
		ppStream__AutoType->lpVtbl->Release (ppStream__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (ppStream)
			{
			CA_DiscardObjHandle (*ppStream);
			*ppStream = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpStreamFormatConverter,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpStreamFormatConverterResetSeekPosition (CAObjHandle objectHandle,
                                                                     ERRORINFO *errorInfo)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpStreamFormatConverter_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpStreamFormatConverter,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->ResetSeekPosition_ (__vtblIFacePtr));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpStreamFormatConverter,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_NewIEnumSpObjectTokens (const char *server,
                                                  int supportMultithreading,
                                                  LCID locale, int reserved,
                                                  CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xAB1890A0, 0xE91F, 0x11D2, 0xBB, 0x91, 0x0, 0xC0, 0x4F,
	              0x8E, 0xE6, 0xC0};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_IEnumSpObjectTokens,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenIEnumSpObjectTokens (const char *fileName,
                                                   const char *server,
                                                   int supportMultithreading,
                                                   LCID locale, int reserved,
                                                   CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xAB1890A0, 0xE91F, 0x11D2, 0xBB, 0x91, 0x0, 0xC0, 0x4F,
	              0x8E, 0xE6, 0xC0};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_IEnumSpObjectTokens,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveIEnumSpObjectTokens (const char *server,
                                                     int supportMultithreading,
                                                     LCID locale, int reserved,
                                                     CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xAB1890A0, 0xE91F, 0x11D2, 0xBB, 0x91, 0x0, 0xC0, 0x4F,
	              0x8E, 0xE6, 0xC0};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_IEnumSpObjectTokens,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_IEnumSpObjectTokensNext (CAObjHandle objectHandle,
                                                   ERRORINFO *errorInfo,
                                                   unsigned long celt,
                                                   SpeechLibObj_ISpObjectToken *pelt,
                                                   unsigned long *pceltFetched)
{
	HRESULT __result = S_OK;
	SpeechLib_IEnumSpObjectTokens_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN pelt__AutoType = 0;
	unsigned long pceltFetched__Temp;
	LCID __locale;
	int __supportMultithreading;

	if (pelt)
		*pelt = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_IEnumSpObjectTokens,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Next_ (__vtblIFacePtr, celt,
	                                           &pelt__AutoType,
	                                           &pceltFetched__Temp));
	

	if (pelt)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (pelt__AutoType,
		                                             &SpeechLib_IID_ISpObjectToken,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, pelt));
		pelt__AutoType = 0;
		}
	if (pceltFetched)
		{
		*pceltFetched = pceltFetched__Temp;
		}

Error:
	if (pelt__AutoType)
		pelt__AutoType->lpVtbl->Release (pelt__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (pelt)
			{
			CA_DiscardObjHandle (*pelt);
			*pelt = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_IEnumSpObjectTokens,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_IEnumSpObjectTokensSkip (CAObjHandle objectHandle,
                                                   ERRORINFO *errorInfo,
                                                   unsigned long celt)
{
	HRESULT __result = S_OK;
	SpeechLib_IEnumSpObjectTokens_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_IEnumSpObjectTokens,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Skip_ (__vtblIFacePtr, celt));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_IEnumSpObjectTokens,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_IEnumSpObjectTokensReset (CAObjHandle objectHandle,
                                                    ERRORINFO *errorInfo)
{
	HRESULT __result = S_OK;
	SpeechLib_IEnumSpObjectTokens_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_IEnumSpObjectTokens,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Reset_ (__vtblIFacePtr));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_IEnumSpObjectTokens,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_IEnumSpObjectTokensClone (CAObjHandle objectHandle,
                                                    ERRORINFO *errorInfo,
                                                    SpeechLibObj_IEnumSpObjectTokens *ppEnum)
{
	HRESULT __result = S_OK;
	SpeechLib_IEnumSpObjectTokens_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN ppEnum__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (ppEnum)
		*ppEnum = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_IEnumSpObjectTokens,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Clone_ (__vtblIFacePtr,
	                                            &ppEnum__AutoType));
	

	if (ppEnum)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (ppEnum__AutoType,
		                                             &SpeechLib_IID_IEnumSpObjectTokens,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, ppEnum));
		ppEnum__AutoType = 0;
		}

Error:
	if (ppEnum__AutoType)
		ppEnum__AutoType->lpVtbl->Release (ppEnum__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (ppEnum)
			{
			CA_DiscardObjHandle (*ppEnum);
			*ppEnum = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_IEnumSpObjectTokens,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_IEnumSpObjectTokensItem (CAObjHandle objectHandle,
                                                   ERRORINFO *errorInfo,
                                                   unsigned long index,
                                                   SpeechLibObj_ISpObjectToken *ppToken)
{
	HRESULT __result = S_OK;
	SpeechLib_IEnumSpObjectTokens_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN ppToken__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (ppToken)
		*ppToken = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_IEnumSpObjectTokens,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Item_ (__vtblIFacePtr, index,
	                                           &ppToken__AutoType));
	

	if (ppToken)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (ppToken__AutoType,
		                                             &SpeechLib_IID_ISpObjectToken,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, ppToken));
		ppToken__AutoType = 0;
		}

Error:
	if (ppToken__AutoType)
		ppToken__AutoType->lpVtbl->Release (ppToken__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (ppToken)
			{
			CA_DiscardObjHandle (*ppToken);
			*ppToken = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_IEnumSpObjectTokens,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_IEnumSpObjectTokensGetCount (CAObjHandle objectHandle,
                                                       ERRORINFO *errorInfo,
                                                       unsigned long *pCount)
{
	HRESULT __result = S_OK;
	SpeechLib_IEnumSpObjectTokens_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	unsigned long pCount__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_IEnumSpObjectTokens,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetCount_ (__vtblIFacePtr,
	                                               &pCount__Temp));

	if (pCount)
		{
		*pCount = pCount__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_IEnumSpObjectTokens,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_NewSpMMAudioInISpeechMMSysAudio (const char *server,
                                                           int supportMultithreading,
                                                           LCID locale,
                                                           int reserved,
                                                           CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xCF3D2E50, 0x53F2, 0x11D2, 0x96, 0xC, 0x0, 0xC0, 0x4F, 0x8E,
	              0xE6, 0x28};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpeechMMSysAudio,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenSpMMAudioInISpeechMMSysAudio (const char *fileName,
                                                            const char *server,
                                                            int supportMultithreading,
                                                            LCID locale,
                                                            int reserved,
                                                            CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xCF3D2E50, 0x53F2, 0x11D2, 0x96, 0xC, 0x0, 0xC0, 0x4F, 0x8E,
	              0xE6, 0x28};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpeechMMSysAudio,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveSpMMAudioInISpeechMMSysAudio (const char *server,
                                                              int supportMultithreading,
                                                              LCID locale,
                                                              int reserved,
                                                              CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xCF3D2E50, 0x53F2, 0x11D2, 0x96, 0xC, 0x0, 0xC0, 0x4F, 0x8E,
	              0xE6, 0x28};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpeechMMSysAudio,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_NewSpMMAudioOutISpeechMMSysAudio (const char *server,
                                                            int supportMultithreading,
                                                            LCID locale,
                                                            int reserved,
                                                            CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xA8C680EB, 0x3D32, 0x11D2, 0x9E, 0xE7, 0x0, 0xC0, 0x4F,
	              0x79, 0x73, 0x96};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpeechMMSysAudio,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenSpMMAudioOutISpeechMMSysAudio (const char *fileName,
                                                             const char *server,
                                                             int supportMultithreading,
                                                             LCID locale,
                                                             int reserved,
                                                             CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xA8C680EB, 0x3D32, 0x11D2, 0x9E, 0xE7, 0x0, 0xC0, 0x4F,
	              0x79, 0x73, 0x96};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpeechMMSysAudio,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveSpMMAudioOutISpeechMMSysAudio (const char *server,
                                                               int supportMultithreading,
                                                               LCID locale,
                                                               int reserved,
                                                               CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xA8C680EB, 0x3D32, 0x11D2, 0x9E, 0xE7, 0x0, 0xC0, 0x4F,
	              0x79, 0x73, 0x96};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpeechMMSysAudio,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechMMSysAudioGetFormat (CAObjHandle objectHandle,
                                                      ERRORINFO *errorInfo,
                                                      SpeechLibObj_ISpeechAudioFormat *audioFormat)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechMMSysAudio_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH audioFormat__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (audioFormat)
		*audioFormat = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechMMSysAudio,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetFormat_ (__vtblIFacePtr,
	                                                &audioFormat__AutoType));
	

	if (audioFormat)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (audioFormat__AutoType,
		                                             &SpeechLib_IID_ISpeechAudioFormat,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, audioFormat));
		audioFormat__AutoType = 0;
		}

Error:
	if (audioFormat__AutoType)
		audioFormat__AutoType->lpVtbl->Release (audioFormat__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (audioFormat)
			{
			CA_DiscardObjHandle (*audioFormat);
			*audioFormat = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechMMSysAudio,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechMMSysAudioSetByRefFormat (CAObjHandle objectHandle,
                                                           ERRORINFO *errorInfo,
                                                           SpeechLibObj_ISpeechAudioFormat audioFormat)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechMMSysAudio_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH audioFormat__AutoType = 0;

	if (audioFormat)
		{
		__caErrChk (CA_GetInterfaceFromObjHandle (audioFormat,
	                                          &SpeechLib_IID_ISpeechAudioFormat,
	                                          1, &audioFormat__AutoType, NULL));
		}

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechMMSysAudio,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetByRefFormat_ (__vtblIFacePtr,
	                                                     audioFormat__AutoType));

Error:
	if (audioFormat__AutoType)
		audioFormat__AutoType->lpVtbl->Release (audioFormat__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechMMSysAudio,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechMMSysAudioRead (CAObjHandle objectHandle,
                                                 ERRORINFO *errorInfo,
                                                 VARIANT *buffer,
                                                 long numberOfBytes,
                                                 long *bytesRead)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechMMSysAudio_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	VARIANT buffer__Temp;
	long bytesRead__Temp;

	if (buffer)
		CA_VariantSetEmpty (buffer);
	CA_VariantSetEmpty (&buffer__Temp);

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechMMSysAudio,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Read_ (__vtblIFacePtr, &buffer__Temp,
	                                           numberOfBytes, &bytesRead__Temp));

	if (buffer)
		{
		*buffer = buffer__Temp;
		CA_VariantSetEmpty (&buffer__Temp);
		}
	if (bytesRead)
		{
		*bytesRead = bytesRead__Temp;
		}

Error:
	CA_VariantClear (&buffer__Temp);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (buffer)
			CA_VariantClear (buffer);
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechMMSysAudio,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechMMSysAudioWrite (CAObjHandle objectHandle,
                                                  ERRORINFO *errorInfo,
                                                  VARIANT buffer,
                                                  long *bytesWritten)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechMMSysAudio_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long bytesWritten__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechMMSysAudio,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Write_ (__vtblIFacePtr, buffer,
	                                            &bytesWritten__Temp));

	if (bytesWritten)
		{
		*bytesWritten = bytesWritten__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechMMSysAudio,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechMMSysAudioSeek (CAObjHandle objectHandle,
                                                 ERRORINFO *errorInfo,
                                                 VARIANT position,
                                                 enum SpeechLibEnum_SpeechStreamSeekPositionType origin,
                                                 VARIANT *newPosition)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechMMSysAudio_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	VARIANT newPosition__Temp;

	if (newPosition)
		CA_VariantSetEmpty (newPosition);
	CA_VariantSetEmpty (&newPosition__Temp);

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechMMSysAudio,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Seek_ (__vtblIFacePtr, position,
	                                           origin, &newPosition__Temp));

	if (newPosition)
		{
		*newPosition = newPosition__Temp;
		CA_VariantSetEmpty (&newPosition__Temp);
		}

Error:
	CA_VariantClear (&newPosition__Temp);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (newPosition)
			CA_VariantClear (newPosition);
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechMMSysAudio,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechMMSysAudioGetStatus (CAObjHandle objectHandle,
                                                      ERRORINFO *errorInfo,
                                                      SpeechLibObj_ISpeechAudioStatus *status)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechMMSysAudio_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH status__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (status)
		*status = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechMMSysAudio,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetStatus_ (__vtblIFacePtr,
	                                                &status__AutoType));
	

	if (status)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (status__AutoType,
		                                             &SpeechLib_IID_ISpeechAudioStatus,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, status));
		status__AutoType = 0;
		}

Error:
	if (status__AutoType)
		status__AutoType->lpVtbl->Release (status__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (status)
			{
			CA_DiscardObjHandle (*status);
			*status = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechMMSysAudio,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechMMSysAudioGetBufferInfo (CAObjHandle objectHandle,
                                                          ERRORINFO *errorInfo,
                                                          SpeechLibObj_ISpeechAudioBufferInfo *bufferInfo)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechMMSysAudio_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH bufferInfo__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (bufferInfo)
		*bufferInfo = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechMMSysAudio,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetBufferInfo_ (__vtblIFacePtr,
	                                                    &bufferInfo__AutoType));
	

	if (bufferInfo)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (bufferInfo__AutoType,
		                                             &SpeechLib_IID_ISpeechAudioBufferInfo,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, bufferInfo));
		bufferInfo__AutoType = 0;
		}

Error:
	if (bufferInfo__AutoType)
		bufferInfo__AutoType->lpVtbl->Release (bufferInfo__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (bufferInfo)
			{
			CA_DiscardObjHandle (*bufferInfo);
			*bufferInfo = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechMMSysAudio,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechMMSysAudioGetDefaultFormat (CAObjHandle objectHandle,
                                                             ERRORINFO *errorInfo,
                                                             SpeechLibObj_ISpeechAudioFormat *streamFormat)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechMMSysAudio_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH streamFormat__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (streamFormat)
		*streamFormat = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechMMSysAudio,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetDefaultFormat_ (__vtblIFacePtr,
	                                                       &streamFormat__AutoType));
	

	if (streamFormat)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (streamFormat__AutoType,
		                                             &SpeechLib_IID_ISpeechAudioFormat,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, streamFormat));
		streamFormat__AutoType = 0;
		}

Error:
	if (streamFormat__AutoType)
		streamFormat__AutoType->lpVtbl->Release (streamFormat__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (streamFormat)
			{
			CA_DiscardObjHandle (*streamFormat);
			*streamFormat = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechMMSysAudio,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechMMSysAudioGetVolume (CAObjHandle objectHandle,
                                                      ERRORINFO *errorInfo,
                                                      long *volume)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechMMSysAudio_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long volume__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechMMSysAudio,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetVolume_ (__vtblIFacePtr,
	                                                &volume__Temp));

	if (volume)
		{
		*volume = volume__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechMMSysAudio,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechMMSysAudioSetVolume (CAObjHandle objectHandle,
                                                      ERRORINFO *errorInfo,
                                                      long volume)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechMMSysAudio_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechMMSysAudio,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetVolume_ (__vtblIFacePtr, volume));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechMMSysAudio,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechMMSysAudioGetBufferNotifySize (CAObjHandle objectHandle,
                                                                ERRORINFO *errorInfo,
                                                                long *bufferNotifySize)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechMMSysAudio_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long bufferNotifySize__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechMMSysAudio,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetBufferNotifySize_ (__vtblIFacePtr,
	                                                          &bufferNotifySize__Temp));

	if (bufferNotifySize)
		{
		*bufferNotifySize = bufferNotifySize__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechMMSysAudio,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechMMSysAudioSetBufferNotifySize (CAObjHandle objectHandle,
                                                                ERRORINFO *errorInfo,
                                                                long bufferNotifySize)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechMMSysAudio_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechMMSysAudio,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetBufferNotifySize_ (__vtblIFacePtr,
	                                                          bufferNotifySize));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechMMSysAudio,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechMMSysAudioGetEventHandle (CAObjHandle objectHandle,
                                                           ERRORINFO *errorInfo,
                                                           long *eventHandle)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechMMSysAudio_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long eventHandle__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechMMSysAudio,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetEventHandle_ (__vtblIFacePtr,
	                                                     &eventHandle__Temp));

	if (eventHandle)
		{
		*eventHandle = eventHandle__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechMMSysAudio,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechMMSysAudioSetState (CAObjHandle objectHandle,
                                                     ERRORINFO *errorInfo,
                                                     enum SpeechLibEnum_SpeechAudioState state)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechMMSysAudio_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechMMSysAudio,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetState_ (__vtblIFacePtr, state));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechMMSysAudio,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechMMSysAudioGetDeviceId (CAObjHandle objectHandle,
                                                        ERRORINFO *errorInfo,
                                                        long *deviceId)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechMMSysAudio_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long deviceId__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechMMSysAudio,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetDeviceId_ (__vtblIFacePtr,
	                                                  &deviceId__Temp));

	if (deviceId)
		{
		*deviceId = deviceId__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechMMSysAudio,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechMMSysAudioSetDeviceId (CAObjHandle objectHandle,
                                                        ERRORINFO *errorInfo,
                                                        long deviceId)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechMMSysAudio_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechMMSysAudio,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetDeviceId_ (__vtblIFacePtr, deviceId));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechMMSysAudio,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechMMSysAudioGetLineId (CAObjHandle objectHandle,
                                                      ERRORINFO *errorInfo,
                                                      long *lineId)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechMMSysAudio_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long lineId__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechMMSysAudio,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetLineId_ (__vtblIFacePtr,
	                                                &lineId__Temp));

	if (lineId)
		{
		*lineId = lineId__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechMMSysAudio,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechMMSysAudioSetLineId (CAObjHandle objectHandle,
                                                      ERRORINFO *errorInfo,
                                                      long lineId)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechMMSysAudio_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechMMSysAudio,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetLineId_ (__vtblIFacePtr, lineId));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechMMSysAudio,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechMMSysAudioGetMMHandle (CAObjHandle objectHandle,
                                                        ERRORINFO *errorInfo,
                                                        long *handle)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechMMSysAudio_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long handle__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechMMSysAudio,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetMMHandle_ (__vtblIFacePtr,
	                                                  &handle__Temp));

	if (handle)
		{
		*handle = handle__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechMMSysAudio,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_NewSpMMAudioInISpEventSource (const char *server,
                                                        int supportMultithreading,
                                                        LCID locale,
                                                        int reserved,
                                                        CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xCF3D2E50, 0x53F2, 0x11D2, 0x96, 0xC, 0x0, 0xC0, 0x4F, 0x8E,
	              0xE6, 0x28};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpEventSource,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenSpMMAudioInISpEventSource (const char *fileName,
                                                         const char *server,
                                                         int supportMultithreading,
                                                         LCID locale,
                                                         int reserved,
                                                         CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xCF3D2E50, 0x53F2, 0x11D2, 0x96, 0xC, 0x0, 0xC0, 0x4F, 0x8E,
	              0xE6, 0x28};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpEventSource,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveSpMMAudioInISpEventSource (const char *server,
                                                           int supportMultithreading,
                                                           LCID locale,
                                                           int reserved,
                                                           CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xCF3D2E50, 0x53F2, 0x11D2, 0x96, 0xC, 0x0, 0xC0, 0x4F, 0x8E,
	              0xE6, 0x28};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpEventSource,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_NewSpMMAudioOutISpEventSource (const char *server,
                                                         int supportMultithreading,
                                                         LCID locale,
                                                         int reserved,
                                                         CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xA8C680EB, 0x3D32, 0x11D2, 0x9E, 0xE7, 0x0, 0xC0, 0x4F,
	              0x79, 0x73, 0x96};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpEventSource,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenSpMMAudioOutISpEventSource (const char *fileName,
                                                          const char *server,
                                                          int supportMultithreading,
                                                          LCID locale,
                                                          int reserved,
                                                          CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xA8C680EB, 0x3D32, 0x11D2, 0x9E, 0xE7, 0x0, 0xC0, 0x4F,
	              0x79, 0x73, 0x96};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpEventSource,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveSpMMAudioOutISpEventSource (const char *server,
                                                            int supportMultithreading,
                                                            LCID locale,
                                                            int reserved,
                                                            CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xA8C680EB, 0x3D32, 0x11D2, 0x9E, 0xE7, 0x0, 0xC0, 0x4F,
	              0x79, 0x73, 0x96};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpEventSource,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpEventSourceSetNotifySink (CAObjHandle objectHandle,
                                                       ERRORINFO *errorInfo,
                                                       SpeechLibObj_ISpNotifySink pNotifySink)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpEventSource_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN pNotifySink__AutoType = 0;

	if (pNotifySink)
		{
		__caErrChk (CA_GetInterfaceFromObjHandle (pNotifySink,
	                                          &SpeechLib_IID_ISpNotifySink, 1,
	                                          &pNotifySink__AutoType, NULL));
		}

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpEventSource, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetNotifySink_ (__vtblIFacePtr,
	                                                    pNotifySink__AutoType));

Error:
	if (pNotifySink__AutoType)
		pNotifySink__AutoType->lpVtbl->Release (pNotifySink__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpEventSource, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpEventSourceSetNotifyWin32Event (CAObjHandle objectHandle,
                                                             ERRORINFO *errorInfo)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpEventSource_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpEventSource, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetNotifyWin32Event_ (__vtblIFacePtr));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpEventSource, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpEventSourceWaitForNotifyEvent (CAObjHandle objectHandle,
                                                            ERRORINFO *errorInfo,
                                                            unsigned long dwMilliseconds)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpEventSource_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpEventSource, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->WaitForNotifyEvent_ (__vtblIFacePtr,
	                                                         dwMilliseconds));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpEventSource, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpEventSourceGetNotifyEventHandle (CAObjHandle objectHandle,
                                                              ERRORINFO *errorInfo)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpEventSource_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpEventSource, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetNotifyEventHandle_ (__vtblIFacePtr));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpEventSource, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_NewSpMMAudioInISpObjectWithToken (const char *server,
                                                            int supportMultithreading,
                                                            LCID locale,
                                                            int reserved,
                                                            CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xCF3D2E50, 0x53F2, 0x11D2, 0x96, 0xC, 0x0, 0xC0, 0x4F, 0x8E,
	              0xE6, 0x28};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpObjectWithToken,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenSpMMAudioInISpObjectWithToken (const char *fileName,
                                                             const char *server,
                                                             int supportMultithreading,
                                                             LCID locale,
                                                             int reserved,
                                                             CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xCF3D2E50, 0x53F2, 0x11D2, 0x96, 0xC, 0x0, 0xC0, 0x4F, 0x8E,
	              0xE6, 0x28};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpObjectWithToken,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveSpMMAudioInISpObjectWithToken (const char *server,
                                                               int supportMultithreading,
                                                               LCID locale,
                                                               int reserved,
                                                               CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xCF3D2E50, 0x53F2, 0x11D2, 0x96, 0xC, 0x0, 0xC0, 0x4F, 0x8E,
	              0xE6, 0x28};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpObjectWithToken,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_NewSpMMAudioOutISpObjectWithToken (const char *server,
                                                             int supportMultithreading,
                                                             LCID locale,
                                                             int reserved,
                                                             CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xA8C680EB, 0x3D32, 0x11D2, 0x9E, 0xE7, 0x0, 0xC0, 0x4F,
	              0x79, 0x73, 0x96};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpObjectWithToken,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenSpMMAudioOutISpObjectWithToken (const char *fileName,
                                                              const char *server,
                                                              int supportMultithreading,
                                                              LCID locale,
                                                              int reserved,
                                                              CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xA8C680EB, 0x3D32, 0x11D2, 0x9E, 0xE7, 0x0, 0xC0, 0x4F,
	              0x79, 0x73, 0x96};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpObjectWithToken,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveSpMMAudioOutISpObjectWithToken (const char *server,
                                                                int supportMultithreading,
                                                                LCID locale,
                                                                int reserved,
                                                                CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xA8C680EB, 0x3D32, 0x11D2, 0x9E, 0xE7, 0x0, 0xC0, 0x4F,
	              0x79, 0x73, 0x96};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpObjectWithToken,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_NewSpUnCompressedLexiconISpObjectWithToken (const char *server,
                                                                      int supportMultithreading,
                                                                      LCID locale,
                                                                      int reserved,
                                                                      CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xC9E37C15, 0xDF92, 0x4727, 0x85, 0xD6, 0x72, 0xE5, 0xEE,
	              0xB6, 0x99, 0x5A};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpObjectWithToken,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenSpUnCompressedLexiconISpObjectWithToken (const char *fileName,
                                                                       const char *server,
                                                                       int supportMultithreading,
                                                                       LCID locale,
                                                                       int reserved,
                                                                       CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xC9E37C15, 0xDF92, 0x4727, 0x85, 0xD6, 0x72, 0xE5, 0xEE,
	              0xB6, 0x99, 0x5A};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpObjectWithToken,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveSpUnCompressedLexiconISpObjectWithToken (const char *server,
                                                                         int supportMultithreading,
                                                                         LCID locale,
                                                                         int reserved,
                                                                         CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xC9E37C15, 0xDF92, 0x4727, 0x85, 0xD6, 0x72, 0xE5, 0xEE,
	              0xB6, 0x99, 0x5A};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpObjectWithToken,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_NewSpCompressedLexiconISpObjectWithToken (const char *server,
                                                                    int supportMultithreading,
                                                                    LCID locale,
                                                                    int reserved,
                                                                    CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x90903716, 0x2F42, 0x11D3, 0x9C, 0x26, 0x0, 0xC0, 0x4F,
	              0x8E, 0xF8, 0x7C};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpObjectWithToken,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenSpCompressedLexiconISpObjectWithToken (const char *fileName,
                                                                     const char *server,
                                                                     int supportMultithreading,
                                                                     LCID locale,
                                                                     int reserved,
                                                                     CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x90903716, 0x2F42, 0x11D3, 0x9C, 0x26, 0x0, 0xC0, 0x4F,
	              0x8E, 0xF8, 0x7C};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpObjectWithToken,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveSpCompressedLexiconISpObjectWithToken (const char *server,
                                                                       int supportMultithreading,
                                                                       LCID locale,
                                                                       int reserved,
                                                                       CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x90903716, 0x2F42, 0x11D3, 0x9C, 0x26, 0x0, 0xC0, 0x4F,
	              0x8E, 0xF8, 0x7C};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpObjectWithToken,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_NewSpShortcutISpObjectWithToken (const char *server,
                                                           int supportMultithreading,
                                                           LCID locale,
                                                           int reserved,
                                                           CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xD722F1A, 0x9FCF, 0x4E62, 0x96, 0xD8, 0x6D, 0xF8, 0xF0,
	              0x1A, 0x26, 0xAA};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpObjectWithToken,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenSpShortcutISpObjectWithToken (const char *fileName,
                                                            const char *server,
                                                            int supportMultithreading,
                                                            LCID locale,
                                                            int reserved,
                                                            CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xD722F1A, 0x9FCF, 0x4E62, 0x96, 0xD8, 0x6D, 0xF8, 0xF0,
	              0x1A, 0x26, 0xAA};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpObjectWithToken,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveSpShortcutISpObjectWithToken (const char *server,
                                                              int supportMultithreading,
                                                              LCID locale,
                                                              int reserved,
                                                              CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xD722F1A, 0x9FCF, 0x4E62, 0x96, 0xD8, 0x6D, 0xF8, 0xF0,
	              0x1A, 0x26, 0xAA};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpObjectWithToken,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpObjectWithTokenSetObjectToken (CAObjHandle objectHandle,
                                                            ERRORINFO *errorInfo,
                                                            SpeechLibObj_ISpObjectToken pToken)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpObjectWithToken_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN pToken__AutoType = 0;

	if (pToken)
		{
		__caErrChk (CA_GetInterfaceFromObjHandle (pToken,
	                                          &SpeechLib_IID_ISpObjectToken, 1,
	                                          &pToken__AutoType, NULL));
		}

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpObjectWithToken,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetObjectToken_ (__vtblIFacePtr,
	                                                     pToken__AutoType));

Error:
	if (pToken__AutoType)
		pToken__AutoType->lpVtbl->Release (pToken__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpObjectWithToken,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpObjectWithTokenGetObjectToken (CAObjHandle objectHandle,
                                                            ERRORINFO *errorInfo,
                                                            SpeechLibObj_ISpObjectToken *ppToken)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpObjectWithToken_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN ppToken__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (ppToken)
		*ppToken = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpObjectWithToken,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetObjectToken_ (__vtblIFacePtr,
	                                                     &ppToken__AutoType));
	

	if (ppToken)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (ppToken__AutoType,
		                                             &SpeechLib_IID_ISpObjectToken,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, ppToken));
		ppToken__AutoType = 0;
		}

Error:
	if (ppToken__AutoType)
		ppToken__AutoType->lpVtbl->Release (ppToken__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (ppToken)
			{
			CA_DiscardObjHandle (*ppToken);
			*ppToken = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpObjectWithToken,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_NewSpMMAudioInISpMMSysAudio (const char *server,
                                                       int supportMultithreading,
                                                       LCID locale, int reserved,
                                                       CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xCF3D2E50, 0x53F2, 0x11D2, 0x96, 0xC, 0x0, 0xC0, 0x4F, 0x8E,
	              0xE6, 0x28};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpMMSysAudio,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenSpMMAudioInISpMMSysAudio (const char *fileName,
                                                        const char *server,
                                                        int supportMultithreading,
                                                        LCID locale,
                                                        int reserved,
                                                        CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xCF3D2E50, 0x53F2, 0x11D2, 0x96, 0xC, 0x0, 0xC0, 0x4F, 0x8E,
	              0xE6, 0x28};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpMMSysAudio,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveSpMMAudioInISpMMSysAudio (const char *server,
                                                          int supportMultithreading,
                                                          LCID locale,
                                                          int reserved,
                                                          CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xCF3D2E50, 0x53F2, 0x11D2, 0x96, 0xC, 0x0, 0xC0, 0x4F, 0x8E,
	              0xE6, 0x28};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpMMSysAudio,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_NewSpMMAudioOutISpMMSysAudio (const char *server,
                                                        int supportMultithreading,
                                                        LCID locale,
                                                        int reserved,
                                                        CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xA8C680EB, 0x3D32, 0x11D2, 0x9E, 0xE7, 0x0, 0xC0, 0x4F,
	              0x79, 0x73, 0x96};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpMMSysAudio,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenSpMMAudioOutISpMMSysAudio (const char *fileName,
                                                         const char *server,
                                                         int supportMultithreading,
                                                         LCID locale,
                                                         int reserved,
                                                         CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xA8C680EB, 0x3D32, 0x11D2, 0x9E, 0xE7, 0x0, 0xC0, 0x4F,
	              0x79, 0x73, 0x96};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpMMSysAudio,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveSpMMAudioOutISpMMSysAudio (const char *server,
                                                           int supportMultithreading,
                                                           LCID locale,
                                                           int reserved,
                                                           CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xA8C680EB, 0x3D32, 0x11D2, 0x9E, 0xE7, 0x0, 0xC0, 0x4F,
	              0x79, 0x73, 0x96};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpMMSysAudio,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpMMSysAudioRemoteRead (CAObjHandle objectHandle,
                                                   ERRORINFO *errorInfo,
                                                   unsigned char *pv,
                                                   unsigned long cb,
                                                   unsigned long *pcbRead)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpMMSysAudio_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	unsigned char pv__Temp;
	unsigned long pcbRead__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpMMSysAudio, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->RemoteRead_ (__vtblIFacePtr, &pv__Temp,
	                                                 cb, &pcbRead__Temp));

	if (pv)
		{
		*pv = pv__Temp;
		}
	if (pcbRead)
		{
		*pcbRead = pcbRead__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpMMSysAudio, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpMMSysAudioRemoteWrite (CAObjHandle objectHandle,
                                                    ERRORINFO *errorInfo,
                                                    unsigned char *pv,
                                                    unsigned long cb,
                                                    unsigned long *pcbWritten)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpMMSysAudio_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	unsigned long pcbWritten__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpMMSysAudio, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->RemoteWrite_ (__vtblIFacePtr, pv, cb,
	                                                  &pcbWritten__Temp));

	if (pcbWritten)
		{
		*pcbWritten = pcbWritten__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpMMSysAudio, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpMMSysAudioCommit (CAObjHandle objectHandle,
                                               ERRORINFO *errorInfo,
                                               unsigned long grfCommitFlags)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpMMSysAudio_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpMMSysAudio, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Commit_ (__vtblIFacePtr,
	                                             grfCommitFlags));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpMMSysAudio, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpMMSysAudioRevert (CAObjHandle objectHandle,
                                               ERRORINFO *errorInfo)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpMMSysAudio_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpMMSysAudio, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Revert_ (__vtblIFacePtr));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpMMSysAudio, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpMMSysAudioClone (CAObjHandle objectHandle,
                                              ERRORINFO *errorInfo,
                                              SpeechLibObj_IStream *ppstm)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpMMSysAudio_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN ppstm__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (ppstm)
		*ppstm = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpMMSysAudio, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Clone_ (__vtblIFacePtr,
	                                            &ppstm__AutoType));
	

	if (ppstm)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (ppstm__AutoType,
		                                             &SpeechLib_IID_IStream,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, ppstm));
		ppstm__AutoType = 0;
		}

Error:
	if (ppstm__AutoType)
		ppstm__AutoType->lpVtbl->Release (ppstm__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (ppstm)
			{
			CA_DiscardObjHandle (*ppstm);
			*ppstm = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpMMSysAudio, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpMMSysAudioEventHandle (CAObjHandle objectHandle,
                                                    ERRORINFO *errorInfo)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpMMSysAudio_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpMMSysAudio, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->EventHandle_ (__vtblIFacePtr));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpMMSysAudio, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpMMSysAudioGetVolumeLevel (CAObjHandle objectHandle,
                                                       ERRORINFO *errorInfo,
                                                       unsigned long *pLevel)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpMMSysAudio_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	unsigned long pLevel__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpMMSysAudio, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetVolumeLevel_ (__vtblIFacePtr,
	                                                     &pLevel__Temp));

	if (pLevel)
		{
		*pLevel = pLevel__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpMMSysAudio, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpMMSysAudioSetVolumeLevel (CAObjHandle objectHandle,
                                                       ERRORINFO *errorInfo,
                                                       unsigned long level)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpMMSysAudio_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpMMSysAudio, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetVolumeLevel_ (__vtblIFacePtr, level));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpMMSysAudio, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpMMSysAudioGetBufferNotifySize (CAObjHandle objectHandle,
                                                            ERRORINFO *errorInfo,
                                                            unsigned long *pcbSize)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpMMSysAudio_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	unsigned long pcbSize__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpMMSysAudio, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetBufferNotifySize_ (__vtblIFacePtr,
	                                                          &pcbSize__Temp));

	if (pcbSize)
		{
		*pcbSize = pcbSize__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpMMSysAudio, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpMMSysAudioSetBufferNotifySize (CAObjHandle objectHandle,
                                                            ERRORINFO *errorInfo,
                                                            unsigned long cbSize)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpMMSysAudio_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpMMSysAudio, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetBufferNotifySize_ (__vtblIFacePtr,
	                                                          cbSize));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpMMSysAudio, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpMMSysAudioGetDeviceId (CAObjHandle objectHandle,
                                                    ERRORINFO *errorInfo,
                                                    unsigned long *puDeviceId)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpMMSysAudio_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	unsigned long puDeviceId__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpMMSysAudio, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetDeviceId_ (__vtblIFacePtr,
	                                                  &puDeviceId__Temp));

	if (puDeviceId)
		{
		*puDeviceId = puDeviceId__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpMMSysAudio, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpMMSysAudioSetDeviceId (CAObjHandle objectHandle,
                                                    ERRORINFO *errorInfo,
                                                    unsigned long uDeviceId)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpMMSysAudio_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpMMSysAudio, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetDeviceId_ (__vtblIFacePtr,
	                                                  uDeviceId));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpMMSysAudio, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpMMSysAudioGetLineId (CAObjHandle objectHandle,
                                                  ERRORINFO *errorInfo,
                                                  unsigned long *puLineId)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpMMSysAudio_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	unsigned long puLineId__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpMMSysAudio, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetLineId_ (__vtblIFacePtr,
	                                                &puLineId__Temp));

	if (puLineId)
		{
		*puLineId = puLineId__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpMMSysAudio, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpMMSysAudioSetLineId (CAObjHandle objectHandle,
                                                  ERRORINFO *errorInfo,
                                                  unsigned long uLineId)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpMMSysAudio_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpMMSysAudio, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetLineId_ (__vtblIFacePtr, uLineId));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpMMSysAudio, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_NewSpStreamISpStream (const char *server,
                                                int supportMultithreading,
                                                LCID locale, int reserved,
                                                CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x715D9C59, 0x4442, 0x11D2, 0x96, 0x5, 0x0, 0xC0, 0x4F, 0x8E,
	              0xE6, 0x28};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpStream,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenSpStreamISpStream (const char *fileName,
                                                 const char *server,
                                                 int supportMultithreading,
                                                 LCID locale, int reserved,
                                                 CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x715D9C59, 0x4442, 0x11D2, 0x96, 0x5, 0x0, 0xC0, 0x4F, 0x8E,
	              0xE6, 0x28};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpStream,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveSpStreamISpStream (const char *server,
                                                   int supportMultithreading,
                                                   LCID locale, int reserved,
                                                   CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x715D9C59, 0x4442, 0x11D2, 0x96, 0x5, 0x0, 0xC0, 0x4F, 0x8E,
	              0xE6, 0x28};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpStream,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_NewSpCustomStreamISpStream (const char *server,
                                                      int supportMultithreading,
                                                      LCID locale, int reserved,
                                                      CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x8DBEF13F, 0x1948, 0x4AA8, 0x8C, 0xF0, 0x4, 0x8E, 0xEB,
	              0xED, 0x95, 0xD8};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpStream,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenSpCustomStreamISpStream (const char *fileName,
                                                       const char *server,
                                                       int supportMultithreading,
                                                       LCID locale, int reserved,
                                                       CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x8DBEF13F, 0x1948, 0x4AA8, 0x8C, 0xF0, 0x4, 0x8E, 0xEB,
	              0xED, 0x95, 0xD8};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpStream,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveSpCustomStreamISpStream (const char *server,
                                                         int supportMultithreading,
                                                         LCID locale,
                                                         int reserved,
                                                         CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x8DBEF13F, 0x1948, 0x4AA8, 0x8C, 0xF0, 0x4, 0x8E, 0xEB,
	              0xED, 0x95, 0xD8};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpStream,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_NewSpFileStreamISpStream (const char *server,
                                                    int supportMultithreading,
                                                    LCID locale, int reserved,
                                                    CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x947812B3, 0x2AE1, 0x4644, 0xBA, 0x86, 0x9E, 0x90, 0xDE,
	              0xD7, 0xEC, 0x91};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpStream,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenSpFileStreamISpStream (const char *fileName,
                                                     const char *server,
                                                     int supportMultithreading,
                                                     LCID locale, int reserved,
                                                     CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x947812B3, 0x2AE1, 0x4644, 0xBA, 0x86, 0x9E, 0x90, 0xDE,
	              0xD7, 0xEC, 0x91};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpStream,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveSpFileStreamISpStream (const char *server,
                                                       int supportMultithreading,
                                                       LCID locale, int reserved,
                                                       CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x947812B3, 0x2AE1, 0x4644, 0xBA, 0x86, 0x9E, 0x90, 0xDE,
	              0xD7, 0xEC, 0x91};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpStream,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_NewSpMemoryStreamISpStream (const char *server,
                                                      int supportMultithreading,
                                                      LCID locale, int reserved,
                                                      CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x5FB7EF7D, 0xDFF4, 0x468A, 0xB6, 0xB7, 0x2F, 0xCB, 0xD1,
	              0x88, 0xF9, 0x94};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpStream,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenSpMemoryStreamISpStream (const char *fileName,
                                                       const char *server,
                                                       int supportMultithreading,
                                                       LCID locale, int reserved,
                                                       CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x5FB7EF7D, 0xDFF4, 0x468A, 0xB6, 0xB7, 0x2F, 0xCB, 0xD1,
	              0x88, 0xF9, 0x94};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpStream,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveSpMemoryStreamISpStream (const char *server,
                                                         int supportMultithreading,
                                                         LCID locale,
                                                         int reserved,
                                                         CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x5FB7EF7D, 0xDFF4, 0x468A, 0xB6, 0xB7, 0x2F, 0xCB, 0xD1,
	              0x88, 0xF9, 0x94};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpStream,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpStreamRemoteRead (CAObjHandle objectHandle,
                                               ERRORINFO *errorInfo,
                                               unsigned char *pv,
                                               unsigned long cb,
                                               unsigned long *pcbRead)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpStream_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	unsigned char pv__Temp;
	unsigned long pcbRead__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpStream, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->RemoteRead_ (__vtblIFacePtr, &pv__Temp,
	                                                 cb, &pcbRead__Temp));

	if (pv)
		{
		*pv = pv__Temp;
		}
	if (pcbRead)
		{
		*pcbRead = pcbRead__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpStream, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpStreamRemoteWrite (CAObjHandle objectHandle,
                                                ERRORINFO *errorInfo,
                                                unsigned char *pv,
                                                unsigned long cb,
                                                unsigned long *pcbWritten)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpStream_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	unsigned long pcbWritten__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpStream, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->RemoteWrite_ (__vtblIFacePtr, pv, cb,
	                                                  &pcbWritten__Temp));

	if (pcbWritten)
		{
		*pcbWritten = pcbWritten__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpStream, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpStreamCommit (CAObjHandle objectHandle,
                                           ERRORINFO *errorInfo,
                                           unsigned long grfCommitFlags)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpStream_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpStream, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Commit_ (__vtblIFacePtr,
	                                             grfCommitFlags));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpStream, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpStreamRevert (CAObjHandle objectHandle,
                                           ERRORINFO *errorInfo)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpStream_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpStream, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Revert_ (__vtblIFacePtr));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpStream, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpStreamClone (CAObjHandle objectHandle,
                                          ERRORINFO *errorInfo,
                                          SpeechLibObj_IStream *ppstm)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpStream_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN ppstm__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (ppstm)
		*ppstm = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpStream, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Clone_ (__vtblIFacePtr,
	                                            &ppstm__AutoType));
	

	if (ppstm)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (ppstm__AutoType,
		                                             &SpeechLib_IID_IStream,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, ppstm));
		ppstm__AutoType = 0;
		}

Error:
	if (ppstm__AutoType)
		ppstm__AutoType->lpVtbl->Release (ppstm__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (ppstm)
			{
			CA_DiscardObjHandle (*ppstm);
			*ppstm = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpStream, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpStreamGetBaseStream (CAObjHandle objectHandle,
                                                  ERRORINFO *errorInfo,
                                                  SpeechLibObj_IStream *ppStream)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpStream_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN ppStream__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (ppStream)
		*ppStream = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpStream, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetBaseStream_ (__vtblIFacePtr,
	                                                    &ppStream__AutoType));
	

	if (ppStream)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (ppStream__AutoType,
		                                             &SpeechLib_IID_IStream,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, ppStream));
		ppStream__AutoType = 0;
		}

Error:
	if (ppStream__AutoType)
		ppStream__AutoType->lpVtbl->Release (ppStream__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (ppStream)
			{
			CA_DiscardObjHandle (*ppStream);
			*ppStream = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpStream, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpStreamClose (CAObjHandle objectHandle,
                                          ERRORINFO *errorInfo)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpStream_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpStream, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Close_ (__vtblIFacePtr));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpStream, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_NewISpeechVoice (const char *server,
                                           int supportMultithreading,
                                           LCID locale, int reserved,
                                           CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x96749377, 0x3391, 0x11D2, 0x9E, 0xE3, 0x0, 0xC0, 0x4F,
	              0x79, 0x73, 0x96};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpeechVoice,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenISpeechVoice (const char *fileName,
                                            const char *server,
                                            int supportMultithreading,
                                            LCID locale, int reserved,
                                            CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x96749377, 0x3391, 0x11D2, 0x9E, 0xE3, 0x0, 0xC0, 0x4F,
	              0x79, 0x73, 0x96};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpeechVoice,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveISpeechVoice (const char *server,
                                              int supportMultithreading,
                                              LCID locale, int reserved,
                                              CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x96749377, 0x3391, 0x11D2, 0x9E, 0xE3, 0x0, 0xC0, 0x4F,
	              0x79, 0x73, 0x96};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpeechVoice,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechVoiceGetStatus (CAObjHandle objectHandle,
                                                 ERRORINFO *errorInfo,
                                                 SpeechLibObj_ISpeechVoiceStatus *status)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechVoice_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH status__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (status)
		*status = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechVoice, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetStatus_ (__vtblIFacePtr,
	                                                &status__AutoType));
	

	if (status)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (status__AutoType,
		                                             &SpeechLib_IID_ISpeechVoiceStatus,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, status));
		status__AutoType = 0;
		}

Error:
	if (status__AutoType)
		status__AutoType->lpVtbl->Release (status__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (status)
			{
			CA_DiscardObjHandle (*status);
			*status = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechVoice, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechVoiceGetVoice (CAObjHandle objectHandle,
                                                ERRORINFO *errorInfo,
                                                SpeechLibObj_ISpeechObjectToken *voice)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechVoice_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH voice__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (voice)
		*voice = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechVoice, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetVoice_ (__vtblIFacePtr,
	                                               &voice__AutoType));
	

	if (voice)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (voice__AutoType,
		                                             &SpeechLib_IID_ISpeechObjectToken,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, voice));
		voice__AutoType = 0;
		}

Error:
	if (voice__AutoType)
		voice__AutoType->lpVtbl->Release (voice__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (voice)
			{
			CA_DiscardObjHandle (*voice);
			*voice = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechVoice, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechVoiceSetByRefVoice (CAObjHandle objectHandle,
                                                     ERRORINFO *errorInfo,
                                                     SpeechLibObj_ISpeechObjectToken voice)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechVoice_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH voice__AutoType = 0;

	if (voice)
		{
		__caErrChk (CA_GetInterfaceFromObjHandle (voice,
	                                          &SpeechLib_IID_ISpeechObjectToken,
	                                          1, &voice__AutoType, NULL));
		}

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechVoice, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetByRefVoice_ (__vtblIFacePtr,
	                                                    voice__AutoType));

Error:
	if (voice__AutoType)
		voice__AutoType->lpVtbl->Release (voice__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechVoice, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechVoiceGetAudioOutput (CAObjHandle objectHandle,
                                                      ERRORINFO *errorInfo,
                                                      SpeechLibObj_ISpeechObjectToken *audioOutput)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechVoice_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH audioOutput__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (audioOutput)
		*audioOutput = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechVoice, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetAudioOutput_ (__vtblIFacePtr,
	                                                     &audioOutput__AutoType));
	

	if (audioOutput)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (audioOutput__AutoType,
		                                             &SpeechLib_IID_ISpeechObjectToken,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, audioOutput));
		audioOutput__AutoType = 0;
		}

Error:
	if (audioOutput__AutoType)
		audioOutput__AutoType->lpVtbl->Release (audioOutput__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (audioOutput)
			{
			CA_DiscardObjHandle (*audioOutput);
			*audioOutput = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechVoice, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechVoiceSetByRefAudioOutput (CAObjHandle objectHandle,
                                                           ERRORINFO *errorInfo,
                                                           SpeechLibObj_ISpeechObjectToken audioOutput)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechVoice_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH audioOutput__AutoType = 0;

	if (audioOutput)
		{
		__caErrChk (CA_GetInterfaceFromObjHandle (audioOutput,
	                                          &SpeechLib_IID_ISpeechObjectToken,
	                                          1, &audioOutput__AutoType, NULL));
		}

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechVoice, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetByRefAudioOutput_ (__vtblIFacePtr,
	                                                          audioOutput__AutoType));

Error:
	if (audioOutput__AutoType)
		audioOutput__AutoType->lpVtbl->Release (audioOutput__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechVoice, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechVoiceGetAudioOutputStream (CAObjHandle objectHandle,
                                                            ERRORINFO *errorInfo,
                                                            SpeechLibObj_ISpeechBaseStream *audioOutputStream)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechVoice_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH audioOutputStream__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (audioOutputStream)
		*audioOutputStream = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechVoice, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetAudioOutputStream_ (__vtblIFacePtr,
	                                                           &audioOutputStream__AutoType));
	

	if (audioOutputStream)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (audioOutputStream__AutoType,
		                                             &SpeechLib_IID_ISpeechBaseStream,
		                                             __supportMultithreading,
		                                             __locale, 0, 0,
		                                             audioOutputStream));
		audioOutputStream__AutoType = 0;
		}

Error:
	if (audioOutputStream__AutoType)
		audioOutputStream__AutoType->lpVtbl->Release (audioOutputStream__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (audioOutputStream)
			{
			CA_DiscardObjHandle (*audioOutputStream);
			*audioOutputStream = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechVoice, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechVoiceSetByRefAudioOutputStream (CAObjHandle objectHandle,
                                                                 ERRORINFO *errorInfo,
                                                                 SpeechLibObj_ISpeechBaseStream audioOutputStream)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechVoice_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH audioOutputStream__AutoType = 0;

	if (audioOutputStream)
		{
		__caErrChk (CA_GetInterfaceFromObjHandle (audioOutputStream,
	                                          &SpeechLib_IID_ISpeechBaseStream,
	                                          1, &audioOutputStream__AutoType,
	                                          NULL));
		}

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechVoice, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetByRefAudioOutputStream_ (__vtblIFacePtr,
	                                                                audioOutputStream__AutoType));

Error:
	if (audioOutputStream__AutoType)
		audioOutputStream__AutoType->lpVtbl->Release (audioOutputStream__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechVoice, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechVoiceGetRate (CAObjHandle objectHandle,
                                               ERRORINFO *errorInfo, long *rate)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechVoice_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long rate__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechVoice, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetRate_ (__vtblIFacePtr, &rate__Temp));

	if (rate)
		{
		*rate = rate__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechVoice, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechVoiceSetRate (CAObjHandle objectHandle,
                                               ERRORINFO *errorInfo, long rate)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechVoice_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechVoice, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetRate_ (__vtblIFacePtr, rate));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechVoice, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechVoiceGetVolume (CAObjHandle objectHandle,
                                                 ERRORINFO *errorInfo,
                                                 long *volume)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechVoice_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long volume__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechVoice, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetVolume_ (__vtblIFacePtr,
	                                                &volume__Temp));

	if (volume)
		{
		*volume = volume__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechVoice, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechVoiceSetVolume (CAObjHandle objectHandle,
                                                 ERRORINFO *errorInfo,
                                                 long volume)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechVoice_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechVoice, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetVolume_ (__vtblIFacePtr, volume));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechVoice, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechVoiceSetAllowAudioOutputFormatChangesOnNextSet (CAObjHandle objectHandle,
                                                                                 ERRORINFO *errorInfo,
                                                                                 VBOOL allow)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechVoice_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechVoice, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetAllowAudioOutputFormatChangesOnNextSet_ (__vtblIFacePtr,
	                                                                                allow));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechVoice, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechVoiceGetAllowAudioOutputFormatChangesOnNextSet (CAObjHandle objectHandle,
                                                                                 ERRORINFO *errorInfo,
                                                                                 VBOOL *allow)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechVoice_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	VBOOL allow__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechVoice, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetAllowAudioOutputFormatChangesOnNextSet_ (__vtblIFacePtr,
	                                                                                &allow__Temp));

	if (allow)
		{
		*allow = allow__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechVoice, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechVoiceGetEventInterests (CAObjHandle objectHandle,
                                                         ERRORINFO *errorInfo,
                                                         enum SpeechLibEnum_SpeechVoiceEvents *eventInterestFlags)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechVoice_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long eventInterestFlags__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechVoice, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetEventInterests_ (__vtblIFacePtr,
	                                                        (long *)&eventInterestFlags__Temp));

	if (eventInterestFlags)
		{
		*eventInterestFlags = eventInterestFlags__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechVoice, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechVoiceSetEventInterests (CAObjHandle objectHandle,
                                                         ERRORINFO *errorInfo,
                                                         enum SpeechLibEnum_SpeechVoiceEvents eventInterestFlags)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechVoice_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechVoice, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetEventInterests_ (__vtblIFacePtr,
	                                                        eventInterestFlags));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechVoice, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechVoiceSetPriority (CAObjHandle objectHandle,
                                                   ERRORINFO *errorInfo,
                                                   enum SpeechLibEnum_SpeechVoicePriority priority)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechVoice_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechVoice, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetPriority_ (__vtblIFacePtr, priority));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechVoice, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechVoiceGetPriority (CAObjHandle objectHandle,
                                                   ERRORINFO *errorInfo,
                                                   enum SpeechLibEnum_SpeechVoicePriority *priority)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechVoice_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long priority__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechVoice, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetPriority_ (__vtblIFacePtr,
	                                                  (long *)&priority__Temp));

	if (priority)
		{
		*priority = priority__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechVoice, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechVoiceSetAlertBoundary (CAObjHandle objectHandle,
                                                        ERRORINFO *errorInfo,
                                                        enum SpeechLibEnum_SpeechVoiceEvents boundary)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechVoice_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechVoice, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetAlertBoundary_ (__vtblIFacePtr,
	                                                       boundary));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechVoice, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechVoiceGetAlertBoundary (CAObjHandle objectHandle,
                                                        ERRORINFO *errorInfo,
                                                        enum SpeechLibEnum_SpeechVoiceEvents *boundary)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechVoice_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long boundary__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechVoice, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetAlertBoundary_ (__vtblIFacePtr,
	                                                       (long *)&boundary__Temp));

	if (boundary)
		{
		*boundary = boundary__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechVoice, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechVoiceSetSynchronousSpeakTimeout (CAObjHandle objectHandle,
                                                                  ERRORINFO *errorInfo,
                                                                  long msTimeout)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechVoice_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechVoice, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetSynchronousSpeakTimeout_ (__vtblIFacePtr,
	                                                                 msTimeout));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechVoice, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechVoiceGetSynchronousSpeakTimeout (CAObjHandle objectHandle,
                                                                  ERRORINFO *errorInfo,
                                                                  long *msTimeout)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechVoice_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long msTimeout__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechVoice, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetSynchronousSpeakTimeout_ (__vtblIFacePtr,
	                                                                 &msTimeout__Temp));

	if (msTimeout)
		{
		*msTimeout = msTimeout__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechVoice, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechVoiceSpeak (CAObjHandle objectHandle,
                                             ERRORINFO *errorInfo,
                                             const char *text,
                                             enum SpeechLibEnum_SpeechVoiceSpeakFlags flags,
                                             long *streamNumber)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechVoice_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR text__AutoType = 0;
	long streamNumber__Temp;

	__caErrChk (CA_CStringToBSTR (text, &text__AutoType));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechVoice, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Speak_ (__vtblIFacePtr, text__AutoType,
	                                            flags, &streamNumber__Temp));

	if (streamNumber)
		{
		*streamNumber = streamNumber__Temp;
		}

Error:
	CA_FreeBSTR (text__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechVoice, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechVoiceSpeakStream (CAObjHandle objectHandle,
                                                   ERRORINFO *errorInfo,
                                                   SpeechLibObj_ISpeechBaseStream stream,
                                                   enum SpeechLibEnum_SpeechVoiceSpeakFlags flags,
                                                   long *streamNumber)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechVoice_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH stream__AutoType = 0;
	long streamNumber__Temp;

	if (stream)
		{
		__caErrChk (CA_GetInterfaceFromObjHandle (stream,
	                                          &SpeechLib_IID_ISpeechBaseStream,
	                                          1, &stream__AutoType, NULL));
		}

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechVoice, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SpeakStream_ (__vtblIFacePtr,
	                                                  stream__AutoType, flags,
	                                                  &streamNumber__Temp));

	if (streamNumber)
		{
		*streamNumber = streamNumber__Temp;
		}

Error:
	if (stream__AutoType)
		stream__AutoType->lpVtbl->Release (stream__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechVoice, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechVoicePause (CAObjHandle objectHandle,
                                             ERRORINFO *errorInfo)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechVoice_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechVoice, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Pause_ (__vtblIFacePtr));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechVoice, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechVoiceResume (CAObjHandle objectHandle,
                                              ERRORINFO *errorInfo)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechVoice_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechVoice, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Resume_ (__vtblIFacePtr));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechVoice, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechVoiceSkip (CAObjHandle objectHandle,
                                            ERRORINFO *errorInfo,
                                            const char *type, long numItems,
                                            long *numSkipped)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechVoice_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR type__AutoType = 0;
	long numSkipped__Temp;

	__caErrChk (CA_CStringToBSTR (type, &type__AutoType));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechVoice, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Skip_ (__vtblIFacePtr, type__AutoType,
	                                           numItems, &numSkipped__Temp));

	if (numSkipped)
		{
		*numSkipped = numSkipped__Temp;
		}

Error:
	CA_FreeBSTR (type__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechVoice, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechVoiceGetVoices (CAObjHandle objectHandle,
                                                 ERRORINFO *errorInfo,
                                                 const char *requiredAttributes,
                                                 const char *optionalAttributes,
                                                 SpeechLibObj_ISpeechObjectTokens *objectTokens)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechVoice_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR requiredAttributes__AutoType = 0;
	BSTR optionalAttributes__AutoType = 0;
	LPDISPATCH objectTokens__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (objectTokens)
		*objectTokens = 0;

	__caErrChk (CA_CStringToBSTR (requiredAttributes,
	                              &requiredAttributes__AutoType));
	__caErrChk (CA_CStringToBSTR (optionalAttributes,
	                              &optionalAttributes__AutoType));
	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechVoice, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetVoices_ (__vtblIFacePtr,
	                                                requiredAttributes__AutoType,
	                                                optionalAttributes__AutoType,
	                                                &objectTokens__AutoType));
	

	if (objectTokens)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (objectTokens__AutoType,
		                                             &SpeechLib_IID_ISpeechObjectTokens,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, objectTokens));
		objectTokens__AutoType = 0;
		}

Error:
	CA_FreeBSTR (requiredAttributes__AutoType);
	CA_FreeBSTR (optionalAttributes__AutoType);
	if (objectTokens__AutoType)
		objectTokens__AutoType->lpVtbl->Release (objectTokens__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (objectTokens)
			{
			CA_DiscardObjHandle (*objectTokens);
			*objectTokens = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechVoice, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechVoiceGetAudioOutputs (CAObjHandle objectHandle,
                                                       ERRORINFO *errorInfo,
                                                       const char *requiredAttributes,
                                                       const char *optionalAttributes,
                                                       SpeechLibObj_ISpeechObjectTokens *objectTokens)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechVoice_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR requiredAttributes__AutoType = 0;
	BSTR optionalAttributes__AutoType = 0;
	LPDISPATCH objectTokens__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (objectTokens)
		*objectTokens = 0;

	__caErrChk (CA_CStringToBSTR (requiredAttributes,
	                              &requiredAttributes__AutoType));
	__caErrChk (CA_CStringToBSTR (optionalAttributes,
	                              &optionalAttributes__AutoType));
	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechVoice, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetAudioOutputs_ (__vtblIFacePtr,
	                                                      requiredAttributes__AutoType,
	                                                      optionalAttributes__AutoType,
	                                                      &objectTokens__AutoType));
	

	if (objectTokens)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (objectTokens__AutoType,
		                                             &SpeechLib_IID_ISpeechObjectTokens,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, objectTokens));
		objectTokens__AutoType = 0;
		}

Error:
	CA_FreeBSTR (requiredAttributes__AutoType);
	CA_FreeBSTR (optionalAttributes__AutoType);
	if (objectTokens__AutoType)
		objectTokens__AutoType->lpVtbl->Release (objectTokens__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (objectTokens)
			{
			CA_DiscardObjHandle (*objectTokens);
			*objectTokens = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechVoice, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechVoiceWaitUntilDone (CAObjHandle objectHandle,
                                                     ERRORINFO *errorInfo,
                                                     long msTimeout, VBOOL *done)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechVoice_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	VBOOL done__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechVoice, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->WaitUntilDone_ (__vtblIFacePtr,
	                                                    msTimeout, &done__Temp));

	if (done)
		{
		*done = done__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechVoice, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechVoiceSpeakCompleteEvent (CAObjHandle objectHandle,
                                                          ERRORINFO *errorInfo,
                                                          long *handle)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechVoice_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long handle__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechVoice, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SpeakCompleteEvent_ (__vtblIFacePtr,
	                                                         &handle__Temp));

	if (handle)
		{
		*handle = handle__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechVoice, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechVoiceIsUISupported (CAObjHandle objectHandle,
                                                     ERRORINFO *errorInfo,
                                                     const char *typeOfUI,
                                                     VARIANT extraData,
                                                     VBOOL *supported)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechVoice_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR typeOfUI__AutoType = 0;
	VBOOL supported__Temp;

	__caErrChk (CA_CStringToBSTR (typeOfUI, &typeOfUI__AutoType));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechVoice, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->IsUISupported_ (__vtblIFacePtr,
	                                                    typeOfUI__AutoType,
	                                                    &extraData,
	                                                    &supported__Temp));

	if (supported)
		{
		*supported = supported__Temp;
		}

Error:
	CA_FreeBSTR (typeOfUI__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechVoice, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechVoiceDisplayUI (CAObjHandle objectHandle,
                                                 ERRORINFO *errorInfo,
                                                 long hWndParent,
                                                 const char *title,
                                                 const char *typeOfUI,
                                                 VARIANT extraData)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechVoice_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR title__AutoType = 0;
	BSTR typeOfUI__AutoType = 0;

	__caErrChk (CA_CStringToBSTR (title, &title__AutoType));
	__caErrChk (CA_CStringToBSTR (typeOfUI, &typeOfUI__AutoType));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechVoice, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->DisplayUI_ (__vtblIFacePtr, hWndParent,
	                                                title__AutoType,
	                                                typeOfUI__AutoType,
	                                                &extraData));

Error:
	CA_FreeBSTR (title__AutoType);
	CA_FreeBSTR (typeOfUI__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechVoice, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_NewISpVoice (const char *server,
                                       int supportMultithreading, LCID locale,
                                       int reserved, CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x96749377, 0x3391, 0x11D2, 0x9E, 0xE3, 0x0, 0xC0, 0x4F,
	              0x79, 0x73, 0x96};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpVoice,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenISpVoice (const char *fileName, const char *server,
                                        int supportMultithreading, LCID locale,
                                        int reserved, CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x96749377, 0x3391, 0x11D2, 0x9E, 0xE3, 0x0, 0xC0, 0x4F,
	              0x79, 0x73, 0x96};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpVoice,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveISpVoice (const char *server,
                                          int supportMultithreading, LCID locale,
                                          int reserved,
                                          CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x96749377, 0x3391, 0x11D2, 0x9E, 0xE3, 0x0, 0xC0, 0x4F,
	              0x79, 0x73, 0x96};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpVoice,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpVoiceSetNotifySink (CAObjHandle objectHandle,
                                                 ERRORINFO *errorInfo,
                                                 SpeechLibObj_ISpNotifySink pNotifySink)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpVoice_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN pNotifySink__AutoType = 0;

	if (pNotifySink)
		{
		__caErrChk (CA_GetInterfaceFromObjHandle (pNotifySink,
	                                          &SpeechLib_IID_ISpNotifySink, 1,
	                                          &pNotifySink__AutoType, NULL));
		}

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpVoice, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetNotifySink_ (__vtblIFacePtr,
	                                                    pNotifySink__AutoType));

Error:
	if (pNotifySink__AutoType)
		pNotifySink__AutoType->lpVtbl->Release (pNotifySink__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpVoice, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpVoiceSetNotifyWin32Event (CAObjHandle objectHandle,
                                                       ERRORINFO *errorInfo)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpVoice_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpVoice, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetNotifyWin32Event_ (__vtblIFacePtr));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpVoice, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpVoiceWaitForNotifyEvent (CAObjHandle objectHandle,
                                                      ERRORINFO *errorInfo,
                                                      unsigned long dwMilliseconds)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpVoice_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpVoice, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->WaitForNotifyEvent_ (__vtblIFacePtr,
	                                                         dwMilliseconds));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpVoice, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpVoiceGetNotifyEventHandle (CAObjHandle objectHandle,
                                                        ERRORINFO *errorInfo)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpVoice_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpVoice, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetNotifyEventHandle_ (__vtblIFacePtr));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpVoice, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpVoiceSetOutput (CAObjHandle objectHandle,
                                             ERRORINFO *errorInfo,
                                             CAObjHandle pUnkOutput,
                                             long fAllowFormatChanges)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpVoice_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN pUnkOutput__AutoType = 0;

	if (pUnkOutput)
		{
		__caErrChk (CA_GetInterfaceFromObjHandle (pUnkOutput, &IID_IUnknown, 1,
	                                          &pUnkOutput__AutoType, NULL));
		}

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpVoice, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetOutput_ (__vtblIFacePtr,
	                                                pUnkOutput__AutoType,
	                                                fAllowFormatChanges));

Error:
	if (pUnkOutput__AutoType)
		pUnkOutput__AutoType->lpVtbl->Release (pUnkOutput__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpVoice, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpVoiceGetOutputObjectToken (CAObjHandle objectHandle,
                                                        ERRORINFO *errorInfo,
                                                        SpeechLibObj_ISpObjectToken *ppObjectToken)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpVoice_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN ppObjectToken__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (ppObjectToken)
		*ppObjectToken = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpVoice, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetOutputObjectToken_ (__vtblIFacePtr,
	                                                           &ppObjectToken__AutoType));
	

	if (ppObjectToken)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (ppObjectToken__AutoType,
		                                             &SpeechLib_IID_ISpObjectToken,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, ppObjectToken));
		ppObjectToken__AutoType = 0;
		}

Error:
	if (ppObjectToken__AutoType)
		ppObjectToken__AutoType->lpVtbl->Release (ppObjectToken__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (ppObjectToken)
			{
			CA_DiscardObjHandle (*ppObjectToken);
			*ppObjectToken = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpVoice, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpVoiceGetOutputStream (CAObjHandle objectHandle,
                                                   ERRORINFO *errorInfo,
                                                   SpeechLibObj_ISpStreamFormat *ppStream)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpVoice_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN ppStream__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (ppStream)
		*ppStream = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpVoice, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetOutputStream_ (__vtblIFacePtr,
	                                                      &ppStream__AutoType));
	

	if (ppStream)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (ppStream__AutoType,
		                                             &SpeechLib_IID_ISpStreamFormat,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, ppStream));
		ppStream__AutoType = 0;
		}

Error:
	if (ppStream__AutoType)
		ppStream__AutoType->lpVtbl->Release (ppStream__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (ppStream)
			{
			CA_DiscardObjHandle (*ppStream);
			*ppStream = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpVoice, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpVoicePause (CAObjHandle objectHandle,
                                         ERRORINFO *errorInfo)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpVoice_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpVoice, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Pause_ (__vtblIFacePtr));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpVoice, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpVoiceResume (CAObjHandle objectHandle,
                                          ERRORINFO *errorInfo)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpVoice_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpVoice, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Resume_ (__vtblIFacePtr));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpVoice, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpVoiceSetVoice (CAObjHandle objectHandle,
                                            ERRORINFO *errorInfo,
                                            SpeechLibObj_ISpObjectToken pToken)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpVoice_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN pToken__AutoType = 0;

	if (pToken)
		{
		__caErrChk (CA_GetInterfaceFromObjHandle (pToken,
	                                          &SpeechLib_IID_ISpObjectToken, 1,
	                                          &pToken__AutoType, NULL));
		}

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpVoice, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetVoice_ (__vtblIFacePtr,
	                                               pToken__AutoType));

Error:
	if (pToken__AutoType)
		pToken__AutoType->lpVtbl->Release (pToken__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpVoice, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpVoiceGetVoice (CAObjHandle objectHandle,
                                            ERRORINFO *errorInfo,
                                            SpeechLibObj_ISpObjectToken *ppToken)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpVoice_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN ppToken__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (ppToken)
		*ppToken = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpVoice, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetVoice_ (__vtblIFacePtr,
	                                               &ppToken__AutoType));
	

	if (ppToken)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (ppToken__AutoType,
		                                             &SpeechLib_IID_ISpObjectToken,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, ppToken));
		ppToken__AutoType = 0;
		}

Error:
	if (ppToken__AutoType)
		ppToken__AutoType->lpVtbl->Release (ppToken__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (ppToken)
			{
			CA_DiscardObjHandle (*ppToken);
			*ppToken = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpVoice, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpVoiceSpeakStream (CAObjHandle objectHandle,
                                               ERRORINFO *errorInfo,
                                               SpeechLibObj_IStream pStream,
                                               unsigned long dwFlags,
                                               unsigned long *pulStreamNumber)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpVoice_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN pStream__AutoType = 0;
	unsigned long pulStreamNumber__Temp;

	if (pStream)
		{
		__caErrChk (CA_GetInterfaceFromObjHandle (pStream, &SpeechLib_IID_IStream,
	                                          1, &pStream__AutoType, NULL));
		}

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpVoice, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SpeakStream_ (__vtblIFacePtr,
	                                                  pStream__AutoType,
	                                                  dwFlags,
	                                                  &pulStreamNumber__Temp));

	if (pulStreamNumber)
		{
		*pulStreamNumber = pulStreamNumber__Temp;
		}

Error:
	if (pStream__AutoType)
		pStream__AutoType->lpVtbl->Release (pStream__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpVoice, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpVoiceSetPriority (CAObjHandle objectHandle,
                                               ERRORINFO *errorInfo,
                                               enum SpeechLibEnum_SPVPRIORITY ePriority)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpVoice_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpVoice, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetPriority_ (__vtblIFacePtr,
	                                                  ePriority));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpVoice, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpVoiceGetPriority (CAObjHandle objectHandle,
                                               ERRORINFO *errorInfo,
                                               enum SpeechLibEnum_SPVPRIORITY *pePriority)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpVoice_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long pePriority__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpVoice, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetPriority_ (__vtblIFacePtr,
	                                                  (long *)&pePriority__Temp));

	if (pePriority)
		{
		*pePriority = pePriority__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpVoice, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpVoiceSetAlertBoundary (CAObjHandle objectHandle,
                                                    ERRORINFO *errorInfo,
                                                    enum SpeechLibEnum_SPEVENTENUM eBoundary)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpVoice_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpVoice, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetAlertBoundary_ (__vtblIFacePtr,
	                                                       eBoundary));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpVoice, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpVoiceGetAlertBoundary (CAObjHandle objectHandle,
                                                    ERRORINFO *errorInfo,
                                                    enum SpeechLibEnum_SPEVENTENUM *peBoundary)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpVoice_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long peBoundary__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpVoice, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetAlertBoundary_ (__vtblIFacePtr,
	                                                       (long *)&peBoundary__Temp));

	if (peBoundary)
		{
		*peBoundary = peBoundary__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpVoice, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpVoiceSetRate (CAObjHandle objectHandle,
                                           ERRORINFO *errorInfo, long rateAdjust)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpVoice_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpVoice, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetRate_ (__vtblIFacePtr, rateAdjust));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpVoice, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpVoiceGetRate (CAObjHandle objectHandle,
                                           ERRORINFO *errorInfo,
                                           long *pRateAdjust)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpVoice_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long pRateAdjust__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpVoice, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetRate_ (__vtblIFacePtr,
	                                              &pRateAdjust__Temp));

	if (pRateAdjust)
		{
		*pRateAdjust = pRateAdjust__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpVoice, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpVoiceSetVolume (CAObjHandle objectHandle,
                                             ERRORINFO *errorInfo,
                                             unsigned short usVolume)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpVoice_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpVoice, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetVolume_ (__vtblIFacePtr, usVolume));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpVoice, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpVoiceGetVolume (CAObjHandle objectHandle,
                                             ERRORINFO *errorInfo,
                                             unsigned short *pusVolume)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpVoice_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	unsigned short pusVolume__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpVoice, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetVolume_ (__vtblIFacePtr,
	                                                &pusVolume__Temp));

	if (pusVolume)
		{
		*pusVolume = pusVolume__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpVoice, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpVoiceWaitUntilDone (CAObjHandle objectHandle,
                                                 ERRORINFO *errorInfo,
                                                 unsigned long msTimeout)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpVoice_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpVoice, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->WaitUntilDone_ (__vtblIFacePtr,
	                                                    msTimeout));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpVoice, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpVoiceSetSyncSpeakTimeout (CAObjHandle objectHandle,
                                                       ERRORINFO *errorInfo,
                                                       unsigned long msTimeout)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpVoice_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpVoice, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetSyncSpeakTimeout_ (__vtblIFacePtr,
	                                                          msTimeout));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpVoice, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpVoiceGetSyncSpeakTimeout (CAObjHandle objectHandle,
                                                       ERRORINFO *errorInfo,
                                                       unsigned long *pmsTimeout)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpVoice_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	unsigned long pmsTimeout__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpVoice, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetSyncSpeakTimeout_ (__vtblIFacePtr,
	                                                          &pmsTimeout__Temp));

	if (pmsTimeout)
		{
		*pmsTimeout = pmsTimeout__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpVoice, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpVoiceSpeakCompleteEvent (CAObjHandle objectHandle,
                                                      ERRORINFO *errorInfo)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpVoice_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpVoice, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SpeakCompleteEvent_ (__vtblIFacePtr));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpVoice, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_NewSpVoiceISpPhoneticAlphabetSelection (const char *server,
                                                                  int supportMultithreading,
                                                                  LCID locale,
                                                                  int reserved,
                                                                  CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x96749377, 0x3391, 0x11D2, 0x9E, 0xE3, 0x0, 0xC0, 0x4F,
	              0x79, 0x73, 0x96};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpPhoneticAlphabetSelection,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenSpVoiceISpPhoneticAlphabetSelection (const char *fileName,
                                                                   const char *server,
                                                                   int supportMultithreading,
                                                                   LCID locale,
                                                                   int reserved,
                                                                   CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x96749377, 0x3391, 0x11D2, 0x9E, 0xE3, 0x0, 0xC0, 0x4F,
	              0x79, 0x73, 0x96};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpPhoneticAlphabetSelection,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveSpVoiceISpPhoneticAlphabetSelection (const char *server,
                                                                     int supportMultithreading,
                                                                     LCID locale,
                                                                     int reserved,
                                                                     CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x96749377, 0x3391, 0x11D2, 0x9E, 0xE3, 0x0, 0xC0, 0x4F,
	              0x79, 0x73, 0x96};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpPhoneticAlphabetSelection,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_NewSpSharedRecoContextISpPhoneticAlphabetSelection (const char *server,
                                                                              int supportMultithreading,
                                                                              LCID locale,
                                                                              int reserved,
                                                                              CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x47206204, 0x5ECA, 0x11D2, 0x96, 0xF, 0x0, 0xC0, 0x4F, 0x8E,
	              0xE6, 0x28};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpPhoneticAlphabetSelection,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenSpSharedRecoContextISpPhoneticAlphabetSelection (const char *fileName,
                                                                               const char *server,
                                                                               int supportMultithreading,
                                                                               LCID locale,
                                                                               int reserved,
                                                                               CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x47206204, 0x5ECA, 0x11D2, 0x96, 0xF, 0x0, 0xC0, 0x4F, 0x8E,
	              0xE6, 0x28};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpPhoneticAlphabetSelection,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveSpSharedRecoContextISpPhoneticAlphabetSelection (const char *server,
                                                                                 int supportMultithreading,
                                                                                 LCID locale,
                                                                                 int reserved,
                                                                                 CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x47206204, 0x5ECA, 0x11D2, 0x96, 0xF, 0x0, 0xC0, 0x4F, 0x8E,
	              0xE6, 0x28};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpPhoneticAlphabetSelection,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_NewSpLexiconISpPhoneticAlphabetSelection (const char *server,
                                                                    int supportMultithreading,
                                                                    LCID locale,
                                                                    int reserved,
                                                                    CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x655E396, 0x25D0, 0x11D3, 0x9C, 0x26, 0x0, 0xC0, 0x4F, 0x8E,
	              0xF8, 0x7C};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpPhoneticAlphabetSelection,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenSpLexiconISpPhoneticAlphabetSelection (const char *fileName,
                                                                     const char *server,
                                                                     int supportMultithreading,
                                                                     LCID locale,
                                                                     int reserved,
                                                                     CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x655E396, 0x25D0, 0x11D3, 0x9C, 0x26, 0x0, 0xC0, 0x4F, 0x8E,
	              0xF8, 0x7C};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpPhoneticAlphabetSelection,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveSpLexiconISpPhoneticAlphabetSelection (const char *server,
                                                                       int supportMultithreading,
                                                                       LCID locale,
                                                                       int reserved,
                                                                       CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x655E396, 0x25D0, 0x11D3, 0x9C, 0x26, 0x0, 0xC0, 0x4F, 0x8E,
	              0xF8, 0x7C};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpPhoneticAlphabetSelection,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_NewSpUnCompressedLexiconISpPhoneticAlphabetSelection (const char *server,
                                                                                int supportMultithreading,
                                                                                LCID locale,
                                                                                int reserved,
                                                                                CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xC9E37C15, 0xDF92, 0x4727, 0x85, 0xD6, 0x72, 0xE5, 0xEE,
	              0xB6, 0x99, 0x5A};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpPhoneticAlphabetSelection,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenSpUnCompressedLexiconISpPhoneticAlphabetSelection (const char *fileName,
                                                                                 const char *server,
                                                                                 int supportMultithreading,
                                                                                 LCID locale,
                                                                                 int reserved,
                                                                                 CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xC9E37C15, 0xDF92, 0x4727, 0x85, 0xD6, 0x72, 0xE5, 0xEE,
	              0xB6, 0x99, 0x5A};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpPhoneticAlphabetSelection,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveSpUnCompressedLexiconISpPhoneticAlphabetSelection (const char *server,
                                                                                   int supportMultithreading,
                                                                                   LCID locale,
                                                                                   int reserved,
                                                                                   CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xC9E37C15, 0xDF92, 0x4727, 0x85, 0xD6, 0x72, 0xE5, 0xEE,
	              0xB6, 0x99, 0x5A};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpPhoneticAlphabetSelection,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_NewSpPhoneConverterISpPhoneticAlphabetSelection (const char *server,
                                                                           int supportMultithreading,
                                                                           LCID locale,
                                                                           int reserved,
                                                                           CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x9185F743, 0x1143, 0x4C28, 0x86, 0xB5, 0xBF, 0xF1, 0x4F,
	              0x20, 0xE5, 0xC8};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpPhoneticAlphabetSelection,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenSpPhoneConverterISpPhoneticAlphabetSelection (const char *fileName,
                                                                            const char *server,
                                                                            int supportMultithreading,
                                                                            LCID locale,
                                                                            int reserved,
                                                                            CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x9185F743, 0x1143, 0x4C28, 0x86, 0xB5, 0xBF, 0xF1, 0x4F,
	              0x20, 0xE5, 0xC8};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpPhoneticAlphabetSelection,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveSpPhoneConverterISpPhoneticAlphabetSelection (const char *server,
                                                                              int supportMultithreading,
                                                                              LCID locale,
                                                                              int reserved,
                                                                              CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x9185F743, 0x1143, 0x4C28, 0x86, 0xB5, 0xBF, 0xF1, 0x4F,
	              0x20, 0xE5, 0xC8};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpPhoneticAlphabetSelection,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_NewSpInProcRecoContextISpPhoneticAlphabetSelection (const char *server,
                                                                              int supportMultithreading,
                                                                              LCID locale,
                                                                              int reserved,
                                                                              CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x73AD6842, 0xACE0, 0x45E8, 0xA4, 0xDD, 0x87, 0x95, 0x88,
	              0x1A, 0x2C, 0x2A};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpPhoneticAlphabetSelection,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenSpInProcRecoContextISpPhoneticAlphabetSelection (const char *fileName,
                                                                               const char *server,
                                                                               int supportMultithreading,
                                                                               LCID locale,
                                                                               int reserved,
                                                                               CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x73AD6842, 0xACE0, 0x45E8, 0xA4, 0xDD, 0x87, 0x95, 0x88,
	              0x1A, 0x2C, 0x2A};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpPhoneticAlphabetSelection,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveSpInProcRecoContextISpPhoneticAlphabetSelection (const char *server,
                                                                                 int supportMultithreading,
                                                                                 LCID locale,
                                                                                 int reserved,
                                                                                 CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x73AD6842, 0xACE0, 0x45E8, 0xA4, 0xDD, 0x87, 0x95, 0x88,
	              0x1A, 0x2C, 0x2A};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpPhoneticAlphabetSelection,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpPhoneticAlphabetSelectionIsAlphabetUPS (CAObjHandle objectHandle,
                                                                     ERRORINFO *errorInfo,
                                                                     long *pfIsUPS)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpPhoneticAlphabetSelection_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long pfIsUPS__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpPhoneticAlphabetSelection,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->IsAlphabetUPS_ (__vtblIFacePtr,
	                                                    &pfIsUPS__Temp));

	if (pfIsUPS)
		{
		*pfIsUPS = pfIsUPS__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle,
	                    &SpeechLib_IID_ISpPhoneticAlphabetSelection, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpPhoneticAlphabetSelectionSetAlphabetToUPS (CAObjHandle objectHandle,
                                                                        ERRORINFO *errorInfo,
                                                                        long fForceUPS)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpPhoneticAlphabetSelection_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpPhoneticAlphabetSelection,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetAlphabetToUPS_ (__vtblIFacePtr,
	                                                       fForceUPS));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle,
	                    &SpeechLib_IID_ISpPhoneticAlphabetSelection, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_NewSpSharedRecoContextISpeechRecoContext (const char *server,
                                                                    int supportMultithreading,
                                                                    LCID locale,
                                                                    int reserved,
                                                                    CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x47206204, 0x5ECA, 0x11D2, 0x96, 0xF, 0x0, 0xC0, 0x4F, 0x8E,
	              0xE6, 0x28};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpeechRecoContext,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenSpSharedRecoContextISpeechRecoContext (const char *fileName,
                                                                     const char *server,
                                                                     int supportMultithreading,
                                                                     LCID locale,
                                                                     int reserved,
                                                                     CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x47206204, 0x5ECA, 0x11D2, 0x96, 0xF, 0x0, 0xC0, 0x4F, 0x8E,
	              0xE6, 0x28};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpeechRecoContext,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveSpSharedRecoContextISpeechRecoContext (const char *server,
                                                                       int supportMultithreading,
                                                                       LCID locale,
                                                                       int reserved,
                                                                       CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x47206204, 0x5ECA, 0x11D2, 0x96, 0xF, 0x0, 0xC0, 0x4F, 0x8E,
	              0xE6, 0x28};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpeechRecoContext,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_NewSpInProcRecoContextISpeechRecoContext (const char *server,
                                                                    int supportMultithreading,
                                                                    LCID locale,
                                                                    int reserved,
                                                                    CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x73AD6842, 0xACE0, 0x45E8, 0xA4, 0xDD, 0x87, 0x95, 0x88,
	              0x1A, 0x2C, 0x2A};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpeechRecoContext,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenSpInProcRecoContextISpeechRecoContext (const char *fileName,
                                                                     const char *server,
                                                                     int supportMultithreading,
                                                                     LCID locale,
                                                                     int reserved,
                                                                     CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x73AD6842, 0xACE0, 0x45E8, 0xA4, 0xDD, 0x87, 0x95, 0x88,
	              0x1A, 0x2C, 0x2A};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpeechRecoContext,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveSpInProcRecoContextISpeechRecoContext (const char *server,
                                                                       int supportMultithreading,
                                                                       LCID locale,
                                                                       int reserved,
                                                                       CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x73AD6842, 0xACE0, 0x45E8, 0xA4, 0xDD, 0x87, 0x95, 0x88,
	              0x1A, 0x2C, 0x2A};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpeechRecoContext,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoContextGetRecognizer (CAObjHandle objectHandle,
                                                           ERRORINFO *errorInfo,
                                                           SpeechLibObj_ISpeechRecognizer *recognizer)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoContext_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH recognizer__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (recognizer)
		*recognizer = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoContext,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetRecognizer_ (__vtblIFacePtr,
	                                                    &recognizer__AutoType));
	

	if (recognizer)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (recognizer__AutoType,
		                                             &SpeechLib_IID_ISpeechRecognizer,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, recognizer));
		recognizer__AutoType = 0;
		}

Error:
	if (recognizer__AutoType)
		recognizer__AutoType->lpVtbl->Release (recognizer__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (recognizer)
			{
			CA_DiscardObjHandle (*recognizer);
			*recognizer = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoContext,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoContextGetAudioInputInterferenceStatus (CAObjHandle objectHandle,
                                                                             ERRORINFO *errorInfo,
                                                                             enum SpeechLibEnum_SpeechInterference *interference)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoContext_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long interference__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoContext,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetAudioInputInterferenceStatus_ (__vtblIFacePtr,
	                                                                      (long *)&interference__Temp));

	if (interference)
		{
		*interference = interference__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoContext,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoContextGetRequestedUIType (CAObjHandle objectHandle,
                                                                ERRORINFO *errorInfo,
                                                                char **UIType)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoContext_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR UIType__AutoType = 0;

	if (UIType)
		*UIType = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoContext,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetRequestedUIType_ (__vtblIFacePtr,
	                                                         &UIType__AutoType));

	if (UIType)
		__caErrChk (CA_BSTRGetCString (UIType__AutoType, UIType));

Error:
	CA_FreeBSTR (UIType__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (UIType)
			{
			CA_FreeMemory (*UIType);
			*UIType = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoContext,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoContextSetByRefVoice (CAObjHandle objectHandle,
                                                           ERRORINFO *errorInfo,
                                                           SpeechLibObj_ISpeechVoice voice)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoContext_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH voice__AutoType = 0;

	if (voice)
		{
		__caErrChk (CA_GetInterfaceFromObjHandle (voice,
	                                          &SpeechLib_IID_ISpeechVoice, 1,
	                                          &voice__AutoType, NULL));
		}

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoContext,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetByRefVoice_ (__vtblIFacePtr,
	                                                    voice__AutoType));

Error:
	if (voice__AutoType)
		voice__AutoType->lpVtbl->Release (voice__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoContext,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoContextGetVoice (CAObjHandle objectHandle,
                                                      ERRORINFO *errorInfo,
                                                      SpeechLibObj_ISpeechVoice *voice)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoContext_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH voice__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (voice)
		*voice = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoContext,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetVoice_ (__vtblIFacePtr,
	                                               &voice__AutoType));
	

	if (voice)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (voice__AutoType,
		                                             &SpeechLib_IID_ISpeechVoice,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, voice));
		voice__AutoType = 0;
		}

Error:
	if (voice__AutoType)
		voice__AutoType->lpVtbl->Release (voice__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (voice)
			{
			CA_DiscardObjHandle (*voice);
			*voice = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoContext,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoContextSetAllowVoiceFormatMatchingOnNextSet (CAObjHandle objectHandle,
                                                                                  ERRORINFO *errorInfo,
                                                                                  VBOOL pAllow)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoContext_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoContext,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetAllowVoiceFormatMatchingOnNextSet_ (__vtblIFacePtr,
	                                                                           pAllow));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoContext,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoContextGetAllowVoiceFormatMatchingOnNextSet (CAObjHandle objectHandle,
                                                                                  ERRORINFO *errorInfo,
                                                                                  VBOOL *pAllow)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoContext_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	VBOOL pAllow__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoContext,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetAllowVoiceFormatMatchingOnNextSet_ (__vtblIFacePtr,
	                                                                           &pAllow__Temp));

	if (pAllow)
		{
		*pAllow = pAllow__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoContext,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoContextSetVoicePurgeEvent (CAObjHandle objectHandle,
                                                                ERRORINFO *errorInfo,
                                                                enum SpeechLibEnum_SpeechRecoEvents eventInterest)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoContext_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoContext,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetVoicePurgeEvent_ (__vtblIFacePtr,
	                                                         eventInterest));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoContext,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoContextGetVoicePurgeEvent (CAObjHandle objectHandle,
                                                                ERRORINFO *errorInfo,
                                                                enum SpeechLibEnum_SpeechRecoEvents *eventInterest)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoContext_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long eventInterest__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoContext,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetVoicePurgeEvent_ (__vtblIFacePtr,
	                                                         (long *)&eventInterest__Temp));

	if (eventInterest)
		{
		*eventInterest = eventInterest__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoContext,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoContextSetEventInterests (CAObjHandle objectHandle,
                                                               ERRORINFO *errorInfo,
                                                               enum SpeechLibEnum_SpeechRecoEvents eventInterest)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoContext_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoContext,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetEventInterests_ (__vtblIFacePtr,
	                                                        eventInterest));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoContext,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoContextGetEventInterests (CAObjHandle objectHandle,
                                                               ERRORINFO *errorInfo,
                                                               enum SpeechLibEnum_SpeechRecoEvents *eventInterest)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoContext_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long eventInterest__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoContext,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetEventInterests_ (__vtblIFacePtr,
	                                                        (long *)&eventInterest__Temp));

	if (eventInterest)
		{
		*eventInterest = eventInterest__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoContext,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoContextSetCmdMaxAlternates (CAObjHandle objectHandle,
                                                                 ERRORINFO *errorInfo,
                                                                 long maxAlternates)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoContext_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoContext,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetCmdMaxAlternates_ (__vtblIFacePtr,
	                                                          maxAlternates));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoContext,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoContextGetCmdMaxAlternates (CAObjHandle objectHandle,
                                                                 ERRORINFO *errorInfo,
                                                                 long *maxAlternates)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoContext_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long maxAlternates__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoContext,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetCmdMaxAlternates_ (__vtblIFacePtr,
	                                                          &maxAlternates__Temp));

	if (maxAlternates)
		{
		*maxAlternates = maxAlternates__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoContext,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoContextSetState (CAObjHandle objectHandle,
                                                      ERRORINFO *errorInfo,
                                                      enum SpeechLibEnum_SpeechRecoContextState state)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoContext_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoContext,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetState_ (__vtblIFacePtr, state));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoContext,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoContextGetState (CAObjHandle objectHandle,
                                                      ERRORINFO *errorInfo,
                                                      enum SpeechLibEnum_SpeechRecoContextState *state)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoContext_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long state__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoContext,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetState_ (__vtblIFacePtr,
	                                               (long *)&state__Temp));

	if (state)
		{
		*state = state__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoContext,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoContextSetRetainedAudio (CAObjHandle objectHandle,
                                                              ERRORINFO *errorInfo,
                                                              enum SpeechLibEnum_SpeechRetainedAudioOptions option)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoContext_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoContext,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetRetainedAudio_ (__vtblIFacePtr,
	                                                       option));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoContext,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoContextGetRetainedAudio (CAObjHandle objectHandle,
                                                              ERRORINFO *errorInfo,
                                                              enum SpeechLibEnum_SpeechRetainedAudioOptions *option)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoContext_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long option__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoContext,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetRetainedAudio_ (__vtblIFacePtr,
	                                                       (long *)&option__Temp));

	if (option)
		{
		*option = option__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoContext,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoContextSetByRefRetainedAudioFormat (CAObjHandle objectHandle,
                                                                         ERRORINFO *errorInfo,
                                                                         SpeechLibObj_ISpeechAudioFormat format)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoContext_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH format__AutoType = 0;

	if (format)
		{
		__caErrChk (CA_GetInterfaceFromObjHandle (format,
	                                          &SpeechLib_IID_ISpeechAudioFormat,
	                                          1, &format__AutoType, NULL));
		}

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoContext,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetByRefRetainedAudioFormat_ (__vtblIFacePtr,
	                                                                  format__AutoType));

Error:
	if (format__AutoType)
		format__AutoType->lpVtbl->Release (format__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoContext,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoContextGetRetainedAudioFormat (CAObjHandle objectHandle,
                                                                    ERRORINFO *errorInfo,
                                                                    SpeechLibObj_ISpeechAudioFormat *format)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoContext_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH format__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (format)
		*format = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoContext,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetRetainedAudioFormat_ (__vtblIFacePtr,
	                                                             &format__AutoType));
	

	if (format)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (format__AutoType,
		                                             &SpeechLib_IID_ISpeechAudioFormat,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, format));
		format__AutoType = 0;
		}

Error:
	if (format__AutoType)
		format__AutoType->lpVtbl->Release (format__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (format)
			{
			CA_DiscardObjHandle (*format);
			*format = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoContext,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoContextPause (CAObjHandle objectHandle,
                                                   ERRORINFO *errorInfo)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoContext_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoContext,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Pause_ (__vtblIFacePtr));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoContext,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoContextResume (CAObjHandle objectHandle,
                                                    ERRORINFO *errorInfo)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoContext_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoContext,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Resume_ (__vtblIFacePtr));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoContext,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoContextCreateGrammar (CAObjHandle objectHandle,
                                                           ERRORINFO *errorInfo,
                                                           VARIANT grammarId,
                                                           SpeechLibObj_ISpeechRecoGrammar *grammar)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoContext_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH grammar__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (grammar)
		*grammar = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoContext,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->CreateGrammar_ (__vtblIFacePtr,
	                                                    grammarId,
	                                                    &grammar__AutoType));
	

	if (grammar)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (grammar__AutoType,
		                                             &SpeechLib_IID_ISpeechRecoGrammar,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, grammar));
		grammar__AutoType = 0;
		}

Error:
	if (grammar__AutoType)
		grammar__AutoType->lpVtbl->Release (grammar__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (grammar)
			{
			CA_DiscardObjHandle (*grammar);
			*grammar = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoContext,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoContextCreateResultFromMemory (CAObjHandle objectHandle,
                                                                    ERRORINFO *errorInfo,
                                                                    VARIANT resultBlock,
                                                                    SpeechLibObj_ISpeechRecoResult *result)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoContext_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH result__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (result)
		*result = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoContext,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->CreateResultFromMemory_ (__vtblIFacePtr,
	                                                             &resultBlock,
	                                                             &result__AutoType));
	

	if (result)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (result__AutoType,
		                                             &SpeechLib_IID_ISpeechRecoResult,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, result));
		result__AutoType = 0;
		}

Error:
	if (result__AutoType)
		result__AutoType->lpVtbl->Release (result__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (result)
			{
			CA_DiscardObjHandle (*result);
			*result = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoContext,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoContextBookmark (CAObjHandle objectHandle,
                                                      ERRORINFO *errorInfo,
                                                      enum SpeechLibEnum_SpeechBookmarkOptions options,
                                                      VARIANT streamPos,
                                                      VARIANT bookmarkId)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoContext_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoContext,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Bookmark_ (__vtblIFacePtr, options,
	                                               streamPos, bookmarkId));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoContext,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoContextSetAdaptationData (CAObjHandle objectHandle,
                                                               ERRORINFO *errorInfo,
                                                               const char *adaptationString)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoContext_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR adaptationString__AutoType = 0;

	__caErrChk (CA_CStringToBSTR (adaptationString,
	                              &adaptationString__AutoType));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoContext,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetAdaptationData_ (__vtblIFacePtr,
	                                                        adaptationString__AutoType));

Error:
	CA_FreeBSTR (adaptationString__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoContext,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_NewSpSharedRecoContextISpRecoContext (const char *server,
                                                                int supportMultithreading,
                                                                LCID locale,
                                                                int reserved,
                                                                CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x47206204, 0x5ECA, 0x11D2, 0x96, 0xF, 0x0, 0xC0, 0x4F, 0x8E,
	              0xE6, 0x28};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpRecoContext,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenSpSharedRecoContextISpRecoContext (const char *fileName,
                                                                 const char *server,
                                                                 int supportMultithreading,
                                                                 LCID locale,
                                                                 int reserved,
                                                                 CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x47206204, 0x5ECA, 0x11D2, 0x96, 0xF, 0x0, 0xC0, 0x4F, 0x8E,
	              0xE6, 0x28};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpRecoContext,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveSpSharedRecoContextISpRecoContext (const char *server,
                                                                   int supportMultithreading,
                                                                   LCID locale,
                                                                   int reserved,
                                                                   CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x47206204, 0x5ECA, 0x11D2, 0x96, 0xF, 0x0, 0xC0, 0x4F, 0x8E,
	              0xE6, 0x28};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpRecoContext,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_NewSpInProcRecoContextISpRecoContext (const char *server,
                                                                int supportMultithreading,
                                                                LCID locale,
                                                                int reserved,
                                                                CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x73AD6842, 0xACE0, 0x45E8, 0xA4, 0xDD, 0x87, 0x95, 0x88,
	              0x1A, 0x2C, 0x2A};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpRecoContext,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenSpInProcRecoContextISpRecoContext (const char *fileName,
                                                                 const char *server,
                                                                 int supportMultithreading,
                                                                 LCID locale,
                                                                 int reserved,
                                                                 CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x73AD6842, 0xACE0, 0x45E8, 0xA4, 0xDD, 0x87, 0x95, 0x88,
	              0x1A, 0x2C, 0x2A};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpRecoContext,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveSpInProcRecoContextISpRecoContext (const char *server,
                                                                   int supportMultithreading,
                                                                   LCID locale,
                                                                   int reserved,
                                                                   CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x73AD6842, 0xACE0, 0x45E8, 0xA4, 0xDD, 0x87, 0x95, 0x88,
	              0x1A, 0x2C, 0x2A};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpRecoContext,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpRecoContextSetNotifySink (CAObjHandle objectHandle,
                                                       ERRORINFO *errorInfo,
                                                       SpeechLibObj_ISpNotifySink pNotifySink)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpRecoContext_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN pNotifySink__AutoType = 0;

	if (pNotifySink)
		{
		__caErrChk (CA_GetInterfaceFromObjHandle (pNotifySink,
	                                          &SpeechLib_IID_ISpNotifySink, 1,
	                                          &pNotifySink__AutoType, NULL));
		}

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpRecoContext, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetNotifySink_ (__vtblIFacePtr,
	                                                    pNotifySink__AutoType));

Error:
	if (pNotifySink__AutoType)
		pNotifySink__AutoType->lpVtbl->Release (pNotifySink__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpRecoContext, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpRecoContextSetNotifyWin32Event (CAObjHandle objectHandle,
                                                             ERRORINFO *errorInfo)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpRecoContext_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpRecoContext, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetNotifyWin32Event_ (__vtblIFacePtr));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpRecoContext, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpRecoContextWaitForNotifyEvent (CAObjHandle objectHandle,
                                                            ERRORINFO *errorInfo,
                                                            unsigned long dwMilliseconds)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpRecoContext_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpRecoContext, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->WaitForNotifyEvent_ (__vtblIFacePtr,
	                                                         dwMilliseconds));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpRecoContext, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpRecoContextGetNotifyEventHandle (CAObjHandle objectHandle,
                                                              ERRORINFO *errorInfo)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpRecoContext_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpRecoContext, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetNotifyEventHandle_ (__vtblIFacePtr));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpRecoContext, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpRecoContextGetRecognizer (CAObjHandle objectHandle,
                                                       ERRORINFO *errorInfo,
                                                       SpeechLibObj_ISpRecognizer *ppRecognizer)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpRecoContext_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN ppRecognizer__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (ppRecognizer)
		*ppRecognizer = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpRecoContext, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetRecognizer_ (__vtblIFacePtr,
	                                                    &ppRecognizer__AutoType));
	

	if (ppRecognizer)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (ppRecognizer__AutoType,
		                                             &SpeechLib_IID_ISpRecognizer,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, ppRecognizer));
		ppRecognizer__AutoType = 0;
		}

Error:
	if (ppRecognizer__AutoType)
		ppRecognizer__AutoType->lpVtbl->Release (ppRecognizer__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (ppRecognizer)
			{
			CA_DiscardObjHandle (*ppRecognizer);
			*ppRecognizer = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpRecoContext, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpRecoContextGetMaxAlternates (CAObjHandle objectHandle,
                                                          ERRORINFO *errorInfo,
                                                          unsigned long *pcAlternates)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpRecoContext_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpRecoContext, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetMaxAlternates_ (__vtblIFacePtr,
	                                                       pcAlternates));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpRecoContext, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpRecoContextSetMaxAlternates (CAObjHandle objectHandle,
                                                          ERRORINFO *errorInfo,
                                                          unsigned long cAlternates)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpRecoContext_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpRecoContext, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetMaxAlternates_ (__vtblIFacePtr,
	                                                       cAlternates));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpRecoContext, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpRecoContextPause (CAObjHandle objectHandle,
                                               ERRORINFO *errorInfo,
                                               unsigned long dwReserved)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpRecoContext_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpRecoContext, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Pause_ (__vtblIFacePtr, dwReserved));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpRecoContext, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpRecoContextResume (CAObjHandle objectHandle,
                                                ERRORINFO *errorInfo,
                                                unsigned long dwReserved)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpRecoContext_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpRecoContext, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Resume_ (__vtblIFacePtr, dwReserved));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpRecoContext, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpRecoContextSetVoice (CAObjHandle objectHandle,
                                                  ERRORINFO *errorInfo,
                                                  SpeechLibObj_ISpVoice pVoice,
                                                  long fAllowFormatChanges)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpRecoContext_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN pVoice__AutoType = 0;

	if (pVoice)
		{
		__caErrChk (CA_GetInterfaceFromObjHandle (pVoice, &SpeechLib_IID_ISpVoice,
	                                          1, &pVoice__AutoType, NULL));
		}

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpRecoContext, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetVoice_ (__vtblIFacePtr,
	                                               pVoice__AutoType,
	                                               fAllowFormatChanges));

Error:
	if (pVoice__AutoType)
		pVoice__AutoType->lpVtbl->Release (pVoice__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpRecoContext, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpRecoContextGetVoice (CAObjHandle objectHandle,
                                                  ERRORINFO *errorInfo,
                                                  SpeechLibObj_ISpVoice *ppVoice)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpRecoContext_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN ppVoice__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (ppVoice)
		*ppVoice = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpRecoContext, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetVoice_ (__vtblIFacePtr,
	                                               &ppVoice__AutoType));
	

	if (ppVoice)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (ppVoice__AutoType,
		                                             &SpeechLib_IID_ISpVoice,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, ppVoice));
		ppVoice__AutoType = 0;
		}

Error:
	if (ppVoice__AutoType)
		ppVoice__AutoType->lpVtbl->Release (ppVoice__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (ppVoice)
			{
			CA_DiscardObjHandle (*ppVoice);
			*ppVoice = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpRecoContext, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpRecoContextSetContextState (CAObjHandle objectHandle,
                                                         ERRORINFO *errorInfo,
                                                         enum SpeechLibEnum_SPCONTEXTSTATE eContextState)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpRecoContext_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpRecoContext, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetContextState_ (__vtblIFacePtr,
	                                                      eContextState));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpRecoContext, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpRecoContextGetContextState (CAObjHandle objectHandle,
                                                         ERRORINFO *errorInfo,
                                                         enum SpeechLibEnum_SPCONTEXTSTATE *peContextState)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpRecoContext_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long peContextState__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpRecoContext, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetContextState_ (__vtblIFacePtr,
	                                                      (long *)&peContextState__Temp));

	if (peContextState)
		{
		*peContextState = peContextState__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpRecoContext, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_NewSpSharedRecoContextISpRecoContext2 (const char *server,
                                                                 int supportMultithreading,
                                                                 LCID locale,
                                                                 int reserved,
                                                                 CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x47206204, 0x5ECA, 0x11D2, 0x96, 0xF, 0x0, 0xC0, 0x4F, 0x8E,
	              0xE6, 0x28};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpRecoContext2,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenSpSharedRecoContextISpRecoContext2 (const char *fileName,
                                                                  const char *server,
                                                                  int supportMultithreading,
                                                                  LCID locale,
                                                                  int reserved,
                                                                  CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x47206204, 0x5ECA, 0x11D2, 0x96, 0xF, 0x0, 0xC0, 0x4F, 0x8E,
	              0xE6, 0x28};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpRecoContext2,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveSpSharedRecoContextISpRecoContext2 (const char *server,
                                                                    int supportMultithreading,
                                                                    LCID locale,
                                                                    int reserved,
                                                                    CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x47206204, 0x5ECA, 0x11D2, 0x96, 0xF, 0x0, 0xC0, 0x4F, 0x8E,
	              0xE6, 0x28};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpRecoContext2,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_NewSpInProcRecoContextISpRecoContext2 (const char *server,
                                                                 int supportMultithreading,
                                                                 LCID locale,
                                                                 int reserved,
                                                                 CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x73AD6842, 0xACE0, 0x45E8, 0xA4, 0xDD, 0x87, 0x95, 0x88,
	              0x1A, 0x2C, 0x2A};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpRecoContext2,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenSpInProcRecoContextISpRecoContext2 (const char *fileName,
                                                                  const char *server,
                                                                  int supportMultithreading,
                                                                  LCID locale,
                                                                  int reserved,
                                                                  CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x73AD6842, 0xACE0, 0x45E8, 0xA4, 0xDD, 0x87, 0x95, 0x88,
	              0x1A, 0x2C, 0x2A};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpRecoContext2,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveSpInProcRecoContextISpRecoContext2 (const char *server,
                                                                    int supportMultithreading,
                                                                    LCID locale,
                                                                    int reserved,
                                                                    CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x73AD6842, 0xACE0, 0x45E8, 0xA4, 0xDD, 0x87, 0x95, 0x88,
	              0x1A, 0x2C, 0x2A};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpRecoContext2,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpRecoContext2SetGrammarOptions (CAObjHandle objectHandle,
                                                            ERRORINFO *errorInfo,
                                                            unsigned long eGrammarOptions)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpRecoContext2_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpRecoContext2,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetGrammarOptions_ (__vtblIFacePtr,
	                                                        eGrammarOptions));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpRecoContext2, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpRecoContext2GetGrammarOptions (CAObjHandle objectHandle,
                                                            ERRORINFO *errorInfo,
                                                            unsigned long *peGrammarOptions)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpRecoContext2_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	unsigned long peGrammarOptions__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpRecoContext2,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetGrammarOptions_ (__vtblIFacePtr,
	                                                        &peGrammarOptions__Temp));

	if (peGrammarOptions)
		{
		*peGrammarOptions = peGrammarOptions__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpRecoContext2, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_NewSpInprocRecognizerISpeechRecognizer (const char *server,
                                                                  int supportMultithreading,
                                                                  LCID locale,
                                                                  int reserved,
                                                                  CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x41B89B6B, 0x9399, 0x11D2, 0x96, 0x23, 0x0, 0xC0, 0x4F,
	              0x8E, 0xE6, 0x28};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpeechRecognizer,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenSpInprocRecognizerISpeechRecognizer (const char *fileName,
                                                                   const char *server,
                                                                   int supportMultithreading,
                                                                   LCID locale,
                                                                   int reserved,
                                                                   CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x41B89B6B, 0x9399, 0x11D2, 0x96, 0x23, 0x0, 0xC0, 0x4F,
	              0x8E, 0xE6, 0x28};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpeechRecognizer,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveSpInprocRecognizerISpeechRecognizer (const char *server,
                                                                     int supportMultithreading,
                                                                     LCID locale,
                                                                     int reserved,
                                                                     CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x41B89B6B, 0x9399, 0x11D2, 0x96, 0x23, 0x0, 0xC0, 0x4F,
	              0x8E, 0xE6, 0x28};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpeechRecognizer,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_NewSpSharedRecognizerISpeechRecognizer (const char *server,
                                                                  int supportMultithreading,
                                                                  LCID locale,
                                                                  int reserved,
                                                                  CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x3BEE4890, 0x4FE9, 0x4A37, 0x8C, 0x1E, 0x5E, 0x7E, 0x12,
	              0x79, 0x1C, 0x1F};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpeechRecognizer,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenSpSharedRecognizerISpeechRecognizer (const char *fileName,
                                                                   const char *server,
                                                                   int supportMultithreading,
                                                                   LCID locale,
                                                                   int reserved,
                                                                   CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x3BEE4890, 0x4FE9, 0x4A37, 0x8C, 0x1E, 0x5E, 0x7E, 0x12,
	              0x79, 0x1C, 0x1F};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpeechRecognizer,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveSpSharedRecognizerISpeechRecognizer (const char *server,
                                                                     int supportMultithreading,
                                                                     LCID locale,
                                                                     int reserved,
                                                                     CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x3BEE4890, 0x4FE9, 0x4A37, 0x8C, 0x1E, 0x5E, 0x7E, 0x12,
	              0x79, 0x1C, 0x1F};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpeechRecognizer,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecognizerSetByRefRecognizer (CAObjHandle objectHandle,
                                                               ERRORINFO *errorInfo,
                                                               SpeechLibObj_ISpeechObjectToken recognizer)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecognizer_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH recognizer__AutoType = 0;

	if (recognizer)
		{
		__caErrChk (CA_GetInterfaceFromObjHandle (recognizer,
	                                          &SpeechLib_IID_ISpeechObjectToken,
	                                          1, &recognizer__AutoType, NULL));
		}

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecognizer,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetByRefRecognizer_ (__vtblIFacePtr,
	                                                         recognizer__AutoType));

Error:
	if (recognizer__AutoType)
		recognizer__AutoType->lpVtbl->Release (recognizer__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecognizer,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecognizerGetRecognizer (CAObjHandle objectHandle,
                                                          ERRORINFO *errorInfo,
                                                          SpeechLibObj_ISpeechObjectToken *recognizer)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecognizer_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH recognizer__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (recognizer)
		*recognizer = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecognizer,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetRecognizer_ (__vtblIFacePtr,
	                                                    &recognizer__AutoType));
	

	if (recognizer)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (recognizer__AutoType,
		                                             &SpeechLib_IID_ISpeechObjectToken,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, recognizer));
		recognizer__AutoType = 0;
		}

Error:
	if (recognizer__AutoType)
		recognizer__AutoType->lpVtbl->Release (recognizer__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (recognizer)
			{
			CA_DiscardObjHandle (*recognizer);
			*recognizer = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecognizer,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecognizerSetAllowAudioInputFormatChangesOnNextSet (CAObjHandle objectHandle,
                                                                                     ERRORINFO *errorInfo,
                                                                                     VBOOL allow)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecognizer_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecognizer,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetAllowAudioInputFormatChangesOnNextSet_ (__vtblIFacePtr,
	                                                                               allow));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecognizer,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecognizerGetAllowAudioInputFormatChangesOnNextSet (CAObjHandle objectHandle,
                                                                                     ERRORINFO *errorInfo,
                                                                                     VBOOL *allow)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecognizer_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	VBOOL allow__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecognizer,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetAllowAudioInputFormatChangesOnNextSet_ (__vtblIFacePtr,
	                                                                               &allow__Temp));

	if (allow)
		{
		*allow = allow__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecognizer,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecognizerSetByRefAudioInput (CAObjHandle objectHandle,
                                                               ERRORINFO *errorInfo,
                                                               SpeechLibObj_ISpeechObjectToken audioInput)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecognizer_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH audioInput__AutoType = 0;

	if (audioInput)
		{
		__caErrChk (CA_GetInterfaceFromObjHandle (audioInput,
	                                          &SpeechLib_IID_ISpeechObjectToken,
	                                          1, &audioInput__AutoType, NULL));
		}

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecognizer,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetByRefAudioInput_ (__vtblIFacePtr,
	                                                         audioInput__AutoType));

Error:
	if (audioInput__AutoType)
		audioInput__AutoType->lpVtbl->Release (audioInput__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecognizer,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecognizerGetAudioInput (CAObjHandle objectHandle,
                                                          ERRORINFO *errorInfo,
                                                          SpeechLibObj_ISpeechObjectToken *audioInput)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecognizer_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH audioInput__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (audioInput)
		*audioInput = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecognizer,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetAudioInput_ (__vtblIFacePtr,
	                                                    &audioInput__AutoType));
	

	if (audioInput)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (audioInput__AutoType,
		                                             &SpeechLib_IID_ISpeechObjectToken,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, audioInput));
		audioInput__AutoType = 0;
		}

Error:
	if (audioInput__AutoType)
		audioInput__AutoType->lpVtbl->Release (audioInput__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (audioInput)
			{
			CA_DiscardObjHandle (*audioInput);
			*audioInput = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecognizer,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecognizerSetByRefAudioInputStream (CAObjHandle objectHandle,
                                                                     ERRORINFO *errorInfo,
                                                                     SpeechLibObj_ISpeechBaseStream audioInputStream)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecognizer_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH audioInputStream__AutoType = 0;

	if (audioInputStream)
		{
		__caErrChk (CA_GetInterfaceFromObjHandle (audioInputStream,
	                                          &SpeechLib_IID_ISpeechBaseStream,
	                                          1, &audioInputStream__AutoType,
	                                          NULL));
		}

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecognizer,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetByRefAudioInputStream_ (__vtblIFacePtr,
	                                                               audioInputStream__AutoType));

Error:
	if (audioInputStream__AutoType)
		audioInputStream__AutoType->lpVtbl->Release (audioInputStream__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecognizer,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecognizerGetAudioInputStream (CAObjHandle objectHandle,
                                                                ERRORINFO *errorInfo,
                                                                SpeechLibObj_ISpeechBaseStream *audioInputStream)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecognizer_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH audioInputStream__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (audioInputStream)
		*audioInputStream = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecognizer,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetAudioInputStream_ (__vtblIFacePtr,
	                                                          &audioInputStream__AutoType));
	

	if (audioInputStream)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (audioInputStream__AutoType,
		                                             &SpeechLib_IID_ISpeechBaseStream,
		                                             __supportMultithreading,
		                                             __locale, 0, 0,
		                                             audioInputStream));
		audioInputStream__AutoType = 0;
		}

Error:
	if (audioInputStream__AutoType)
		audioInputStream__AutoType->lpVtbl->Release (audioInputStream__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (audioInputStream)
			{
			CA_DiscardObjHandle (*audioInputStream);
			*audioInputStream = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecognizer,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecognizerGetIsShared (CAObjHandle objectHandle,
                                                        ERRORINFO *errorInfo,
                                                        VBOOL *shared)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecognizer_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	VBOOL shared__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecognizer,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetIsShared_ (__vtblIFacePtr,
	                                                  &shared__Temp));

	if (shared)
		{
		*shared = shared__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecognizer,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecognizerSetState (CAObjHandle objectHandle,
                                                     ERRORINFO *errorInfo,
                                                     enum SpeechLibEnum_SpeechRecognizerState state)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecognizer_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecognizer,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetState_ (__vtblIFacePtr, state));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecognizer,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecognizerGetState (CAObjHandle objectHandle,
                                                     ERRORINFO *errorInfo,
                                                     enum SpeechLibEnum_SpeechRecognizerState *state)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecognizer_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long state__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecognizer,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetState_ (__vtblIFacePtr,
	                                               (long *)&state__Temp));

	if (state)
		{
		*state = state__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecognizer,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecognizerGetStatus (CAObjHandle objectHandle,
                                                      ERRORINFO *errorInfo,
                                                      SpeechLibObj_ISpeechRecognizerStatus *status)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecognizer_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH status__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (status)
		*status = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecognizer,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetStatus_ (__vtblIFacePtr,
	                                                &status__AutoType));
	

	if (status)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (status__AutoType,
		                                             &SpeechLib_IID_ISpeechRecognizerStatus,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, status));
		status__AutoType = 0;
		}

Error:
	if (status__AutoType)
		status__AutoType->lpVtbl->Release (status__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (status)
			{
			CA_DiscardObjHandle (*status);
			*status = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecognizer,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecognizerSetByRefProfile (CAObjHandle objectHandle,
                                                            ERRORINFO *errorInfo,
                                                            SpeechLibObj_ISpeechObjectToken profile)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecognizer_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH profile__AutoType = 0;

	if (profile)
		{
		__caErrChk (CA_GetInterfaceFromObjHandle (profile,
	                                          &SpeechLib_IID_ISpeechObjectToken,
	                                          1, &profile__AutoType, NULL));
		}

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecognizer,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetByRefProfile_ (__vtblIFacePtr,
	                                                      profile__AutoType));

Error:
	if (profile__AutoType)
		profile__AutoType->lpVtbl->Release (profile__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecognizer,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecognizerGetProfile (CAObjHandle objectHandle,
                                                       ERRORINFO *errorInfo,
                                                       SpeechLibObj_ISpeechObjectToken *profile)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecognizer_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH profile__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (profile)
		*profile = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecognizer,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetProfile_ (__vtblIFacePtr,
	                                                 &profile__AutoType));
	

	if (profile)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (profile__AutoType,
		                                             &SpeechLib_IID_ISpeechObjectToken,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, profile));
		profile__AutoType = 0;
		}

Error:
	if (profile__AutoType)
		profile__AutoType->lpVtbl->Release (profile__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (profile)
			{
			CA_DiscardObjHandle (*profile);
			*profile = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecognizer,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecognizerEmulateRecognition (CAObjHandle objectHandle,
                                                               ERRORINFO *errorInfo,
                                                               VARIANT textElements,
                                                               VARIANT elementDisplayAttributes,
                                                               long languageId)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecognizer_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecognizer,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->EmulateRecognition_ (__vtblIFacePtr,
	                                                         textElements,
	                                                         &elementDisplayAttributes,
	                                                         languageId));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecognizer,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecognizerCreateRecoContext (CAObjHandle objectHandle,
                                                              ERRORINFO *errorInfo,
                                                              SpeechLibObj_ISpeechRecoContext *newContext)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecognizer_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH newContext__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (newContext)
		*newContext = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecognizer,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->CreateRecoContext_ (__vtblIFacePtr,
	                                                        &newContext__AutoType));
	

	if (newContext)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (newContext__AutoType,
		                                             &SpeechLib_IID_ISpeechRecoContext,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, newContext));
		newContext__AutoType = 0;
		}

Error:
	if (newContext__AutoType)
		newContext__AutoType->lpVtbl->Release (newContext__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (newContext)
			{
			CA_DiscardObjHandle (*newContext);
			*newContext = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecognizer,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecognizerGetFormat (CAObjHandle objectHandle,
                                                      ERRORINFO *errorInfo,
                                                      enum SpeechLibEnum_SpeechFormatType type,
                                                      SpeechLibObj_ISpeechAudioFormat *format)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecognizer_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH format__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (format)
		*format = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecognizer,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetFormat_ (__vtblIFacePtr, type,
	                                                &format__AutoType));
	

	if (format)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (format__AutoType,
		                                             &SpeechLib_IID_ISpeechAudioFormat,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, format));
		format__AutoType = 0;
		}

Error:
	if (format__AutoType)
		format__AutoType->lpVtbl->Release (format__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (format)
			{
			CA_DiscardObjHandle (*format);
			*format = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecognizer,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecognizerSetPropertyNumber (CAObjHandle objectHandle,
                                                              ERRORINFO *errorInfo,
                                                              const char *name,
                                                              long value,
                                                              VBOOL *supported)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecognizer_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR name__AutoType = 0;
	VBOOL supported__Temp;

	__caErrChk (CA_CStringToBSTR (name, &name__AutoType));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecognizer,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetPropertyNumber_ (__vtblIFacePtr,
	                                                        name__AutoType,
	                                                        value,
	                                                        &supported__Temp));

	if (supported)
		{
		*supported = supported__Temp;
		}

Error:
	CA_FreeBSTR (name__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecognizer,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecognizerGetPropertyNumber (CAObjHandle objectHandle,
                                                              ERRORINFO *errorInfo,
                                                              const char *name,
                                                              long *value,
                                                              VBOOL *supported)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecognizer_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR name__AutoType = 0;
	VBOOL supported__Temp;

	__caErrChk (CA_CStringToBSTR (name, &name__AutoType));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecognizer,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetPropertyNumber_ (__vtblIFacePtr,
	                                                        name__AutoType,
	                                                        value,
	                                                        &supported__Temp));

	if (supported)
		{
		*supported = supported__Temp;
		}

Error:
	CA_FreeBSTR (name__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecognizer,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecognizerSetPropertyString (CAObjHandle objectHandle,
                                                              ERRORINFO *errorInfo,
                                                              const char *name,
                                                              const char *value,
                                                              VBOOL *supported)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecognizer_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR name__AutoType = 0;
	BSTR value__AutoType = 0;
	VBOOL supported__Temp;

	__caErrChk (CA_CStringToBSTR (name, &name__AutoType));
	__caErrChk (CA_CStringToBSTR (value, &value__AutoType));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecognizer,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetPropertyString_ (__vtblIFacePtr,
	                                                        name__AutoType,
	                                                        value__AutoType,
	                                                        &supported__Temp));

	if (supported)
		{
		*supported = supported__Temp;
		}

Error:
	CA_FreeBSTR (name__AutoType);
	CA_FreeBSTR (value__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecognizer,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecognizerGetPropertyString (CAObjHandle objectHandle,
                                                              ERRORINFO *errorInfo,
                                                              const char *name,
                                                              char **value,
                                                              VBOOL *supported)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecognizer_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR name__AutoType = 0;
	BSTR value__AutoType = 0;
	VBOOL supported__Temp;

	__caErrChk (CA_CStringToBSTR (name, &name__AutoType));
	__caErrChk (CA_CStringToBSTR (*value, &value__AutoType));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecognizer,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetPropertyString_ (__vtblIFacePtr,
	                                                        name__AutoType,
	                                                        &value__AutoType,
	                                                        &supported__Temp));

	if (value)
		{
		CA_FreeMemory (*value);
		*value = 0;
		}
	if (value)
		__caErrChk (CA_BSTRGetCString (value__AutoType, value));
	if (supported)
		{
		*supported = supported__Temp;
		}

Error:
	CA_FreeBSTR (name__AutoType);
	CA_FreeBSTR (value__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (value)
			{
			CA_FreeMemory (*value);
			*value = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecognizer,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecognizerIsUISupported (CAObjHandle objectHandle,
                                                          ERRORINFO *errorInfo,
                                                          const char *typeOfUI,
                                                          VARIANT extraData,
                                                          VBOOL *supported)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecognizer_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR typeOfUI__AutoType = 0;
	VBOOL supported__Temp;

	__caErrChk (CA_CStringToBSTR (typeOfUI, &typeOfUI__AutoType));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecognizer,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->IsUISupported_ (__vtblIFacePtr,
	                                                    typeOfUI__AutoType,
	                                                    &extraData,
	                                                    &supported__Temp));

	if (supported)
		{
		*supported = supported__Temp;
		}

Error:
	CA_FreeBSTR (typeOfUI__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecognizer,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecognizerDisplayUI (CAObjHandle objectHandle,
                                                      ERRORINFO *errorInfo,
                                                      long hWndParent,
                                                      const char *title,
                                                      const char *typeOfUI,
                                                      VARIANT extraData)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecognizer_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR title__AutoType = 0;
	BSTR typeOfUI__AutoType = 0;

	__caErrChk (CA_CStringToBSTR (title, &title__AutoType));
	__caErrChk (CA_CStringToBSTR (typeOfUI, &typeOfUI__AutoType));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecognizer,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->DisplayUI_ (__vtblIFacePtr, hWndParent,
	                                                title__AutoType,
	                                                typeOfUI__AutoType,
	                                                &extraData));

Error:
	CA_FreeBSTR (title__AutoType);
	CA_FreeBSTR (typeOfUI__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecognizer,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecognizerGetRecognizers (CAObjHandle objectHandle,
                                                           ERRORINFO *errorInfo,
                                                           const char *requiredAttributes,
                                                           const char *optionalAttributes,
                                                           SpeechLibObj_ISpeechObjectTokens *objectTokens)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecognizer_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR requiredAttributes__AutoType = 0;
	BSTR optionalAttributes__AutoType = 0;
	LPDISPATCH objectTokens__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (objectTokens)
		*objectTokens = 0;

	__caErrChk (CA_CStringToBSTR (requiredAttributes,
	                              &requiredAttributes__AutoType));
	__caErrChk (CA_CStringToBSTR (optionalAttributes,
	                              &optionalAttributes__AutoType));
	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecognizer,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetRecognizers_ (__vtblIFacePtr,
	                                                     requiredAttributes__AutoType,
	                                                     optionalAttributes__AutoType,
	                                                     &objectTokens__AutoType));
	

	if (objectTokens)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (objectTokens__AutoType,
		                                             &SpeechLib_IID_ISpeechObjectTokens,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, objectTokens));
		objectTokens__AutoType = 0;
		}

Error:
	CA_FreeBSTR (requiredAttributes__AutoType);
	CA_FreeBSTR (optionalAttributes__AutoType);
	if (objectTokens__AutoType)
		objectTokens__AutoType->lpVtbl->Release (objectTokens__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (objectTokens)
			{
			CA_DiscardObjHandle (*objectTokens);
			*objectTokens = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecognizer,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecognizerGetAudioInputs (CAObjHandle objectHandle,
                                                           ERRORINFO *errorInfo,
                                                           const char *requiredAttributes,
                                                           const char *optionalAttributes,
                                                           SpeechLibObj_ISpeechObjectTokens *objectTokens)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecognizer_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR requiredAttributes__AutoType = 0;
	BSTR optionalAttributes__AutoType = 0;
	LPDISPATCH objectTokens__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (objectTokens)
		*objectTokens = 0;

	__caErrChk (CA_CStringToBSTR (requiredAttributes,
	                              &requiredAttributes__AutoType));
	__caErrChk (CA_CStringToBSTR (optionalAttributes,
	                              &optionalAttributes__AutoType));
	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecognizer,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetAudioInputs_ (__vtblIFacePtr,
	                                                     requiredAttributes__AutoType,
	                                                     optionalAttributes__AutoType,
	                                                     &objectTokens__AutoType));
	

	if (objectTokens)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (objectTokens__AutoType,
		                                             &SpeechLib_IID_ISpeechObjectTokens,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, objectTokens));
		objectTokens__AutoType = 0;
		}

Error:
	CA_FreeBSTR (requiredAttributes__AutoType);
	CA_FreeBSTR (optionalAttributes__AutoType);
	if (objectTokens__AutoType)
		objectTokens__AutoType->lpVtbl->Release (objectTokens__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (objectTokens)
			{
			CA_DiscardObjHandle (*objectTokens);
			*objectTokens = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecognizer,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecognizerGetProfiles (CAObjHandle objectHandle,
                                                        ERRORINFO *errorInfo,
                                                        const char *requiredAttributes,
                                                        const char *optionalAttributes,
                                                        SpeechLibObj_ISpeechObjectTokens *objectTokens)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecognizer_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR requiredAttributes__AutoType = 0;
	BSTR optionalAttributes__AutoType = 0;
	LPDISPATCH objectTokens__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (objectTokens)
		*objectTokens = 0;

	__caErrChk (CA_CStringToBSTR (requiredAttributes,
	                              &requiredAttributes__AutoType));
	__caErrChk (CA_CStringToBSTR (optionalAttributes,
	                              &optionalAttributes__AutoType));
	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecognizer,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetProfiles_ (__vtblIFacePtr,
	                                                  requiredAttributes__AutoType,
	                                                  optionalAttributes__AutoType,
	                                                  &objectTokens__AutoType));
	

	if (objectTokens)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (objectTokens__AutoType,
		                                             &SpeechLib_IID_ISpeechObjectTokens,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, objectTokens));
		objectTokens__AutoType = 0;
		}

Error:
	CA_FreeBSTR (requiredAttributes__AutoType);
	CA_FreeBSTR (optionalAttributes__AutoType);
	if (objectTokens__AutoType)
		objectTokens__AutoType->lpVtbl->Release (objectTokens__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (objectTokens)
			{
			CA_DiscardObjHandle (*objectTokens);
			*objectTokens = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecognizer,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_NewSpInprocRecognizerISpRecognizer (const char *server,
                                                              int supportMultithreading,
                                                              LCID locale,
                                                              int reserved,
                                                              CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x41B89B6B, 0x9399, 0x11D2, 0x96, 0x23, 0x0, 0xC0, 0x4F,
	              0x8E, 0xE6, 0x28};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpRecognizer,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenSpInprocRecognizerISpRecognizer (const char *fileName,
                                                               const char *server,
                                                               int supportMultithreading,
                                                               LCID locale,
                                                               int reserved,
                                                               CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x41B89B6B, 0x9399, 0x11D2, 0x96, 0x23, 0x0, 0xC0, 0x4F,
	              0x8E, 0xE6, 0x28};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpRecognizer,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveSpInprocRecognizerISpRecognizer (const char *server,
                                                                 int supportMultithreading,
                                                                 LCID locale,
                                                                 int reserved,
                                                                 CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x41B89B6B, 0x9399, 0x11D2, 0x96, 0x23, 0x0, 0xC0, 0x4F,
	              0x8E, 0xE6, 0x28};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpRecognizer,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_NewSpSharedRecognizerISpRecognizer (const char *server,
                                                              int supportMultithreading,
                                                              LCID locale,
                                                              int reserved,
                                                              CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x3BEE4890, 0x4FE9, 0x4A37, 0x8C, 0x1E, 0x5E, 0x7E, 0x12,
	              0x79, 0x1C, 0x1F};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpRecognizer,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenSpSharedRecognizerISpRecognizer (const char *fileName,
                                                               const char *server,
                                                               int supportMultithreading,
                                                               LCID locale,
                                                               int reserved,
                                                               CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x3BEE4890, 0x4FE9, 0x4A37, 0x8C, 0x1E, 0x5E, 0x7E, 0x12,
	              0x79, 0x1C, 0x1F};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpRecognizer,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveSpSharedRecognizerISpRecognizer (const char *server,
                                                                 int supportMultithreading,
                                                                 LCID locale,
                                                                 int reserved,
                                                                 CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x3BEE4890, 0x4FE9, 0x4A37, 0x8C, 0x1E, 0x5E, 0x7E, 0x12,
	              0x79, 0x1C, 0x1F};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpRecognizer,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpRecognizerSetRecognizer (CAObjHandle objectHandle,
                                                      ERRORINFO *errorInfo,
                                                      SpeechLibObj_ISpObjectToken pRecognizer)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpRecognizer_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN pRecognizer__AutoType = 0;

	if (pRecognizer)
		{
		__caErrChk (CA_GetInterfaceFromObjHandle (pRecognizer,
	                                          &SpeechLib_IID_ISpObjectToken, 1,
	                                          &pRecognizer__AutoType, NULL));
		}

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpRecognizer, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetRecognizer_ (__vtblIFacePtr,
	                                                    pRecognizer__AutoType));

Error:
	if (pRecognizer__AutoType)
		pRecognizer__AutoType->lpVtbl->Release (pRecognizer__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpRecognizer, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpRecognizerGetRecognizer (CAObjHandle objectHandle,
                                                      ERRORINFO *errorInfo,
                                                      SpeechLibObj_ISpObjectToken *ppRecognizer)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpRecognizer_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN ppRecognizer__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (ppRecognizer)
		*ppRecognizer = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpRecognizer, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetRecognizer_ (__vtblIFacePtr,
	                                                    &ppRecognizer__AutoType));
	

	if (ppRecognizer)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (ppRecognizer__AutoType,
		                                             &SpeechLib_IID_ISpObjectToken,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, ppRecognizer));
		ppRecognizer__AutoType = 0;
		}

Error:
	if (ppRecognizer__AutoType)
		ppRecognizer__AutoType->lpVtbl->Release (ppRecognizer__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (ppRecognizer)
			{
			CA_DiscardObjHandle (*ppRecognizer);
			*ppRecognizer = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpRecognizer, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpRecognizerSetInput (CAObjHandle objectHandle,
                                                 ERRORINFO *errorInfo,
                                                 CAObjHandle pUnkInput,
                                                 long fAllowFormatChanges)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpRecognizer_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN pUnkInput__AutoType = 0;

	if (pUnkInput)
		{
		__caErrChk (CA_GetInterfaceFromObjHandle (pUnkInput, &IID_IUnknown, 1,
	                                          &pUnkInput__AutoType, NULL));
		}

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpRecognizer, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetInput_ (__vtblIFacePtr,
	                                               pUnkInput__AutoType,
	                                               fAllowFormatChanges));

Error:
	if (pUnkInput__AutoType)
		pUnkInput__AutoType->lpVtbl->Release (pUnkInput__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpRecognizer, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpRecognizerGetInputObjectToken (CAObjHandle objectHandle,
                                                            ERRORINFO *errorInfo,
                                                            SpeechLibObj_ISpObjectToken *ppToken)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpRecognizer_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN ppToken__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (ppToken)
		*ppToken = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpRecognizer, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetInputObjectToken_ (__vtblIFacePtr,
	                                                          &ppToken__AutoType));
	

	if (ppToken)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (ppToken__AutoType,
		                                             &SpeechLib_IID_ISpObjectToken,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, ppToken));
		ppToken__AutoType = 0;
		}

Error:
	if (ppToken__AutoType)
		ppToken__AutoType->lpVtbl->Release (ppToken__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (ppToken)
			{
			CA_DiscardObjHandle (*ppToken);
			*ppToken = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpRecognizer, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpRecognizerGetInputStream (CAObjHandle objectHandle,
                                                       ERRORINFO *errorInfo,
                                                       SpeechLibObj_ISpStreamFormat *ppStream)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpRecognizer_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN ppStream__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (ppStream)
		*ppStream = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpRecognizer, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetInputStream_ (__vtblIFacePtr,
	                                                     &ppStream__AutoType));
	

	if (ppStream)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (ppStream__AutoType,
		                                             &SpeechLib_IID_ISpStreamFormat,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, ppStream));
		ppStream__AutoType = 0;
		}

Error:
	if (ppStream__AutoType)
		ppStream__AutoType->lpVtbl->Release (ppStream__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (ppStream)
			{
			CA_DiscardObjHandle (*ppStream);
			*ppStream = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpRecognizer, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpRecognizerCreateRecoContext (CAObjHandle objectHandle,
                                                          ERRORINFO *errorInfo,
                                                          SpeechLibObj_ISpRecoContext *ppNewCtxt)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpRecognizer_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN ppNewCtxt__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (ppNewCtxt)
		*ppNewCtxt = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpRecognizer, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->CreateRecoContext_ (__vtblIFacePtr,
	                                                        &ppNewCtxt__AutoType));
	

	if (ppNewCtxt)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (ppNewCtxt__AutoType,
		                                             &SpeechLib_IID_ISpRecoContext,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, ppNewCtxt));
		ppNewCtxt__AutoType = 0;
		}

Error:
	if (ppNewCtxt__AutoType)
		ppNewCtxt__AutoType->lpVtbl->Release (ppNewCtxt__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (ppNewCtxt)
			{
			CA_DiscardObjHandle (*ppNewCtxt);
			*ppNewCtxt = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpRecognizer, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpRecognizerGetRecoProfile (CAObjHandle objectHandle,
                                                       ERRORINFO *errorInfo,
                                                       SpeechLibObj_ISpObjectToken *ppToken)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpRecognizer_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN ppToken__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (ppToken)
		*ppToken = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpRecognizer, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetRecoProfile_ (__vtblIFacePtr,
	                                                     &ppToken__AutoType));
	

	if (ppToken)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (ppToken__AutoType,
		                                             &SpeechLib_IID_ISpObjectToken,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, ppToken));
		ppToken__AutoType = 0;
		}

Error:
	if (ppToken__AutoType)
		ppToken__AutoType->lpVtbl->Release (ppToken__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (ppToken)
			{
			CA_DiscardObjHandle (*ppToken);
			*ppToken = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpRecognizer, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpRecognizerSetRecoProfile (CAObjHandle objectHandle,
                                                       ERRORINFO *errorInfo,
                                                       SpeechLibObj_ISpObjectToken pToken)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpRecognizer_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN pToken__AutoType = 0;

	if (pToken)
		{
		__caErrChk (CA_GetInterfaceFromObjHandle (pToken,
	                                          &SpeechLib_IID_ISpObjectToken, 1,
	                                          &pToken__AutoType, NULL));
		}

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpRecognizer, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetRecoProfile_ (__vtblIFacePtr,
	                                                     pToken__AutoType));

Error:
	if (pToken__AutoType)
		pToken__AutoType->lpVtbl->Release (pToken__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpRecognizer, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpRecognizerIsSharedInstance (CAObjHandle objectHandle,
                                                         ERRORINFO *errorInfo)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpRecognizer_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpRecognizer, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->IsSharedInstance_ (__vtblIFacePtr));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpRecognizer, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpRecognizerGetRecoState (CAObjHandle objectHandle,
                                                     ERRORINFO *errorInfo,
                                                     enum SpeechLibEnum_SPRECOSTATE *pState)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpRecognizer_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long pState__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpRecognizer, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetRecoState_ (__vtblIFacePtr,
	                                                   (long *)&pState__Temp));

	if (pState)
		{
		*pState = pState__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpRecognizer, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpRecognizerSetRecoState (CAObjHandle objectHandle,
                                                     ERRORINFO *errorInfo,
                                                     enum SpeechLibEnum_SPRECOSTATE newState)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpRecognizer_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpRecognizer, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetRecoState_ (__vtblIFacePtr,
	                                                   newState));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpRecognizer, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpRecognizerEmulateRecognition (CAObjHandle objectHandle,
                                                           ERRORINFO *errorInfo,
                                                           SpeechLibObj_ISpPhrase pPhrase)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpRecognizer_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN pPhrase__AutoType = 0;

	if (pPhrase)
		{
		__caErrChk (CA_GetInterfaceFromObjHandle (pPhrase,
	                                          &SpeechLib_IID_ISpPhrase, 1,
	                                          &pPhrase__AutoType, NULL));
		}

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpRecognizer, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->EmulateRecognition_ (__vtblIFacePtr,
	                                                         pPhrase__AutoType));

Error:
	if (pPhrase__AutoType)
		pPhrase__AutoType->lpVtbl->Release (pPhrase__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpRecognizer, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_NewSpInprocRecognizerISpRecognizer2 (const char *server,
                                                               int supportMultithreading,
                                                               LCID locale,
                                                               int reserved,
                                                               CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x41B89B6B, 0x9399, 0x11D2, 0x96, 0x23, 0x0, 0xC0, 0x4F,
	              0x8E, 0xE6, 0x28};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpRecognizer2,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenSpInprocRecognizerISpRecognizer2 (const char *fileName,
                                                                const char *server,
                                                                int supportMultithreading,
                                                                LCID locale,
                                                                int reserved,
                                                                CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x41B89B6B, 0x9399, 0x11D2, 0x96, 0x23, 0x0, 0xC0, 0x4F,
	              0x8E, 0xE6, 0x28};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpRecognizer2,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveSpInprocRecognizerISpRecognizer2 (const char *server,
                                                                  int supportMultithreading,
                                                                  LCID locale,
                                                                  int reserved,
                                                                  CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x41B89B6B, 0x9399, 0x11D2, 0x96, 0x23, 0x0, 0xC0, 0x4F,
	              0x8E, 0xE6, 0x28};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpRecognizer2,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_NewSpSharedRecognizerISpRecognizer2 (const char *server,
                                                               int supportMultithreading,
                                                               LCID locale,
                                                               int reserved,
                                                               CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x3BEE4890, 0x4FE9, 0x4A37, 0x8C, 0x1E, 0x5E, 0x7E, 0x12,
	              0x79, 0x1C, 0x1F};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpRecognizer2,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenSpSharedRecognizerISpRecognizer2 (const char *fileName,
                                                                const char *server,
                                                                int supportMultithreading,
                                                                LCID locale,
                                                                int reserved,
                                                                CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x3BEE4890, 0x4FE9, 0x4A37, 0x8C, 0x1E, 0x5E, 0x7E, 0x12,
	              0x79, 0x1C, 0x1F};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpRecognizer2,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveSpSharedRecognizerISpRecognizer2 (const char *server,
                                                                  int supportMultithreading,
                                                                  LCID locale,
                                                                  int reserved,
                                                                  CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x3BEE4890, 0x4FE9, 0x4A37, 0x8C, 0x1E, 0x5E, 0x7E, 0x12,
	              0x79, 0x1C, 0x1F};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpRecognizer2,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpRecognizer2EmulateRecognitionEx (CAObjHandle objectHandle,
                                                              ERRORINFO *errorInfo,
                                                              SpeechLibObj_ISpPhrase pPhrase,
                                                              unsigned long dwCompareFlags)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpRecognizer2_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN pPhrase__AutoType = 0;

	if (pPhrase)
		{
		__caErrChk (CA_GetInterfaceFromObjHandle (pPhrase,
	                                          &SpeechLib_IID_ISpPhrase, 1,
	                                          &pPhrase__AutoType, NULL));
		}

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpRecognizer2, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->EmulateRecognitionEx_ (__vtblIFacePtr,
	                                                           pPhrase__AutoType,
	                                                           dwCompareFlags));

Error:
	if (pPhrase__AutoType)
		pPhrase__AutoType->lpVtbl->Release (pPhrase__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpRecognizer2, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpRecognizer2SetTrainingState (CAObjHandle objectHandle,
                                                          ERRORINFO *errorInfo,
                                                          long fDoingTraining,
                                                          long fAdaptFromTrainingData)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpRecognizer2_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpRecognizer2, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetTrainingState_ (__vtblIFacePtr,
	                                                       fDoingTraining,
	                                                       fAdaptFromTrainingData));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpRecognizer2, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpRecognizer2ResetAcousticModelAdaptation (CAObjHandle objectHandle,
                                                                      ERRORINFO *errorInfo)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpRecognizer2_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpRecognizer2, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->ResetAcousticModelAdaptation_ (__vtblIFacePtr));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpRecognizer2, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_NewSpInprocRecognizerISpRecognizer3 (const char *server,
                                                               int supportMultithreading,
                                                               LCID locale,
                                                               int reserved,
                                                               CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x41B89B6B, 0x9399, 0x11D2, 0x96, 0x23, 0x0, 0xC0, 0x4F,
	              0x8E, 0xE6, 0x28};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpRecognizer3,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenSpInprocRecognizerISpRecognizer3 (const char *fileName,
                                                                const char *server,
                                                                int supportMultithreading,
                                                                LCID locale,
                                                                int reserved,
                                                                CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x41B89B6B, 0x9399, 0x11D2, 0x96, 0x23, 0x0, 0xC0, 0x4F,
	              0x8E, 0xE6, 0x28};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpRecognizer3,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveSpInprocRecognizerISpRecognizer3 (const char *server,
                                                                  int supportMultithreading,
                                                                  LCID locale,
                                                                  int reserved,
                                                                  CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x41B89B6B, 0x9399, 0x11D2, 0x96, 0x23, 0x0, 0xC0, 0x4F,
	              0x8E, 0xE6, 0x28};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpRecognizer3,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_NewSpSharedRecognizerISpRecognizer3 (const char *server,
                                                               int supportMultithreading,
                                                               LCID locale,
                                                               int reserved,
                                                               CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x3BEE4890, 0x4FE9, 0x4A37, 0x8C, 0x1E, 0x5E, 0x7E, 0x12,
	              0x79, 0x1C, 0x1F};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpRecognizer3,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenSpSharedRecognizerISpRecognizer3 (const char *fileName,
                                                                const char *server,
                                                                int supportMultithreading,
                                                                LCID locale,
                                                                int reserved,
                                                                CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x3BEE4890, 0x4FE9, 0x4A37, 0x8C, 0x1E, 0x5E, 0x7E, 0x12,
	              0x79, 0x1C, 0x1F};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpRecognizer3,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveSpSharedRecognizerISpRecognizer3 (const char *server,
                                                                  int supportMultithreading,
                                                                  LCID locale,
                                                                  int reserved,
                                                                  CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x3BEE4890, 0x4FE9, 0x4A37, 0x8C, 0x1E, 0x5E, 0x7E, 0x12,
	              0x79, 0x1C, 0x1F};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpRecognizer3,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpRecognizer3GetCategory (CAObjHandle objectHandle,
                                                     ERRORINFO *errorInfo,
                                                     enum SpeechLibEnum_SPCATEGORYTYPE categoryType,
                                                     SpeechLibObj_ISpRecoCategory *ppCategory)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpRecognizer3_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN ppCategory__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (ppCategory)
		*ppCategory = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpRecognizer3, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetCategory_ (__vtblIFacePtr,
	                                                  categoryType,
	                                                  &ppCategory__AutoType));
	

	if (ppCategory)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (ppCategory__AutoType,
		                                             &SpeechLib_IID_ISpRecoCategory,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, ppCategory));
		ppCategory__AutoType = 0;
		}

Error:
	if (ppCategory__AutoType)
		ppCategory__AutoType->lpVtbl->Release (ppCategory__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (ppCategory)
			{
			CA_DiscardObjHandle (*ppCategory);
			*ppCategory = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpRecognizer3, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpRecognizer3SetActiveCategory (CAObjHandle objectHandle,
                                                           ERRORINFO *errorInfo,
                                                           SpeechLibObj_ISpRecoCategory pCategory)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpRecognizer3_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN pCategory__AutoType = 0;

	if (pCategory)
		{
		__caErrChk (CA_GetInterfaceFromObjHandle (pCategory,
	                                          &SpeechLib_IID_ISpRecoCategory,
	                                          1, &pCategory__AutoType, NULL));
		}

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpRecognizer3, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetActiveCategory_ (__vtblIFacePtr,
	                                                        pCategory__AutoType));

Error:
	if (pCategory__AutoType)
		pCategory__AutoType->lpVtbl->Release (pCategory__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpRecognizer3, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpRecognizer3GetActiveCategory (CAObjHandle objectHandle,
                                                           ERRORINFO *errorInfo,
                                                           SpeechLibObj_ISpRecoCategory *ppCategory)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpRecognizer3_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN ppCategory__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (ppCategory)
		*ppCategory = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpRecognizer3, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetActiveCategory_ (__vtblIFacePtr,
	                                                        &ppCategory__AutoType));
	

	if (ppCategory)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (ppCategory__AutoType,
		                                             &SpeechLib_IID_ISpRecoCategory,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, ppCategory));
		ppCategory__AutoType = 0;
		}

Error:
	if (ppCategory__AutoType)
		ppCategory__AutoType->lpVtbl->Release (ppCategory__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (ppCategory)
			{
			CA_DiscardObjHandle (*ppCategory);
			*ppCategory = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpRecognizer3, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_NewSpInprocRecognizerISpSerializeState (const char *server,
                                                                  int supportMultithreading,
                                                                  LCID locale,
                                                                  int reserved,
                                                                  CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x41B89B6B, 0x9399, 0x11D2, 0x96, 0x23, 0x0, 0xC0, 0x4F,
	              0x8E, 0xE6, 0x28};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpSerializeState,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenSpInprocRecognizerISpSerializeState (const char *fileName,
                                                                   const char *server,
                                                                   int supportMultithreading,
                                                                   LCID locale,
                                                                   int reserved,
                                                                   CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x41B89B6B, 0x9399, 0x11D2, 0x96, 0x23, 0x0, 0xC0, 0x4F,
	              0x8E, 0xE6, 0x28};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpSerializeState,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveSpInprocRecognizerISpSerializeState (const char *server,
                                                                     int supportMultithreading,
                                                                     LCID locale,
                                                                     int reserved,
                                                                     CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x41B89B6B, 0x9399, 0x11D2, 0x96, 0x23, 0x0, 0xC0, 0x4F,
	              0x8E, 0xE6, 0x28};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpSerializeState,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_NewSpSharedRecognizerISpSerializeState (const char *server,
                                                                  int supportMultithreading,
                                                                  LCID locale,
                                                                  int reserved,
                                                                  CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x3BEE4890, 0x4FE9, 0x4A37, 0x8C, 0x1E, 0x5E, 0x7E, 0x12,
	              0x79, 0x1C, 0x1F};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpSerializeState,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenSpSharedRecognizerISpSerializeState (const char *fileName,
                                                                   const char *server,
                                                                   int supportMultithreading,
                                                                   LCID locale,
                                                                   int reserved,
                                                                   CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x3BEE4890, 0x4FE9, 0x4A37, 0x8C, 0x1E, 0x5E, 0x7E, 0x12,
	              0x79, 0x1C, 0x1F};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpSerializeState,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveSpSharedRecognizerISpSerializeState (const char *server,
                                                                     int supportMultithreading,
                                                                     LCID locale,
                                                                     int reserved,
                                                                     CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x3BEE4890, 0x4FE9, 0x4A37, 0x8C, 0x1E, 0x5E, 0x7E, 0x12,
	              0x79, 0x1C, 0x1F};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpSerializeState,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpSerializeStateSetSerializedState (CAObjHandle objectHandle,
                                                               ERRORINFO *errorInfo,
                                                               unsigned char *pbData,
                                                               unsigned long ulSize,
                                                               unsigned long dwReserved)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpSerializeState_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpSerializeState,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetSerializedState_ (__vtblIFacePtr,
	                                                         pbData, ulSize,
	                                                         dwReserved));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpSerializeState,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_NewSpLexiconISpeechLexicon (const char *server,
                                                      int supportMultithreading,
                                                      LCID locale, int reserved,
                                                      CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x655E396, 0x25D0, 0x11D3, 0x9C, 0x26, 0x0, 0xC0, 0x4F, 0x8E,
	              0xF8, 0x7C};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpeechLexicon,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenSpLexiconISpeechLexicon (const char *fileName,
                                                       const char *server,
                                                       int supportMultithreading,
                                                       LCID locale, int reserved,
                                                       CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x655E396, 0x25D0, 0x11D3, 0x9C, 0x26, 0x0, 0xC0, 0x4F, 0x8E,
	              0xF8, 0x7C};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpeechLexicon,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveSpLexiconISpeechLexicon (const char *server,
                                                         int supportMultithreading,
                                                         LCID locale,
                                                         int reserved,
                                                         CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x655E396, 0x25D0, 0x11D3, 0x9C, 0x26, 0x0, 0xC0, 0x4F, 0x8E,
	              0xF8, 0x7C};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpeechLexicon,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_NewSpUnCompressedLexiconISpeechLexicon (const char *server,
                                                                  int supportMultithreading,
                                                                  LCID locale,
                                                                  int reserved,
                                                                  CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xC9E37C15, 0xDF92, 0x4727, 0x85, 0xD6, 0x72, 0xE5, 0xEE,
	              0xB6, 0x99, 0x5A};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpeechLexicon,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenSpUnCompressedLexiconISpeechLexicon (const char *fileName,
                                                                   const char *server,
                                                                   int supportMultithreading,
                                                                   LCID locale,
                                                                   int reserved,
                                                                   CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xC9E37C15, 0xDF92, 0x4727, 0x85, 0xD6, 0x72, 0xE5, 0xEE,
	              0xB6, 0x99, 0x5A};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpeechLexicon,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveSpUnCompressedLexiconISpeechLexicon (const char *server,
                                                                     int supportMultithreading,
                                                                     LCID locale,
                                                                     int reserved,
                                                                     CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xC9E37C15, 0xDF92, 0x4727, 0x85, 0xD6, 0x72, 0xE5, 0xEE,
	              0xB6, 0x99, 0x5A};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpeechLexicon,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechLexiconGetGenerationId (CAObjHandle objectHandle,
                                                         ERRORINFO *errorInfo,
                                                         long *generationId)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechLexicon_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long generationId__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechLexicon, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetGenerationId_ (__vtblIFacePtr,
	                                                      &generationId__Temp));

	if (generationId)
		{
		*generationId = generationId__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechLexicon, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechLexiconGetWords (CAObjHandle objectHandle,
                                                  ERRORINFO *errorInfo,
                                                  enum SpeechLibEnum_SpeechLexiconType flags,
                                                  long *generationId,
                                                  SpeechLibObj_ISpeechLexiconWords *words)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechLexicon_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long generationId__Temp;
	LPDISPATCH words__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (words)
		*words = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechLexicon, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetWords_ (__vtblIFacePtr, flags,
	                                               &generationId__Temp,
	                                               &words__AutoType));

	if (generationId)
		{
		*generationId = generationId__Temp;
		}

	if (words)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (words__AutoType,
		                                             &SpeechLib_IID_ISpeechLexiconWords,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, words));
		words__AutoType = 0;
		}

Error:
	if (words__AutoType)
		words__AutoType->lpVtbl->Release (words__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (words)
			{
			CA_DiscardObjHandle (*words);
			*words = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechLexicon, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechLexiconAddPronunciation (CAObjHandle objectHandle,
                                                          ERRORINFO *errorInfo,
                                                          const char *bstrWord,
                                                          long langId,
                                                          enum SpeechLibEnum_SpeechPartOfSpeech partOfSpeech,
                                                          const char *bstrPronunciation)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechLexicon_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR bstrWord__AutoType = 0;
	BSTR bstrPronunciation__AutoType = 0;

	__caErrChk (CA_CStringToBSTR (bstrWord, &bstrWord__AutoType));
	__caErrChk (CA_CStringToBSTR (bstrPronunciation,
	                              &bstrPronunciation__AutoType));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechLexicon, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->AddPronunciation_ (__vtblIFacePtr,
	                                                       bstrWord__AutoType,
	                                                       langId,
	                                                       partOfSpeech,
	                                                       bstrPronunciation__AutoType));

Error:
	CA_FreeBSTR (bstrWord__AutoType);
	CA_FreeBSTR (bstrPronunciation__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechLexicon, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechLexiconAddPronunciationByPhoneIds (CAObjHandle objectHandle,
                                                                    ERRORINFO *errorInfo,
                                                                    const char *bstrWord,
                                                                    long langId,
                                                                    enum SpeechLibEnum_SpeechPartOfSpeech partOfSpeech,
                                                                    VARIANT phoneIds)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechLexicon_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR bstrWord__AutoType = 0;

	__caErrChk (CA_CStringToBSTR (bstrWord, &bstrWord__AutoType));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechLexicon, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->AddPronunciationByPhoneIds_ (__vtblIFacePtr,
	                                                                 bstrWord__AutoType,
	                                                                 langId,
	                                                                 partOfSpeech,
	                                                                 &phoneIds));

Error:
	CA_FreeBSTR (bstrWord__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechLexicon, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechLexiconRemovePronunciation (CAObjHandle objectHandle,
                                                             ERRORINFO *errorInfo,
                                                             const char *bstrWord,
                                                             long langId,
                                                             enum SpeechLibEnum_SpeechPartOfSpeech partOfSpeech,
                                                             const char *bstrPronunciation)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechLexicon_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR bstrWord__AutoType = 0;
	BSTR bstrPronunciation__AutoType = 0;

	__caErrChk (CA_CStringToBSTR (bstrWord, &bstrWord__AutoType));
	__caErrChk (CA_CStringToBSTR (bstrPronunciation,
	                              &bstrPronunciation__AutoType));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechLexicon, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->RemovePronunciation_ (__vtblIFacePtr,
	                                                          bstrWord__AutoType,
	                                                          langId,
	                                                          partOfSpeech,
	                                                          bstrPronunciation__AutoType));

Error:
	CA_FreeBSTR (bstrWord__AutoType);
	CA_FreeBSTR (bstrPronunciation__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechLexicon, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechLexiconRemovePronunciationByPhoneIds (CAObjHandle objectHandle,
                                                                       ERRORINFO *errorInfo,
                                                                       const char *bstrWord,
                                                                       long langId,
                                                                       enum SpeechLibEnum_SpeechPartOfSpeech partOfSpeech,
                                                                       VARIANT phoneIds)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechLexicon_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR bstrWord__AutoType = 0;

	__caErrChk (CA_CStringToBSTR (bstrWord, &bstrWord__AutoType));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechLexicon, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->RemovePronunciationByPhoneIds_ (__vtblIFacePtr,
	                                                                    bstrWord__AutoType,
	                                                                    langId,
	                                                                    partOfSpeech,
	                                                                    &phoneIds));

Error:
	CA_FreeBSTR (bstrWord__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechLexicon, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechLexiconGetPronunciations (CAObjHandle objectHandle,
                                                           ERRORINFO *errorInfo,
                                                           const char *bstrWord,
                                                           long langId,
                                                           enum SpeechLibEnum_SpeechLexiconType typeFlags,
                                                           SpeechLibObj_ISpeechLexiconPronunciations *ppPronunciations)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechLexicon_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR bstrWord__AutoType = 0;
	LPDISPATCH ppPronunciations__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (ppPronunciations)
		*ppPronunciations = 0;

	__caErrChk (CA_CStringToBSTR (bstrWord, &bstrWord__AutoType));
	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechLexicon, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetPronunciations_ (__vtblIFacePtr,
	                                                        bstrWord__AutoType,
	                                                        langId, typeFlags,
	                                                        &ppPronunciations__AutoType));
	

	if (ppPronunciations)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (ppPronunciations__AutoType,
		                                             &SpeechLib_IID_ISpeechLexiconPronunciations,
		                                             __supportMultithreading,
		                                             __locale, 0, 0,
		                                             ppPronunciations));
		ppPronunciations__AutoType = 0;
		}

Error:
	CA_FreeBSTR (bstrWord__AutoType);
	if (ppPronunciations__AutoType)
		ppPronunciations__AutoType->lpVtbl->Release (ppPronunciations__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (ppPronunciations)
			{
			CA_DiscardObjHandle (*ppPronunciations);
			*ppPronunciations = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechLexicon, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechLexiconGetGenerationChange (CAObjHandle objectHandle,
                                                             ERRORINFO *errorInfo,
                                                             long *generationId,
                                                             SpeechLibObj_ISpeechLexiconWords *ppWords)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechLexicon_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH ppWords__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (ppWords)
		*ppWords = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechLexicon, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetGenerationChange_ (__vtblIFacePtr,
	                                                          generationId,
	                                                          &ppWords__AutoType));
	

	if (ppWords)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (ppWords__AutoType,
		                                             &SpeechLib_IID_ISpeechLexiconWords,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, ppWords));
		ppWords__AutoType = 0;
		}

Error:
	if (ppWords__AutoType)
		ppWords__AutoType->lpVtbl->Release (ppWords__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (ppWords)
			{
			CA_DiscardObjHandle (*ppWords);
			*ppWords = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechLexicon, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_NewSpLexiconISpLexicon (const char *server,
                                                  int supportMultithreading,
                                                  LCID locale, int reserved,
                                                  CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x655E396, 0x25D0, 0x11D3, 0x9C, 0x26, 0x0, 0xC0, 0x4F, 0x8E,
	              0xF8, 0x7C};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpLexicon,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenSpLexiconISpLexicon (const char *fileName,
                                                   const char *server,
                                                   int supportMultithreading,
                                                   LCID locale, int reserved,
                                                   CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x655E396, 0x25D0, 0x11D3, 0x9C, 0x26, 0x0, 0xC0, 0x4F, 0x8E,
	              0xF8, 0x7C};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpLexicon,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveSpLexiconISpLexicon (const char *server,
                                                     int supportMultithreading,
                                                     LCID locale, int reserved,
                                                     CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x655E396, 0x25D0, 0x11D3, 0x9C, 0x26, 0x0, 0xC0, 0x4F, 0x8E,
	              0xF8, 0x7C};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpLexicon,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_NewSpUnCompressedLexiconISpLexicon (const char *server,
                                                              int supportMultithreading,
                                                              LCID locale,
                                                              int reserved,
                                                              CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xC9E37C15, 0xDF92, 0x4727, 0x85, 0xD6, 0x72, 0xE5, 0xEE,
	              0xB6, 0x99, 0x5A};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpLexicon,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenSpUnCompressedLexiconISpLexicon (const char *fileName,
                                                               const char *server,
                                                               int supportMultithreading,
                                                               LCID locale,
                                                               int reserved,
                                                               CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xC9E37C15, 0xDF92, 0x4727, 0x85, 0xD6, 0x72, 0xE5, 0xEE,
	              0xB6, 0x99, 0x5A};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpLexicon,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveSpUnCompressedLexiconISpLexicon (const char *server,
                                                                 int supportMultithreading,
                                                                 LCID locale,
                                                                 int reserved,
                                                                 CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xC9E37C15, 0xDF92, 0x4727, 0x85, 0xD6, 0x72, 0xE5, 0xEE,
	              0xB6, 0x99, 0x5A};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpLexicon,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_NewSpCompressedLexiconISpLexicon (const char *server,
                                                            int supportMultithreading,
                                                            LCID locale,
                                                            int reserved,
                                                            CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x90903716, 0x2F42, 0x11D3, 0x9C, 0x26, 0x0, 0xC0, 0x4F,
	              0x8E, 0xF8, 0x7C};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpLexicon,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenSpCompressedLexiconISpLexicon (const char *fileName,
                                                             const char *server,
                                                             int supportMultithreading,
                                                             LCID locale,
                                                             int reserved,
                                                             CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x90903716, 0x2F42, 0x11D3, 0x9C, 0x26, 0x0, 0xC0, 0x4F,
	              0x8E, 0xF8, 0x7C};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpLexicon,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveSpCompressedLexiconISpLexicon (const char *server,
                                                               int supportMultithreading,
                                                               LCID locale,
                                                               int reserved,
                                                               CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x90903716, 0x2F42, 0x11D3, 0x9C, 0x26, 0x0, 0xC0, 0x4F,
	              0x8E, 0xF8, 0x7C};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpLexicon,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpLexiconGetGeneration (CAObjHandle objectHandle,
                                                   ERRORINFO *errorInfo,
                                                   unsigned long *pdwGeneration)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpLexicon_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	unsigned long pdwGeneration__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpLexicon, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetGeneration_ (__vtblIFacePtr,
	                                                    &pdwGeneration__Temp));

	if (pdwGeneration)
		{
		*pdwGeneration = pdwGeneration__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpLexicon, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_NewISpShortcut (const char *server,
                                          int supportMultithreading, LCID locale,
                                          int reserved,
                                          CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xD722F1A, 0x9FCF, 0x4E62, 0x96, 0xD8, 0x6D, 0xF8, 0xF0,
	              0x1A, 0x26, 0xAA};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpShortcut,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenISpShortcut (const char *fileName,
                                           const char *server,
                                           int supportMultithreading,
                                           LCID locale, int reserved,
                                           CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xD722F1A, 0x9FCF, 0x4E62, 0x96, 0xD8, 0x6D, 0xF8, 0xF0,
	              0x1A, 0x26, 0xAA};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpShortcut,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveISpShortcut (const char *server,
                                             int supportMultithreading,
                                             LCID locale, int reserved,
                                             CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xD722F1A, 0x9FCF, 0x4E62, 0x96, 0xD8, 0x6D, 0xF8, 0xF0,
	              0x1A, 0x26, 0xAA};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpShortcut,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpShortcutGetGeneration (CAObjHandle objectHandle,
                                                    ERRORINFO *errorInfo,
                                                    unsigned long *pdwGeneration)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpShortcut_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	unsigned long pdwGeneration__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpShortcut, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetGeneration_ (__vtblIFacePtr,
	                                                    &pdwGeneration__Temp));

	if (pdwGeneration)
		{
		*pdwGeneration = pdwGeneration__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpShortcut, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_NewISpeechPhoneConverter (const char *server,
                                                    int supportMultithreading,
                                                    LCID locale, int reserved,
                                                    CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x9185F743, 0x1143, 0x4C28, 0x86, 0xB5, 0xBF, 0xF1, 0x4F,
	              0x20, 0xE5, 0xC8};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpeechPhoneConverter,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenISpeechPhoneConverter (const char *fileName,
                                                     const char *server,
                                                     int supportMultithreading,
                                                     LCID locale, int reserved,
                                                     CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x9185F743, 0x1143, 0x4C28, 0x86, 0xB5, 0xBF, 0xF1, 0x4F,
	              0x20, 0xE5, 0xC8};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpeechPhoneConverter,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveISpeechPhoneConverter (const char *server,
                                                       int supportMultithreading,
                                                       LCID locale, int reserved,
                                                       CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x9185F743, 0x1143, 0x4C28, 0x86, 0xB5, 0xBF, 0xF1, 0x4F,
	              0x20, 0xE5, 0xC8};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpeechPhoneConverter,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhoneConverterGetLanguageId (CAObjHandle objectHandle,
                                                              ERRORINFO *errorInfo,
                                                              long *languageId)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhoneConverter_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long languageId__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhoneConverter,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetLanguageId_ (__vtblIFacePtr,
	                                                    &languageId__Temp));

	if (languageId)
		{
		*languageId = languageId__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhoneConverter,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhoneConverterSetLanguageId (CAObjHandle objectHandle,
                                                              ERRORINFO *errorInfo,
                                                              long languageId)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhoneConverter_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhoneConverter,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetLanguageId_ (__vtblIFacePtr,
	                                                    languageId));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhoneConverter,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhoneConverterPhoneToId (CAObjHandle objectHandle,
                                                          ERRORINFO *errorInfo,
                                                          const char *phonemes,
                                                          VARIANT *idArray)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhoneConverter_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR phonemes__AutoType = 0;
	VARIANT idArray__Temp;

	if (idArray)
		CA_VariantSetEmpty (idArray);
	CA_VariantSetEmpty (&idArray__Temp);

	__caErrChk (CA_CStringToBSTR (phonemes, &phonemes__AutoType));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhoneConverter,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->PhoneToId_ (__vtblIFacePtr,
	                                                phonemes__AutoType,
	                                                &idArray__Temp));

	if (idArray)
		{
		*idArray = idArray__Temp;
		CA_VariantSetEmpty (&idArray__Temp);
		}

Error:
	CA_FreeBSTR (phonemes__AutoType);
	CA_VariantClear (&idArray__Temp);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (idArray)
			CA_VariantClear (idArray);
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhoneConverter,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhoneConverterIdToPhone (CAObjHandle objectHandle,
                                                          ERRORINFO *errorInfo,
                                                          VARIANT idArray,
                                                          char **phonemes)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhoneConverter_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR phonemes__AutoType = 0;

	if (phonemes)
		*phonemes = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhoneConverter,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->IdToPhone_ (__vtblIFacePtr, idArray,
	                                                &phonemes__AutoType));

	if (phonemes)
		__caErrChk (CA_BSTRGetCString (phonemes__AutoType, phonemes));

Error:
	CA_FreeBSTR (phonemes__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (phonemes)
			{
			CA_FreeMemory (*phonemes);
			*phonemes = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhoneConverter,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_NewSpPhoneConverterISpPhoneConverter (const char *server,
                                                                int supportMultithreading,
                                                                LCID locale,
                                                                int reserved,
                                                                CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x9185F743, 0x1143, 0x4C28, 0x86, 0xB5, 0xBF, 0xF1, 0x4F,
	              0x20, 0xE5, 0xC8};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpPhoneConverter,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenSpPhoneConverterISpPhoneConverter (const char *fileName,
                                                                 const char *server,
                                                                 int supportMultithreading,
                                                                 LCID locale,
                                                                 int reserved,
                                                                 CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x9185F743, 0x1143, 0x4C28, 0x86, 0xB5, 0xBF, 0xF1, 0x4F,
	              0x20, 0xE5, 0xC8};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpPhoneConverter,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveSpPhoneConverterISpPhoneConverter (const char *server,
                                                                   int supportMultithreading,
                                                                   LCID locale,
                                                                   int reserved,
                                                                   CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x9185F743, 0x1143, 0x4C28, 0x86, 0xB5, 0xBF, 0xF1, 0x4F,
	              0x20, 0xE5, 0xC8};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpPhoneConverter,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_NewSpNullPhoneConverterISpPhoneConverter (const char *server,
                                                                    int supportMultithreading,
                                                                    LCID locale,
                                                                    int reserved,
                                                                    CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x455F24E9, 0x7396, 0x4A16, 0x97, 0x15, 0x7C, 0xF, 0xDB,
	              0xE3, 0xEF, 0xE3};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpPhoneConverter,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenSpNullPhoneConverterISpPhoneConverter (const char *fileName,
                                                                     const char *server,
                                                                     int supportMultithreading,
                                                                     LCID locale,
                                                                     int reserved,
                                                                     CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x455F24E9, 0x7396, 0x4A16, 0x97, 0x15, 0x7C, 0xF, 0xDB,
	              0xE3, 0xEF, 0xE3};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpPhoneConverter,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveSpNullPhoneConverterISpPhoneConverter (const char *server,
                                                                       int supportMultithreading,
                                                                       LCID locale,
                                                                       int reserved,
                                                                       CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x455F24E9, 0x7396, 0x4A16, 0x97, 0x15, 0x7C, 0xF, 0xDB,
	              0xE3, 0xEF, 0xE3};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpPhoneConverter,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpPhoneConverterSetObjectToken (CAObjHandle objectHandle,
                                                           ERRORINFO *errorInfo,
                                                           SpeechLibObj_ISpObjectToken pToken)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpPhoneConverter_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN pToken__AutoType = 0;

	if (pToken)
		{
		__caErrChk (CA_GetInterfaceFromObjHandle (pToken,
	                                          &SpeechLib_IID_ISpObjectToken, 1,
	                                          &pToken__AutoType, NULL));
		}

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpPhoneConverter,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetObjectToken_ (__vtblIFacePtr,
	                                                     pToken__AutoType));

Error:
	if (pToken__AutoType)
		pToken__AutoType->lpVtbl->Release (pToken__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpPhoneConverter,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpPhoneConverterGetObjectToken (CAObjHandle objectHandle,
                                                           ERRORINFO *errorInfo,
                                                           SpeechLibObj_ISpObjectToken *ppToken)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpPhoneConverter_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN ppToken__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (ppToken)
		*ppToken = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpPhoneConverter,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetObjectToken_ (__vtblIFacePtr,
	                                                     &ppToken__AutoType));
	

	if (ppToken)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (ppToken__AutoType,
		                                             &SpeechLib_IID_ISpObjectToken,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, ppToken));
		ppToken__AutoType = 0;
		}

Error:
	if (ppToken__AutoType)
		ppToken__AutoType->lpVtbl->Release (ppToken__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (ppToken)
			{
			CA_DiscardObjHandle (*ppToken);
			*ppToken = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpPhoneConverter,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_NewISpPhoneticAlphabetConverter (const char *server,
                                                           int supportMultithreading,
                                                           LCID locale,
                                                           int reserved,
                                                           CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x4F414126, 0xDFE3, 0x4629, 0x99, 0xEE, 0x79, 0x79, 0x78,
	              0x31, 0x7E, 0xAD};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpPhoneticAlphabetConverter,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenISpPhoneticAlphabetConverter (const char *fileName,
                                                            const char *server,
                                                            int supportMultithreading,
                                                            LCID locale,
                                                            int reserved,
                                                            CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x4F414126, 0xDFE3, 0x4629, 0x99, 0xEE, 0x79, 0x79, 0x78,
	              0x31, 0x7E, 0xAD};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpPhoneticAlphabetConverter,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveISpPhoneticAlphabetConverter (const char *server,
                                                              int supportMultithreading,
                                                              LCID locale,
                                                              int reserved,
                                                              CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x4F414126, 0xDFE3, 0x4629, 0x99, 0xEE, 0x79, 0x79, 0x78,
	              0x31, 0x7E, 0xAD};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpPhoneticAlphabetConverter,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpPhoneticAlphabetConverterGetLangId (CAObjHandle objectHandle,
                                                                 ERRORINFO *errorInfo,
                                                                 unsigned short *pLangID)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpPhoneticAlphabetConverter_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	unsigned short pLangID__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpPhoneticAlphabetConverter,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetLangId_ (__vtblIFacePtr,
	                                                &pLangID__Temp));

	if (pLangID)
		{
		*pLangID = pLangID__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle,
	                    &SpeechLib_IID_ISpPhoneticAlphabetConverter, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpPhoneticAlphabetConverterSetLangId (CAObjHandle objectHandle,
                                                                 ERRORINFO *errorInfo,
                                                                 unsigned short langId)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpPhoneticAlphabetConverter_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpPhoneticAlphabetConverter,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetLangId_ (__vtblIFacePtr, langId));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle,
	                    &SpeechLib_IID_ISpPhoneticAlphabetConverter, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpPhoneticAlphabetConverterSAPI2UPS (CAObjHandle objectHandle,
                                                                ERRORINFO *errorInfo,
                                                                unsigned short *pszSAPIId,
                                                                unsigned short *pszUPSId,
                                                                unsigned long cMaxLength)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpPhoneticAlphabetConverter_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	unsigned short pszUPSId__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpPhoneticAlphabetConverter,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SAPI2UPS_ (__vtblIFacePtr, pszSAPIId,
	                                               &pszUPSId__Temp, cMaxLength));

	if (pszUPSId)
		{
		*pszUPSId = pszUPSId__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle,
	                    &SpeechLib_IID_ISpPhoneticAlphabetConverter, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpPhoneticAlphabetConverterUPS2SAPI (CAObjHandle objectHandle,
                                                                ERRORINFO *errorInfo,
                                                                unsigned short *pszUPSId,
                                                                unsigned short *pszSAPIId,
                                                                unsigned long cMaxLength)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpPhoneticAlphabetConverter_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	unsigned short pszSAPIId__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpPhoneticAlphabetConverter,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->UPS2SAPI_ (__vtblIFacePtr, pszUPSId,
	                                               &pszSAPIId__Temp,
	                                               cMaxLength));

	if (pszSAPIId)
		{
		*pszSAPIId = pszSAPIId__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle,
	                    &SpeechLib_IID_ISpPhoneticAlphabetConverter, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpPhoneticAlphabetConverterGetMaxConvertLength (CAObjHandle objectHandle,
                                                                           ERRORINFO *errorInfo,
                                                                           unsigned long cSrcLength,
                                                                           long bSAPI2UPS,
                                                                           unsigned long *pcMaxDestLength)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpPhoneticAlphabetConverter_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	unsigned long pcMaxDestLength__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpPhoneticAlphabetConverter,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetMaxConvertLength_ (__vtblIFacePtr,
	                                                          cSrcLength,
	                                                          bSAPI2UPS,
	                                                          &pcMaxDestLength__Temp));

	if (pcMaxDestLength)
		{
		*pcMaxDestLength = pcMaxDestLength__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle,
	                    &SpeechLib_IID_ISpPhoneticAlphabetConverter, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_NewISpeechTextSelectionInformation (const char *server,
                                                              int supportMultithreading,
                                                              LCID locale,
                                                              int reserved,
                                                              CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xF92030A, 0xCBFD, 0x4AB8, 0xA1, 0x64, 0xFF, 0x59, 0x85,
	              0x54, 0x7F, 0xF6};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpeechTextSelectionInformation,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenISpeechTextSelectionInformation (const char *fileName,
                                                               const char *server,
                                                               int supportMultithreading,
                                                               LCID locale,
                                                               int reserved,
                                                               CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xF92030A, 0xCBFD, 0x4AB8, 0xA1, 0x64, 0xFF, 0x59, 0x85,
	              0x54, 0x7F, 0xF6};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpeechTextSelectionInformation,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveISpeechTextSelectionInformation (const char *server,
                                                                 int supportMultithreading,
                                                                 LCID locale,
                                                                 int reserved,
                                                                 CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xF92030A, 0xCBFD, 0x4AB8, 0xA1, 0x64, 0xFF, 0x59, 0x85,
	              0x54, 0x7F, 0xF6};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpeechTextSelectionInformation,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechTextSelectionInformationSetActiveOffset (CAObjHandle objectHandle,
                                                                          ERRORINFO *errorInfo,
                                                                          long activeOffset)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechTextSelectionInformation_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechTextSelectionInformation,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetActiveOffset_ (__vtblIFacePtr,
	                                                      activeOffset));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle,
	                    &SpeechLib_IID_ISpeechTextSelectionInformation,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechTextSelectionInformationGetActiveOffset (CAObjHandle objectHandle,
                                                                          ERRORINFO *errorInfo,
                                                                          long *activeOffset)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechTextSelectionInformation_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long activeOffset__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechTextSelectionInformation,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetActiveOffset_ (__vtblIFacePtr,
	                                                      &activeOffset__Temp));

	if (activeOffset)
		{
		*activeOffset = activeOffset__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle,
	                    &SpeechLib_IID_ISpeechTextSelectionInformation,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechTextSelectionInformationSetActiveLength (CAObjHandle objectHandle,
                                                                          ERRORINFO *errorInfo,
                                                                          long activeLength)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechTextSelectionInformation_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechTextSelectionInformation,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetActiveLength_ (__vtblIFacePtr,
	                                                      activeLength));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle,
	                    &SpeechLib_IID_ISpeechTextSelectionInformation,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechTextSelectionInformationGetActiveLength (CAObjHandle objectHandle,
                                                                          ERRORINFO *errorInfo,
                                                                          long *activeLength)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechTextSelectionInformation_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long activeLength__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechTextSelectionInformation,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetActiveLength_ (__vtblIFacePtr,
	                                                      &activeLength__Temp));

	if (activeLength)
		{
		*activeLength = activeLength__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle,
	                    &SpeechLib_IID_ISpeechTextSelectionInformation,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechTextSelectionInformationSetSelectionOffset (CAObjHandle objectHandle,
                                                                             ERRORINFO *errorInfo,
                                                                             long selectionOffset)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechTextSelectionInformation_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechTextSelectionInformation,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetSelectionOffset_ (__vtblIFacePtr,
	                                                         selectionOffset));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle,
	                    &SpeechLib_IID_ISpeechTextSelectionInformation,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechTextSelectionInformationGetSelectionOffset (CAObjHandle objectHandle,
                                                                             ERRORINFO *errorInfo,
                                                                             long *selectionOffset)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechTextSelectionInformation_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long selectionOffset__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechTextSelectionInformation,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetSelectionOffset_ (__vtblIFacePtr,
	                                                         &selectionOffset__Temp));

	if (selectionOffset)
		{
		*selectionOffset = selectionOffset__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle,
	                    &SpeechLib_IID_ISpeechTextSelectionInformation,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechTextSelectionInformationSetSelectionLength (CAObjHandle objectHandle,
                                                                             ERRORINFO *errorInfo,
                                                                             long selectionLength)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechTextSelectionInformation_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechTextSelectionInformation,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetSelectionLength_ (__vtblIFacePtr,
	                                                         selectionLength));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle,
	                    &SpeechLib_IID_ISpeechTextSelectionInformation,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechTextSelectionInformationGetSelectionLength (CAObjHandle objectHandle,
                                                                             ERRORINFO *errorInfo,
                                                                             long *selectionLength)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechTextSelectionInformation_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long selectionLength__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechTextSelectionInformation,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetSelectionLength_ (__vtblIFacePtr,
	                                                         &selectionLength__Temp));

	if (selectionLength)
		{
		*selectionLength = selectionLength__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle,
	                    &SpeechLib_IID_ISpeechTextSelectionInformation,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_NewISpeechPhraseInfoBuilder (const char *server,
                                                       int supportMultithreading,
                                                       LCID locale, int reserved,
                                                       CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xC23FC28D, 0xC55F, 0x4720, 0x8B, 0x32, 0x91, 0xF7, 0x3C,
	              0x2B, 0xD5, 0xD1};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpeechPhraseInfoBuilder,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenISpeechPhraseInfoBuilder (const char *fileName,
                                                        const char *server,
                                                        int supportMultithreading,
                                                        LCID locale,
                                                        int reserved,
                                                        CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xC23FC28D, 0xC55F, 0x4720, 0x8B, 0x32, 0x91, 0xF7, 0x3C,
	              0x2B, 0xD5, 0xD1};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpeechPhraseInfoBuilder,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveISpeechPhraseInfoBuilder (const char *server,
                                                          int supportMultithreading,
                                                          LCID locale,
                                                          int reserved,
                                                          CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xC23FC28D, 0xC55F, 0x4720, 0x8B, 0x32, 0x91, 0xF7, 0x3C,
	              0x2B, 0xD5, 0xD1};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpeechPhraseInfoBuilder,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseInfoBuilderRestorePhraseFromMemory (CAObjHandle objectHandle,
                                                                           ERRORINFO *errorInfo,
                                                                           VARIANT phraseInMemory,
                                                                           SpeechLibObj_ISpeechPhraseInfo *phraseInfo)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseInfoBuilder_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH phraseInfo__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (phraseInfo)
		*phraseInfo = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseInfoBuilder,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->RestorePhraseFromMemory_ (__vtblIFacePtr,
	                                                              &phraseInMemory,
	                                                              &phraseInfo__AutoType));
	

	if (phraseInfo)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (phraseInfo__AutoType,
		                                             &SpeechLib_IID_ISpeechPhraseInfo,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, phraseInfo));
		phraseInfo__AutoType = 0;
		}

Error:
	if (phraseInfo__AutoType)
		phraseInfo__AutoType->lpVtbl->Release (phraseInfo__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (phraseInfo)
			{
			CA_DiscardObjHandle (*phraseInfo);
			*phraseInfo = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseInfoBuilder,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_NewISpeechAudioFormat (const char *server,
                                                 int supportMultithreading,
                                                 LCID locale, int reserved,
                                                 CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x9EF96870, 0xE160, 0x4792, 0x82, 0xD, 0x48, 0xCF, 0x6, 0x49,
	              0xE4, 0xEC};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpeechAudioFormat,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenISpeechAudioFormat (const char *fileName,
                                                  const char *server,
                                                  int supportMultithreading,
                                                  LCID locale, int reserved,
                                                  CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x9EF96870, 0xE160, 0x4792, 0x82, 0xD, 0x48, 0xCF, 0x6, 0x49,
	              0xE4, 0xEC};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpeechAudioFormat,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveISpeechAudioFormat (const char *server,
                                                    int supportMultithreading,
                                                    LCID locale, int reserved,
                                                    CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x9EF96870, 0xE160, 0x4792, 0x82, 0xD, 0x48, 0xCF, 0x6, 0x49,
	              0xE4, 0xEC};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpeechAudioFormat,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechAudioFormatGetType (CAObjHandle objectHandle,
                                                     ERRORINFO *errorInfo,
                                                     enum SpeechLibEnum_SpeechAudioFormatType *audioFormat)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechAudioFormat_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long audioFormat__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechAudioFormat,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetType_ (__vtblIFacePtr,
	                                              (long *)&audioFormat__Temp));

	if (audioFormat)
		{
		*audioFormat = audioFormat__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechAudioFormat,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechAudioFormatSetType (CAObjHandle objectHandle,
                                                     ERRORINFO *errorInfo,
                                                     enum SpeechLibEnum_SpeechAudioFormatType audioFormat)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechAudioFormat_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechAudioFormat,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetType_ (__vtblIFacePtr, audioFormat));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechAudioFormat,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechAudioFormatGetGuid (CAObjHandle objectHandle,
                                                     ERRORINFO *errorInfo,
                                                     char **guid)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechAudioFormat_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR guid__AutoType = 0;

	if (guid)
		*guid = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechAudioFormat,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetGuid_ (__vtblIFacePtr,
	                                              &guid__AutoType));

	if (guid)
		__caErrChk (CA_BSTRGetCString (guid__AutoType, guid));

Error:
	CA_FreeBSTR (guid__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (guid)
			{
			CA_FreeMemory (*guid);
			*guid = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechAudioFormat,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechAudioFormatSetGuid (CAObjHandle objectHandle,
                                                     ERRORINFO *errorInfo,
                                                     const char *guid)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechAudioFormat_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR guid__AutoType = 0;

	__caErrChk (CA_CStringToBSTR (guid, &guid__AutoType));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechAudioFormat,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetGuid_ (__vtblIFacePtr,
	                                              guid__AutoType));

Error:
	CA_FreeBSTR (guid__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechAudioFormat,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechAudioFormatGetWaveFormatEx (CAObjHandle objectHandle,
                                                             ERRORINFO *errorInfo,
                                                             SpeechLibObj_ISpeechWaveFormatEx *speechWaveFormatEx)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechAudioFormat_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH speechWaveFormatEx__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (speechWaveFormatEx)
		*speechWaveFormatEx = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechAudioFormat,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetWaveFormatEx_ (__vtblIFacePtr,
	                                                      &speechWaveFormatEx__AutoType));
	

	if (speechWaveFormatEx)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (speechWaveFormatEx__AutoType,
		                                             &SpeechLib_IID_ISpeechWaveFormatEx,
		                                             __supportMultithreading,
		                                             __locale, 0, 0,
		                                             speechWaveFormatEx));
		speechWaveFormatEx__AutoType = 0;
		}

Error:
	if (speechWaveFormatEx__AutoType)
		speechWaveFormatEx__AutoType->lpVtbl->Release (speechWaveFormatEx__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (speechWaveFormatEx)
			{
			CA_DiscardObjHandle (*speechWaveFormatEx);
			*speechWaveFormatEx = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechAudioFormat,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechAudioFormatSetWaveFormatEx (CAObjHandle objectHandle,
                                                             ERRORINFO *errorInfo,
                                                             SpeechLibObj_ISpeechWaveFormatEx speechWaveFormatEx)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechAudioFormat_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH speechWaveFormatEx__AutoType = 0;

	if (speechWaveFormatEx)
		{
		__caErrChk (CA_GetInterfaceFromObjHandle (speechWaveFormatEx,
	                                          &SpeechLib_IID_ISpeechWaveFormatEx,
	                                          1, &speechWaveFormatEx__AutoType,
	                                          NULL));
		}

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechAudioFormat,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetWaveFormatEx_ (__vtblIFacePtr,
	                                                      speechWaveFormatEx__AutoType));

Error:
	if (speechWaveFormatEx__AutoType)
		speechWaveFormatEx__AutoType->lpVtbl->Release (speechWaveFormatEx__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechAudioFormat,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_NewISpeechWaveFormatEx (const char *server,
                                                  int supportMultithreading,
                                                  LCID locale, int reserved,
                                                  CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xC79A574C, 0x63BE, 0x44B9, 0x80, 0x1F, 0x28, 0x3F, 0x87,
	              0xF8, 0x98, 0xBE};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpeechWaveFormatEx,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenISpeechWaveFormatEx (const char *fileName,
                                                   const char *server,
                                                   int supportMultithreading,
                                                   LCID locale, int reserved,
                                                   CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xC79A574C, 0x63BE, 0x44B9, 0x80, 0x1F, 0x28, 0x3F, 0x87,
	              0xF8, 0x98, 0xBE};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpeechWaveFormatEx,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveISpeechWaveFormatEx (const char *server,
                                                     int supportMultithreading,
                                                     LCID locale, int reserved,
                                                     CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0xC79A574C, 0x63BE, 0x44B9, 0x80, 0x1F, 0x28, 0x3F, 0x87,
	              0xF8, 0x98, 0xBE};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpeechWaveFormatEx,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechWaveFormatExGetFormatTag (CAObjHandle objectHandle,
                                                           ERRORINFO *errorInfo,
                                                           short *formatTag)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechWaveFormatEx_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	short formatTag__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechWaveFormatEx,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetFormatTag_ (__vtblIFacePtr,
	                                                   &formatTag__Temp));

	if (formatTag)
		{
		*formatTag = formatTag__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechWaveFormatEx,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechWaveFormatExSetFormatTag (CAObjHandle objectHandle,
                                                           ERRORINFO *errorInfo,
                                                           short formatTag)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechWaveFormatEx_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechWaveFormatEx,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetFormatTag_ (__vtblIFacePtr,
	                                                   formatTag));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechWaveFormatEx,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechWaveFormatExGetChannels (CAObjHandle objectHandle,
                                                          ERRORINFO *errorInfo,
                                                          short *channels)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechWaveFormatEx_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	short channels__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechWaveFormatEx,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetChannels_ (__vtblIFacePtr,
	                                                  &channels__Temp));

	if (channels)
		{
		*channels = channels__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechWaveFormatEx,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechWaveFormatExSetChannels (CAObjHandle objectHandle,
                                                          ERRORINFO *errorInfo,
                                                          short channels)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechWaveFormatEx_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechWaveFormatEx,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetChannels_ (__vtblIFacePtr, channels));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechWaveFormatEx,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechWaveFormatExGetSamplesPerSec (CAObjHandle objectHandle,
                                                               ERRORINFO *errorInfo,
                                                               long *samplesPerSec)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechWaveFormatEx_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long samplesPerSec__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechWaveFormatEx,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetSamplesPerSec_ (__vtblIFacePtr,
	                                                       &samplesPerSec__Temp));

	if (samplesPerSec)
		{
		*samplesPerSec = samplesPerSec__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechWaveFormatEx,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechWaveFormatExSetSamplesPerSec (CAObjHandle objectHandle,
                                                               ERRORINFO *errorInfo,
                                                               long samplesPerSec)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechWaveFormatEx_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechWaveFormatEx,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetSamplesPerSec_ (__vtblIFacePtr,
	                                                       samplesPerSec));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechWaveFormatEx,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechWaveFormatExGetAvgBytesPerSec (CAObjHandle objectHandle,
                                                                ERRORINFO *errorInfo,
                                                                long *avgBytesPerSec)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechWaveFormatEx_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long avgBytesPerSec__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechWaveFormatEx,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetAvgBytesPerSec_ (__vtblIFacePtr,
	                                                        &avgBytesPerSec__Temp));

	if (avgBytesPerSec)
		{
		*avgBytesPerSec = avgBytesPerSec__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechWaveFormatEx,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechWaveFormatExSetAvgBytesPerSec (CAObjHandle objectHandle,
                                                                ERRORINFO *errorInfo,
                                                                long avgBytesPerSec)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechWaveFormatEx_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechWaveFormatEx,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetAvgBytesPerSec_ (__vtblIFacePtr,
	                                                        avgBytesPerSec));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechWaveFormatEx,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechWaveFormatExGetBlockAlign (CAObjHandle objectHandle,
                                                            ERRORINFO *errorInfo,
                                                            short *blockAlign)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechWaveFormatEx_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	short blockAlign__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechWaveFormatEx,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetBlockAlign_ (__vtblIFacePtr,
	                                                    &blockAlign__Temp));

	if (blockAlign)
		{
		*blockAlign = blockAlign__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechWaveFormatEx,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechWaveFormatExSetBlockAlign (CAObjHandle objectHandle,
                                                            ERRORINFO *errorInfo,
                                                            short blockAlign)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechWaveFormatEx_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechWaveFormatEx,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetBlockAlign_ (__vtblIFacePtr,
	                                                    blockAlign));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechWaveFormatEx,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechWaveFormatExGetBitsPerSample (CAObjHandle objectHandle,
                                                               ERRORINFO *errorInfo,
                                                               short *bitsPerSample)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechWaveFormatEx_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	short bitsPerSample__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechWaveFormatEx,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetBitsPerSample_ (__vtblIFacePtr,
	                                                       &bitsPerSample__Temp));

	if (bitsPerSample)
		{
		*bitsPerSample = bitsPerSample__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechWaveFormatEx,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechWaveFormatExSetBitsPerSample (CAObjHandle objectHandle,
                                                               ERRORINFO *errorInfo,
                                                               short bitsPerSample)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechWaveFormatEx_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechWaveFormatEx,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetBitsPerSample_ (__vtblIFacePtr,
	                                                       bitsPerSample));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechWaveFormatEx,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechWaveFormatExGetExtraData (CAObjHandle objectHandle,
                                                           ERRORINFO *errorInfo,
                                                           VARIANT *extraData)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechWaveFormatEx_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	VARIANT extraData__Temp;

	if (extraData)
		CA_VariantSetEmpty (extraData);
	CA_VariantSetEmpty (&extraData__Temp);

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechWaveFormatEx,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetExtraData_ (__vtblIFacePtr,
	                                                   &extraData__Temp));

	if (extraData)
		{
		*extraData = extraData__Temp;
		CA_VariantSetEmpty (&extraData__Temp);
		}

Error:
	CA_VariantClear (&extraData__Temp);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (extraData)
			CA_VariantClear (extraData);
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechWaveFormatEx,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechWaveFormatExSetExtraData (CAObjHandle objectHandle,
                                                           ERRORINFO *errorInfo,
                                                           VARIANT extraData)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechWaveFormatEx_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechWaveFormatEx,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetExtraData_ (__vtblIFacePtr,
	                                                   extraData));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechWaveFormatEx,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_NewISpeechCustomStream (const char *server,
                                                  int supportMultithreading,
                                                  LCID locale, int reserved,
                                                  CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x8DBEF13F, 0x1948, 0x4AA8, 0x8C, 0xF0, 0x4, 0x8E, 0xEB,
	              0xED, 0x95, 0xD8};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpeechCustomStream,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenISpeechCustomStream (const char *fileName,
                                                   const char *server,
                                                   int supportMultithreading,
                                                   LCID locale, int reserved,
                                                   CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x8DBEF13F, 0x1948, 0x4AA8, 0x8C, 0xF0, 0x4, 0x8E, 0xEB,
	              0xED, 0x95, 0xD8};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpeechCustomStream,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveISpeechCustomStream (const char *server,
                                                     int supportMultithreading,
                                                     LCID locale, int reserved,
                                                     CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x8DBEF13F, 0x1948, 0x4AA8, 0x8C, 0xF0, 0x4, 0x8E, 0xEB,
	              0xED, 0x95, 0xD8};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpeechCustomStream,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechCustomStreamGetFormat (CAObjHandle objectHandle,
                                                        ERRORINFO *errorInfo,
                                                        SpeechLibObj_ISpeechAudioFormat *audioFormat)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechCustomStream_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH audioFormat__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (audioFormat)
		*audioFormat = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechCustomStream,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetFormat_ (__vtblIFacePtr,
	                                                &audioFormat__AutoType));
	

	if (audioFormat)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (audioFormat__AutoType,
		                                             &SpeechLib_IID_ISpeechAudioFormat,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, audioFormat));
		audioFormat__AutoType = 0;
		}

Error:
	if (audioFormat__AutoType)
		audioFormat__AutoType->lpVtbl->Release (audioFormat__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (audioFormat)
			{
			CA_DiscardObjHandle (*audioFormat);
			*audioFormat = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechCustomStream,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechCustomStreamSetByRefFormat (CAObjHandle objectHandle,
                                                             ERRORINFO *errorInfo,
                                                             SpeechLibObj_ISpeechAudioFormat audioFormat)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechCustomStream_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH audioFormat__AutoType = 0;

	if (audioFormat)
		{
		__caErrChk (CA_GetInterfaceFromObjHandle (audioFormat,
	                                          &SpeechLib_IID_ISpeechAudioFormat,
	                                          1, &audioFormat__AutoType, NULL));
		}

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechCustomStream,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetByRefFormat_ (__vtblIFacePtr,
	                                                     audioFormat__AutoType));

Error:
	if (audioFormat__AutoType)
		audioFormat__AutoType->lpVtbl->Release (audioFormat__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechCustomStream,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechCustomStreamRead (CAObjHandle objectHandle,
                                                   ERRORINFO *errorInfo,
                                                   VARIANT *buffer,
                                                   long numberOfBytes,
                                                   long *bytesRead)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechCustomStream_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	VARIANT buffer__Temp;
	long bytesRead__Temp;

	if (buffer)
		CA_VariantSetEmpty (buffer);
	CA_VariantSetEmpty (&buffer__Temp);

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechCustomStream,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Read_ (__vtblIFacePtr, &buffer__Temp,
	                                           numberOfBytes, &bytesRead__Temp));

	if (buffer)
		{
		*buffer = buffer__Temp;
		CA_VariantSetEmpty (&buffer__Temp);
		}
	if (bytesRead)
		{
		*bytesRead = bytesRead__Temp;
		}

Error:
	CA_VariantClear (&buffer__Temp);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (buffer)
			CA_VariantClear (buffer);
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechCustomStream,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechCustomStreamWrite (CAObjHandle objectHandle,
                                                    ERRORINFO *errorInfo,
                                                    VARIANT buffer,
                                                    long *bytesWritten)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechCustomStream_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long bytesWritten__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechCustomStream,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Write_ (__vtblIFacePtr, buffer,
	                                            &bytesWritten__Temp));

	if (bytesWritten)
		{
		*bytesWritten = bytesWritten__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechCustomStream,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechCustomStreamSeek (CAObjHandle objectHandle,
                                                   ERRORINFO *errorInfo,
                                                   VARIANT position,
                                                   enum SpeechLibEnum_SpeechStreamSeekPositionType origin,
                                                   VARIANT *newPosition)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechCustomStream_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	VARIANT newPosition__Temp;

	if (newPosition)
		CA_VariantSetEmpty (newPosition);
	CA_VariantSetEmpty (&newPosition__Temp);

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechCustomStream,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Seek_ (__vtblIFacePtr, position,
	                                           origin, &newPosition__Temp));

	if (newPosition)
		{
		*newPosition = newPosition__Temp;
		CA_VariantSetEmpty (&newPosition__Temp);
		}

Error:
	CA_VariantClear (&newPosition__Temp);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (newPosition)
			CA_VariantClear (newPosition);
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechCustomStream,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechCustomStreamGetBaseStream (CAObjHandle objectHandle,
                                                            ERRORINFO *errorInfo,
                                                            LPUNKNOWN *ppUnkStream)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechCustomStream_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN ppUnkStream__Temp = 0;

	if (ppUnkStream)
		*ppUnkStream = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechCustomStream,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetBaseStream_ (__vtblIFacePtr,
	                                                    &ppUnkStream__Temp));

	if (ppUnkStream)
		{
		*ppUnkStream = ppUnkStream__Temp;
		ppUnkStream__Temp = 0;
		}

Error:
	if (ppUnkStream__Temp)
		ppUnkStream__Temp->lpVtbl->Release (ppUnkStream__Temp);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (ppUnkStream)
			{
			if (*ppUnkStream)
				(*ppUnkStream)->lpVtbl->Release (*ppUnkStream);
			*ppUnkStream = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechCustomStream,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechCustomStreamSetByRefBaseStream (CAObjHandle objectHandle,
                                                                 ERRORINFO *errorInfo,
                                                                 LPUNKNOWN ppUnkStream)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechCustomStream_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechCustomStream,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetByRefBaseStream_ (__vtblIFacePtr,
	                                                         ppUnkStream));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechCustomStream,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_NewISpeechFileStream (const char *server,
                                                int supportMultithreading,
                                                LCID locale, int reserved,
                                                CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x947812B3, 0x2AE1, 0x4644, 0xBA, 0x86, 0x9E, 0x90, 0xDE,
	              0xD7, 0xEC, 0x91};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpeechFileStream,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenISpeechFileStream (const char *fileName,
                                                 const char *server,
                                                 int supportMultithreading,
                                                 LCID locale, int reserved,
                                                 CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x947812B3, 0x2AE1, 0x4644, 0xBA, 0x86, 0x9E, 0x90, 0xDE,
	              0xD7, 0xEC, 0x91};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpeechFileStream,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveISpeechFileStream (const char *server,
                                                   int supportMultithreading,
                                                   LCID locale, int reserved,
                                                   CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x947812B3, 0x2AE1, 0x4644, 0xBA, 0x86, 0x9E, 0x90, 0xDE,
	              0xD7, 0xEC, 0x91};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpeechFileStream,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechFileStreamGetFormat (CAObjHandle objectHandle,
                                                      ERRORINFO *errorInfo,
                                                      SpeechLibObj_ISpeechAudioFormat *audioFormat)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechFileStream_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH audioFormat__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (audioFormat)
		*audioFormat = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechFileStream,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetFormat_ (__vtblIFacePtr,
	                                                &audioFormat__AutoType));
	

	if (audioFormat)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (audioFormat__AutoType,
		                                             &SpeechLib_IID_ISpeechAudioFormat,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, audioFormat));
		audioFormat__AutoType = 0;
		}

Error:
	if (audioFormat__AutoType)
		audioFormat__AutoType->lpVtbl->Release (audioFormat__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (audioFormat)
			{
			CA_DiscardObjHandle (*audioFormat);
			*audioFormat = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechFileStream,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechFileStreamSetByRefFormat (CAObjHandle objectHandle,
                                                           ERRORINFO *errorInfo,
                                                           SpeechLibObj_ISpeechAudioFormat audioFormat)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechFileStream_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH audioFormat__AutoType = 0;

	if (audioFormat)
		{
		__caErrChk (CA_GetInterfaceFromObjHandle (audioFormat,
	                                          &SpeechLib_IID_ISpeechAudioFormat,
	                                          1, &audioFormat__AutoType, NULL));
		}

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechFileStream,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetByRefFormat_ (__vtblIFacePtr,
	                                                     audioFormat__AutoType));

Error:
	if (audioFormat__AutoType)
		audioFormat__AutoType->lpVtbl->Release (audioFormat__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechFileStream,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechFileStreamRead (CAObjHandle objectHandle,
                                                 ERRORINFO *errorInfo,
                                                 VARIANT *buffer,
                                                 long numberOfBytes,
                                                 long *bytesRead)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechFileStream_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	VARIANT buffer__Temp;
	long bytesRead__Temp;

	if (buffer)
		CA_VariantSetEmpty (buffer);
	CA_VariantSetEmpty (&buffer__Temp);

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechFileStream,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Read_ (__vtblIFacePtr, &buffer__Temp,
	                                           numberOfBytes, &bytesRead__Temp));

	if (buffer)
		{
		*buffer = buffer__Temp;
		CA_VariantSetEmpty (&buffer__Temp);
		}
	if (bytesRead)
		{
		*bytesRead = bytesRead__Temp;
		}

Error:
	CA_VariantClear (&buffer__Temp);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (buffer)
			CA_VariantClear (buffer);
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechFileStream,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechFileStreamWrite (CAObjHandle objectHandle,
                                                  ERRORINFO *errorInfo,
                                                  VARIANT buffer,
                                                  long *bytesWritten)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechFileStream_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long bytesWritten__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechFileStream,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Write_ (__vtblIFacePtr, buffer,
	                                            &bytesWritten__Temp));

	if (bytesWritten)
		{
		*bytesWritten = bytesWritten__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechFileStream,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechFileStreamSeek (CAObjHandle objectHandle,
                                                 ERRORINFO *errorInfo,
                                                 VARIANT position,
                                                 enum SpeechLibEnum_SpeechStreamSeekPositionType origin,
                                                 VARIANT *newPosition)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechFileStream_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	VARIANT newPosition__Temp;

	if (newPosition)
		CA_VariantSetEmpty (newPosition);
	CA_VariantSetEmpty (&newPosition__Temp);

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechFileStream,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Seek_ (__vtblIFacePtr, position,
	                                           origin, &newPosition__Temp));

	if (newPosition)
		{
		*newPosition = newPosition__Temp;
		CA_VariantSetEmpty (&newPosition__Temp);
		}

Error:
	CA_VariantClear (&newPosition__Temp);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (newPosition)
			CA_VariantClear (newPosition);
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechFileStream,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechFileStreamOpen (CAObjHandle objectHandle,
                                                 ERRORINFO *errorInfo,
                                                 const char *fileName,
                                                 enum SpeechLibEnum_SpeechStreamFileMode fileMode,
                                                 VBOOL doEvents)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechFileStream_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR fileName__AutoType = 0;

	__caErrChk (CA_CStringToBSTR (fileName, &fileName__AutoType));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechFileStream,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Open_ (__vtblIFacePtr,
	                                           fileName__AutoType, fileMode,
	                                           doEvents));

Error:
	CA_FreeBSTR (fileName__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechFileStream,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechFileStreamClose (CAObjHandle objectHandle,
                                                  ERRORINFO *errorInfo)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechFileStream_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechFileStream,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Close_ (__vtblIFacePtr));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechFileStream,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_NewISpeechMemoryStream (const char *server,
                                                  int supportMultithreading,
                                                  LCID locale, int reserved,
                                                  CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x5FB7EF7D, 0xDFF4, 0x468A, 0xB6, 0xB7, 0x2F, 0xCB, 0xD1,
	              0x88, 0xF9, 0x94};

	__result = CA_CreateObjectByClassIdEx (&clsid, server,
	                                       &SpeechLib_IID_ISpeechMemoryStream,
	                                       supportMultithreading, locale,
	                                       reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_OpenISpeechMemoryStream (const char *fileName,
                                                   const char *server,
                                                   int supportMultithreading,
                                                   LCID locale, int reserved,
                                                   CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x5FB7EF7D, 0xDFF4, 0x468A, 0xB6, 0xB7, 0x2F, 0xCB, 0xD1,
	              0x88, 0xF9, 0x94};

	__result = CA_LoadObjectFromFileByClassIdEx (fileName, &clsid, server,
	                                             &SpeechLib_IID_ISpeechMemoryStream,
	                                             supportMultithreading, locale,
	                                             reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ActiveISpeechMemoryStream (const char *server,
                                                     int supportMultithreading,
                                                     LCID locale, int reserved,
                                                     CAObjHandle *objectHandle)
{
	HRESULT __result = S_OK;
	GUID clsid = {0x5FB7EF7D, 0xDFF4, 0x468A, 0xB6, 0xB7, 0x2F, 0xCB, 0xD1,
	              0x88, 0xF9, 0x94};

	__result = CA_GetActiveObjectByClassIdEx (&clsid, server,
	                                          &SpeechLib_IID_ISpeechMemoryStream,
	                                          supportMultithreading, locale,
	                                          reserved, objectHandle);

	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechMemoryStreamGetFormat (CAObjHandle objectHandle,
                                                        ERRORINFO *errorInfo,
                                                        SpeechLibObj_ISpeechAudioFormat *audioFormat)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechMemoryStream_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH audioFormat__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (audioFormat)
		*audioFormat = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechMemoryStream,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetFormat_ (__vtblIFacePtr,
	                                                &audioFormat__AutoType));
	

	if (audioFormat)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (audioFormat__AutoType,
		                                             &SpeechLib_IID_ISpeechAudioFormat,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, audioFormat));
		audioFormat__AutoType = 0;
		}

Error:
	if (audioFormat__AutoType)
		audioFormat__AutoType->lpVtbl->Release (audioFormat__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (audioFormat)
			{
			CA_DiscardObjHandle (*audioFormat);
			*audioFormat = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechMemoryStream,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechMemoryStreamSetByRefFormat (CAObjHandle objectHandle,
                                                             ERRORINFO *errorInfo,
                                                             SpeechLibObj_ISpeechAudioFormat audioFormat)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechMemoryStream_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH audioFormat__AutoType = 0;

	if (audioFormat)
		{
		__caErrChk (CA_GetInterfaceFromObjHandle (audioFormat,
	                                          &SpeechLib_IID_ISpeechAudioFormat,
	                                          1, &audioFormat__AutoType, NULL));
		}

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechMemoryStream,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetByRefFormat_ (__vtblIFacePtr,
	                                                     audioFormat__AutoType));

Error:
	if (audioFormat__AutoType)
		audioFormat__AutoType->lpVtbl->Release (audioFormat__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechMemoryStream,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechMemoryStreamRead (CAObjHandle objectHandle,
                                                   ERRORINFO *errorInfo,
                                                   VARIANT *buffer,
                                                   long numberOfBytes,
                                                   long *bytesRead)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechMemoryStream_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	VARIANT buffer__Temp;
	long bytesRead__Temp;

	if (buffer)
		CA_VariantSetEmpty (buffer);
	CA_VariantSetEmpty (&buffer__Temp);

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechMemoryStream,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Read_ (__vtblIFacePtr, &buffer__Temp,
	                                           numberOfBytes, &bytesRead__Temp));

	if (buffer)
		{
		*buffer = buffer__Temp;
		CA_VariantSetEmpty (&buffer__Temp);
		}
	if (bytesRead)
		{
		*bytesRead = bytesRead__Temp;
		}

Error:
	CA_VariantClear (&buffer__Temp);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (buffer)
			CA_VariantClear (buffer);
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechMemoryStream,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechMemoryStreamWrite (CAObjHandle objectHandle,
                                                    ERRORINFO *errorInfo,
                                                    VARIANT buffer,
                                                    long *bytesWritten)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechMemoryStream_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long bytesWritten__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechMemoryStream,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Write_ (__vtblIFacePtr, buffer,
	                                            &bytesWritten__Temp));

	if (bytesWritten)
		{
		*bytesWritten = bytesWritten__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechMemoryStream,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechMemoryStreamSeek (CAObjHandle objectHandle,
                                                   ERRORINFO *errorInfo,
                                                   VARIANT position,
                                                   enum SpeechLibEnum_SpeechStreamSeekPositionType origin,
                                                   VARIANT *newPosition)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechMemoryStream_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	VARIANT newPosition__Temp;

	if (newPosition)
		CA_VariantSetEmpty (newPosition);
	CA_VariantSetEmpty (&newPosition__Temp);

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechMemoryStream,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Seek_ (__vtblIFacePtr, position,
	                                           origin, &newPosition__Temp));

	if (newPosition)
		{
		*newPosition = newPosition__Temp;
		CA_VariantSetEmpty (&newPosition__Temp);
		}

Error:
	CA_VariantClear (&newPosition__Temp);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (newPosition)
			CA_VariantClear (newPosition);
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechMemoryStream,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechMemoryStreamSetData (CAObjHandle objectHandle,
                                                      ERRORINFO *errorInfo,
                                                      VARIANT data)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechMemoryStream_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechMemoryStream,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetData_ (__vtblIFacePtr, data));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechMemoryStream,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechMemoryStreamGetData (CAObjHandle objectHandle,
                                                      ERRORINFO *errorInfo,
                                                      VARIANT *pData)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechMemoryStream_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	VARIANT pData__Temp;

	if (pData)
		CA_VariantSetEmpty (pData);
	CA_VariantSetEmpty (&pData__Temp);

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechMemoryStream,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetData_ (__vtblIFacePtr, &pData__Temp));

	if (pData)
		{
		*pData = pData__Temp;
		CA_VariantSetEmpty (&pData__Temp);
		}

Error:
	CA_VariantClear (&pData__Temp);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (pData)
			CA_VariantClear (pData);
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechMemoryStream,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechDataKeySetBinaryValue (CAObjHandle objectHandle,
                                                        ERRORINFO *errorInfo,
                                                        const char *valueName,
                                                        VARIANT value)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechDataKey_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR valueName__AutoType = 0;

	__caErrChk (CA_CStringToBSTR (valueName, &valueName__AutoType));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechDataKey, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetBinaryValue_ (__vtblIFacePtr,
	                                                     valueName__AutoType,
	                                                     value));

Error:
	CA_FreeBSTR (valueName__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechDataKey, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechDataKeyGetBinaryValue (CAObjHandle objectHandle,
                                                        ERRORINFO *errorInfo,
                                                        const char *valueName,
                                                        VARIANT *value)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechDataKey_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR valueName__AutoType = 0;
	VARIANT value__Temp;

	if (value)
		CA_VariantSetEmpty (value);
	CA_VariantSetEmpty (&value__Temp);

	__caErrChk (CA_CStringToBSTR (valueName, &valueName__AutoType));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechDataKey, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetBinaryValue_ (__vtblIFacePtr,
	                                                     valueName__AutoType,
	                                                     &value__Temp));

	if (value)
		{
		*value = value__Temp;
		CA_VariantSetEmpty (&value__Temp);
		}

Error:
	CA_FreeBSTR (valueName__AutoType);
	CA_VariantClear (&value__Temp);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (value)
			CA_VariantClear (value);
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechDataKey, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechDataKeySetStringValue (CAObjHandle objectHandle,
                                                        ERRORINFO *errorInfo,
                                                        const char *valueName,
                                                        const char *value)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechDataKey_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR valueName__AutoType = 0;
	BSTR value__AutoType = 0;

	__caErrChk (CA_CStringToBSTR (valueName, &valueName__AutoType));
	__caErrChk (CA_CStringToBSTR (value, &value__AutoType));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechDataKey, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetStringValue_ (__vtblIFacePtr,
	                                                     valueName__AutoType,
	                                                     value__AutoType));

Error:
	CA_FreeBSTR (valueName__AutoType);
	CA_FreeBSTR (value__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechDataKey, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechDataKeyGetStringValue (CAObjHandle objectHandle,
                                                        ERRORINFO *errorInfo,
                                                        const char *valueName,
                                                        char **value)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechDataKey_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR valueName__AutoType = 0;
	BSTR value__AutoType = 0;

	if (value)
		*value = 0;

	__caErrChk (CA_CStringToBSTR (valueName, &valueName__AutoType));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechDataKey, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetStringValue_ (__vtblIFacePtr,
	                                                     valueName__AutoType,
	                                                     &value__AutoType));

	if (value)
		__caErrChk (CA_BSTRGetCString (value__AutoType, value));

Error:
	CA_FreeBSTR (valueName__AutoType);
	CA_FreeBSTR (value__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (value)
			{
			CA_FreeMemory (*value);
			*value = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechDataKey, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechDataKeySetLongValue (CAObjHandle objectHandle,
                                                      ERRORINFO *errorInfo,
                                                      const char *valueName,
                                                      long value)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechDataKey_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR valueName__AutoType = 0;

	__caErrChk (CA_CStringToBSTR (valueName, &valueName__AutoType));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechDataKey, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetLongValue_ (__vtblIFacePtr,
	                                                   valueName__AutoType,
	                                                   value));

Error:
	CA_FreeBSTR (valueName__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechDataKey, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechDataKeyGetLongValue (CAObjHandle objectHandle,
                                                      ERRORINFO *errorInfo,
                                                      const char *valueName,
                                                      long *value)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechDataKey_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR valueName__AutoType = 0;
	long value__Temp;

	__caErrChk (CA_CStringToBSTR (valueName, &valueName__AutoType));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechDataKey, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetLongValue_ (__vtblIFacePtr,
	                                                   valueName__AutoType,
	                                                   &value__Temp));

	if (value)
		{
		*value = value__Temp;
		}

Error:
	CA_FreeBSTR (valueName__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechDataKey, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechDataKeyOpenKey (CAObjHandle objectHandle,
                                                 ERRORINFO *errorInfo,
                                                 const char *subKeyName,
                                                 SpeechLibObj_ISpeechDataKey *subKey)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechDataKey_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR subKeyName__AutoType = 0;
	LPDISPATCH subKey__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (subKey)
		*subKey = 0;

	__caErrChk (CA_CStringToBSTR (subKeyName, &subKeyName__AutoType));
	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechDataKey, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->OpenKey_ (__vtblIFacePtr,
	                                              subKeyName__AutoType,
	                                              &subKey__AutoType));
	

	if (subKey)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (subKey__AutoType,
		                                             &SpeechLib_IID_ISpeechDataKey,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, subKey));
		subKey__AutoType = 0;
		}

Error:
	CA_FreeBSTR (subKeyName__AutoType);
	if (subKey__AutoType)
		subKey__AutoType->lpVtbl->Release (subKey__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (subKey)
			{
			CA_DiscardObjHandle (*subKey);
			*subKey = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechDataKey, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechDataKeyCreateKey (CAObjHandle objectHandle,
                                                   ERRORINFO *errorInfo,
                                                   const char *subKeyName,
                                                   SpeechLibObj_ISpeechDataKey *subKey)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechDataKey_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR subKeyName__AutoType = 0;
	LPDISPATCH subKey__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (subKey)
		*subKey = 0;

	__caErrChk (CA_CStringToBSTR (subKeyName, &subKeyName__AutoType));
	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechDataKey, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->CreateKey_ (__vtblIFacePtr,
	                                                subKeyName__AutoType,
	                                                &subKey__AutoType));
	

	if (subKey)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (subKey__AutoType,
		                                             &SpeechLib_IID_ISpeechDataKey,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, subKey));
		subKey__AutoType = 0;
		}

Error:
	CA_FreeBSTR (subKeyName__AutoType);
	if (subKey__AutoType)
		subKey__AutoType->lpVtbl->Release (subKey__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (subKey)
			{
			CA_DiscardObjHandle (*subKey);
			*subKey = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechDataKey, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechDataKeyDeleteKey (CAObjHandle objectHandle,
                                                   ERRORINFO *errorInfo,
                                                   const char *subKeyName)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechDataKey_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR subKeyName__AutoType = 0;

	__caErrChk (CA_CStringToBSTR (subKeyName, &subKeyName__AutoType));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechDataKey, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->DeleteKey_ (__vtblIFacePtr,
	                                                subKeyName__AutoType));

Error:
	CA_FreeBSTR (subKeyName__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechDataKey, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechDataKeyDeleteValue (CAObjHandle objectHandle,
                                                     ERRORINFO *errorInfo,
                                                     const char *valueName)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechDataKey_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR valueName__AutoType = 0;

	__caErrChk (CA_CStringToBSTR (valueName, &valueName__AutoType));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechDataKey, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->DeleteValue_ (__vtblIFacePtr,
	                                                  valueName__AutoType));

Error:
	CA_FreeBSTR (valueName__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechDataKey, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechDataKeyEnumKeys (CAObjHandle objectHandle,
                                                  ERRORINFO *errorInfo,
                                                  long index, char **subKeyName)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechDataKey_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR subKeyName__AutoType = 0;

	if (subKeyName)
		*subKeyName = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechDataKey, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->EnumKeys_ (__vtblIFacePtr, index,
	                                               &subKeyName__AutoType));

	if (subKeyName)
		__caErrChk (CA_BSTRGetCString (subKeyName__AutoType, subKeyName));

Error:
	CA_FreeBSTR (subKeyName__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (subKeyName)
			{
			CA_FreeMemory (*subKeyName);
			*subKeyName = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechDataKey, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechDataKeyEnumValues (CAObjHandle objectHandle,
                                                    ERRORINFO *errorInfo,
                                                    long index, char **valueName)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechDataKey_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR valueName__AutoType = 0;

	if (valueName)
		*valueName = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechDataKey, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->EnumValues_ (__vtblIFacePtr, index,
	                                                 &valueName__AutoType));

	if (valueName)
		__caErrChk (CA_BSTRGetCString (valueName__AutoType, valueName));

Error:
	CA_FreeBSTR (valueName__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (valueName)
			{
			CA_FreeMemory (*valueName);
			*valueName = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechDataKey, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechObjectTokensGetCount (CAObjHandle objectHandle,
                                                       ERRORINFO *errorInfo,
                                                       long *count)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechObjectTokens_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long count__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechObjectTokens,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetCount_ (__vtblIFacePtr,
	                                               &count__Temp));

	if (count)
		{
		*count = count__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechObjectTokens,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechObjectTokensItem (CAObjHandle objectHandle,
                                                   ERRORINFO *errorInfo,
                                                   long index,
                                                   SpeechLibObj_ISpeechObjectToken *token)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechObjectTokens_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH token__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (token)
		*token = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechObjectTokens,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Item_ (__vtblIFacePtr, index,
	                                           &token__AutoType));
	

	if (token)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (token__AutoType,
		                                             &SpeechLib_IID_ISpeechObjectToken,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, token));
		token__AutoType = 0;
		}

Error:
	if (token__AutoType)
		token__AutoType->lpVtbl->Release (token__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (token)
			{
			CA_DiscardObjHandle (*token);
			*token = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechObjectTokens,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechObjectTokensGet_NewEnum (CAObjHandle objectHandle,
                                                          ERRORINFO *errorInfo,
                                                          LPUNKNOWN *ppEnumVARIANT)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechObjectTokens_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN ppEnumVARIANT__Temp = 0;

	if (ppEnumVARIANT)
		*ppEnumVARIANT = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechObjectTokens,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Get_NewEnum_ (__vtblIFacePtr,
	                                                  &ppEnumVARIANT__Temp));

	if (ppEnumVARIANT)
		{
		*ppEnumVARIANT = ppEnumVARIANT__Temp;
		ppEnumVARIANT__Temp = 0;
		}

Error:
	if (ppEnumVARIANT__Temp)
		ppEnumVARIANT__Temp->lpVtbl->Release (ppEnumVARIANT__Temp);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (ppEnumVARIANT)
			{
			if (*ppEnumVARIANT)
				(*ppEnumVARIANT)->lpVtbl->Release (*ppEnumVARIANT);
			*ppEnumVARIANT = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechObjectTokens,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechAudioBufferInfoGetMinNotification (CAObjHandle objectHandle,
                                                                    ERRORINFO *errorInfo,
                                                                    long *minNotification)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechAudioBufferInfo_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long minNotification__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechAudioBufferInfo,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetMinNotification_ (__vtblIFacePtr,
	                                                         &minNotification__Temp));

	if (minNotification)
		{
		*minNotification = minNotification__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechAudioBufferInfo,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechAudioBufferInfoSetMinNotification (CAObjHandle objectHandle,
                                                                    ERRORINFO *errorInfo,
                                                                    long minNotification)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechAudioBufferInfo_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechAudioBufferInfo,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetMinNotification_ (__vtblIFacePtr,
	                                                         minNotification));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechAudioBufferInfo,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechAudioBufferInfoGetBufferSize (CAObjHandle objectHandle,
                                                               ERRORINFO *errorInfo,
                                                               long *bufferSize)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechAudioBufferInfo_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long bufferSize__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechAudioBufferInfo,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetBufferSize_ (__vtblIFacePtr,
	                                                    &bufferSize__Temp));

	if (bufferSize)
		{
		*bufferSize = bufferSize__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechAudioBufferInfo,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechAudioBufferInfoSetBufferSize (CAObjHandle objectHandle,
                                                               ERRORINFO *errorInfo,
                                                               long bufferSize)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechAudioBufferInfo_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechAudioBufferInfo,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetBufferSize_ (__vtblIFacePtr,
	                                                    bufferSize));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechAudioBufferInfo,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechAudioBufferInfoGetEventBias (CAObjHandle objectHandle,
                                                              ERRORINFO *errorInfo,
                                                              long *eventBias)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechAudioBufferInfo_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long eventBias__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechAudioBufferInfo,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetEventBias_ (__vtblIFacePtr,
	                                                   &eventBias__Temp));

	if (eventBias)
		{
		*eventBias = eventBias__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechAudioBufferInfo,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechAudioBufferInfoSetEventBias (CAObjHandle objectHandle,
                                                              ERRORINFO *errorInfo,
                                                              long eventBias)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechAudioBufferInfo_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechAudioBufferInfo,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetEventBias_ (__vtblIFacePtr,
	                                                   eventBias));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechAudioBufferInfo,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechAudioStatusGetFreeBufferSpace (CAObjHandle objectHandle,
                                                                ERRORINFO *errorInfo,
                                                                long *freeBufferSpace)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechAudioStatus_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long freeBufferSpace__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechAudioStatus,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetFreeBufferSpace_ (__vtblIFacePtr,
	                                                         &freeBufferSpace__Temp));

	if (freeBufferSpace)
		{
		*freeBufferSpace = freeBufferSpace__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechAudioStatus,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechAudioStatusGetNonBlockingIO (CAObjHandle objectHandle,
                                                              ERRORINFO *errorInfo,
                                                              long *nonBlockingIO)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechAudioStatus_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long nonBlockingIO__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechAudioStatus,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetNonBlockingIO_ (__vtblIFacePtr,
	                                                       &nonBlockingIO__Temp));

	if (nonBlockingIO)
		{
		*nonBlockingIO = nonBlockingIO__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechAudioStatus,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechAudioStatusGetState (CAObjHandle objectHandle,
                                                      ERRORINFO *errorInfo,
                                                      enum SpeechLibEnum_SpeechAudioState *state)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechAudioStatus_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long state__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechAudioStatus,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetState_ (__vtblIFacePtr,
	                                               (long *)&state__Temp));

	if (state)
		{
		*state = state__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechAudioStatus,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechAudioStatusGetCurrentSeekPosition (CAObjHandle objectHandle,
                                                                    ERRORINFO *errorInfo,
                                                                    VARIANT *currentSeekPosition)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechAudioStatus_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	VARIANT currentSeekPosition__Temp;

	if (currentSeekPosition)
		CA_VariantSetEmpty (currentSeekPosition);
	CA_VariantSetEmpty (&currentSeekPosition__Temp);

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechAudioStatus,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetCurrentSeekPosition_ (__vtblIFacePtr,
	                                                             &currentSeekPosition__Temp));

	if (currentSeekPosition)
		{
		*currentSeekPosition = currentSeekPosition__Temp;
		CA_VariantSetEmpty (&currentSeekPosition__Temp);
		}

Error:
	CA_VariantClear (&currentSeekPosition__Temp);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (currentSeekPosition)
			CA_VariantClear (currentSeekPosition);
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechAudioStatus,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechAudioStatusGetCurrentDevicePosition (CAObjHandle objectHandle,
                                                                      ERRORINFO *errorInfo,
                                                                      VARIANT *currentDevicePosition)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechAudioStatus_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	VARIANT currentDevicePosition__Temp;

	if (currentDevicePosition)
		CA_VariantSetEmpty (currentDevicePosition);
	CA_VariantSetEmpty (&currentDevicePosition__Temp);

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechAudioStatus,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetCurrentDevicePosition_ (__vtblIFacePtr,
	                                                               &currentDevicePosition__Temp));

	if (currentDevicePosition)
		{
		*currentDevicePosition = currentDevicePosition__Temp;
		CA_VariantSetEmpty (&currentDevicePosition__Temp);
		}

Error:
	CA_VariantClear (&currentDevicePosition__Temp);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (currentDevicePosition)
			CA_VariantClear (currentDevicePosition);
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechAudioStatus,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechBaseStreamGetFormat (CAObjHandle objectHandle,
                                                      ERRORINFO *errorInfo,
                                                      SpeechLibObj_ISpeechAudioFormat *audioFormat)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechBaseStream_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH audioFormat__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (audioFormat)
		*audioFormat = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechBaseStream,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetFormat_ (__vtblIFacePtr,
	                                                &audioFormat__AutoType));
	

	if (audioFormat)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (audioFormat__AutoType,
		                                             &SpeechLib_IID_ISpeechAudioFormat,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, audioFormat));
		audioFormat__AutoType = 0;
		}

Error:
	if (audioFormat__AutoType)
		audioFormat__AutoType->lpVtbl->Release (audioFormat__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (audioFormat)
			{
			CA_DiscardObjHandle (*audioFormat);
			*audioFormat = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechBaseStream,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechBaseStreamSetByRefFormat (CAObjHandle objectHandle,
                                                           ERRORINFO *errorInfo,
                                                           SpeechLibObj_ISpeechAudioFormat audioFormat)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechBaseStream_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH audioFormat__AutoType = 0;

	if (audioFormat)
		{
		__caErrChk (CA_GetInterfaceFromObjHandle (audioFormat,
	                                          &SpeechLib_IID_ISpeechAudioFormat,
	                                          1, &audioFormat__AutoType, NULL));
		}

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechBaseStream,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetByRefFormat_ (__vtblIFacePtr,
	                                                     audioFormat__AutoType));

Error:
	if (audioFormat__AutoType)
		audioFormat__AutoType->lpVtbl->Release (audioFormat__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechBaseStream,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechBaseStreamRead (CAObjHandle objectHandle,
                                                 ERRORINFO *errorInfo,
                                                 VARIANT *buffer,
                                                 long numberOfBytes,
                                                 long *bytesRead)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechBaseStream_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	VARIANT buffer__Temp;
	long bytesRead__Temp;

	if (buffer)
		CA_VariantSetEmpty (buffer);
	CA_VariantSetEmpty (&buffer__Temp);

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechBaseStream,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Read_ (__vtblIFacePtr, &buffer__Temp,
	                                           numberOfBytes, &bytesRead__Temp));

	if (buffer)
		{
		*buffer = buffer__Temp;
		CA_VariantSetEmpty (&buffer__Temp);
		}
	if (bytesRead)
		{
		*bytesRead = bytesRead__Temp;
		}

Error:
	CA_VariantClear (&buffer__Temp);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (buffer)
			CA_VariantClear (buffer);
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechBaseStream,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechBaseStreamWrite (CAObjHandle objectHandle,
                                                  ERRORINFO *errorInfo,
                                                  VARIANT buffer,
                                                  long *bytesWritten)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechBaseStream_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long bytesWritten__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechBaseStream,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Write_ (__vtblIFacePtr, buffer,
	                                            &bytesWritten__Temp));

	if (bytesWritten)
		{
		*bytesWritten = bytesWritten__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechBaseStream,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechBaseStreamSeek (CAObjHandle objectHandle,
                                                 ERRORINFO *errorInfo,
                                                 VARIANT position,
                                                 enum SpeechLibEnum_SpeechStreamSeekPositionType origin,
                                                 VARIANT *newPosition)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechBaseStream_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	VARIANT newPosition__Temp;

	if (newPosition)
		CA_VariantSetEmpty (newPosition);
	CA_VariantSetEmpty (&newPosition__Temp);

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechBaseStream,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Seek_ (__vtblIFacePtr, position,
	                                           origin, &newPosition__Temp));

	if (newPosition)
		{
		*newPosition = newPosition__Temp;
		CA_VariantSetEmpty (&newPosition__Temp);
		}

Error:
	CA_VariantClear (&newPosition__Temp);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (newPosition)
			CA_VariantClear (newPosition);
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechBaseStream,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechAudioGetFormat (CAObjHandle objectHandle,
                                                 ERRORINFO *errorInfo,
                                                 SpeechLibObj_ISpeechAudioFormat *audioFormat)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechAudio_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH audioFormat__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (audioFormat)
		*audioFormat = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechAudio, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetFormat_ (__vtblIFacePtr,
	                                                &audioFormat__AutoType));
	

	if (audioFormat)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (audioFormat__AutoType,
		                                             &SpeechLib_IID_ISpeechAudioFormat,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, audioFormat));
		audioFormat__AutoType = 0;
		}

Error:
	if (audioFormat__AutoType)
		audioFormat__AutoType->lpVtbl->Release (audioFormat__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (audioFormat)
			{
			CA_DiscardObjHandle (*audioFormat);
			*audioFormat = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechAudio, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechAudioSetByRefFormat (CAObjHandle objectHandle,
                                                      ERRORINFO *errorInfo,
                                                      SpeechLibObj_ISpeechAudioFormat audioFormat)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechAudio_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH audioFormat__AutoType = 0;

	if (audioFormat)
		{
		__caErrChk (CA_GetInterfaceFromObjHandle (audioFormat,
	                                          &SpeechLib_IID_ISpeechAudioFormat,
	                                          1, &audioFormat__AutoType, NULL));
		}

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechAudio, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetByRefFormat_ (__vtblIFacePtr,
	                                                     audioFormat__AutoType));

Error:
	if (audioFormat__AutoType)
		audioFormat__AutoType->lpVtbl->Release (audioFormat__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechAudio, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechAudioRead (CAObjHandle objectHandle,
                                            ERRORINFO *errorInfo,
                                            VARIANT *buffer, long numberOfBytes,
                                            long *bytesRead)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechAudio_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	VARIANT buffer__Temp;
	long bytesRead__Temp;

	if (buffer)
		CA_VariantSetEmpty (buffer);
	CA_VariantSetEmpty (&buffer__Temp);

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechAudio, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Read_ (__vtblIFacePtr, &buffer__Temp,
	                                           numberOfBytes, &bytesRead__Temp));

	if (buffer)
		{
		*buffer = buffer__Temp;
		CA_VariantSetEmpty (&buffer__Temp);
		}
	if (bytesRead)
		{
		*bytesRead = bytesRead__Temp;
		}

Error:
	CA_VariantClear (&buffer__Temp);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (buffer)
			CA_VariantClear (buffer);
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechAudio, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechAudioWrite (CAObjHandle objectHandle,
                                             ERRORINFO *errorInfo,
                                             VARIANT buffer, long *bytesWritten)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechAudio_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long bytesWritten__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechAudio, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Write_ (__vtblIFacePtr, buffer,
	                                            &bytesWritten__Temp));

	if (bytesWritten)
		{
		*bytesWritten = bytesWritten__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechAudio, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechAudioSeek (CAObjHandle objectHandle,
                                            ERRORINFO *errorInfo,
                                            VARIANT position,
                                            enum SpeechLibEnum_SpeechStreamSeekPositionType origin,
                                            VARIANT *newPosition)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechAudio_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	VARIANT newPosition__Temp;

	if (newPosition)
		CA_VariantSetEmpty (newPosition);
	CA_VariantSetEmpty (&newPosition__Temp);

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechAudio, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Seek_ (__vtblIFacePtr, position,
	                                           origin, &newPosition__Temp));

	if (newPosition)
		{
		*newPosition = newPosition__Temp;
		CA_VariantSetEmpty (&newPosition__Temp);
		}

Error:
	CA_VariantClear (&newPosition__Temp);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (newPosition)
			CA_VariantClear (newPosition);
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechAudio, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechAudioGetStatus (CAObjHandle objectHandle,
                                                 ERRORINFO *errorInfo,
                                                 SpeechLibObj_ISpeechAudioStatus *status)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechAudio_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH status__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (status)
		*status = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechAudio, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetStatus_ (__vtblIFacePtr,
	                                                &status__AutoType));
	

	if (status)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (status__AutoType,
		                                             &SpeechLib_IID_ISpeechAudioStatus,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, status));
		status__AutoType = 0;
		}

Error:
	if (status__AutoType)
		status__AutoType->lpVtbl->Release (status__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (status)
			{
			CA_DiscardObjHandle (*status);
			*status = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechAudio, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechAudioGetBufferInfo (CAObjHandle objectHandle,
                                                     ERRORINFO *errorInfo,
                                                     SpeechLibObj_ISpeechAudioBufferInfo *bufferInfo)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechAudio_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH bufferInfo__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (bufferInfo)
		*bufferInfo = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechAudio, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetBufferInfo_ (__vtblIFacePtr,
	                                                    &bufferInfo__AutoType));
	

	if (bufferInfo)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (bufferInfo__AutoType,
		                                             &SpeechLib_IID_ISpeechAudioBufferInfo,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, bufferInfo));
		bufferInfo__AutoType = 0;
		}

Error:
	if (bufferInfo__AutoType)
		bufferInfo__AutoType->lpVtbl->Release (bufferInfo__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (bufferInfo)
			{
			CA_DiscardObjHandle (*bufferInfo);
			*bufferInfo = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechAudio, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechAudioGetDefaultFormat (CAObjHandle objectHandle,
                                                        ERRORINFO *errorInfo,
                                                        SpeechLibObj_ISpeechAudioFormat *streamFormat)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechAudio_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH streamFormat__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (streamFormat)
		*streamFormat = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechAudio, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetDefaultFormat_ (__vtblIFacePtr,
	                                                       &streamFormat__AutoType));
	

	if (streamFormat)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (streamFormat__AutoType,
		                                             &SpeechLib_IID_ISpeechAudioFormat,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, streamFormat));
		streamFormat__AutoType = 0;
		}

Error:
	if (streamFormat__AutoType)
		streamFormat__AutoType->lpVtbl->Release (streamFormat__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (streamFormat)
			{
			CA_DiscardObjHandle (*streamFormat);
			*streamFormat = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechAudio, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechAudioGetVolume (CAObjHandle objectHandle,
                                                 ERRORINFO *errorInfo,
                                                 long *volume)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechAudio_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long volume__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechAudio, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetVolume_ (__vtblIFacePtr,
	                                                &volume__Temp));

	if (volume)
		{
		*volume = volume__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechAudio, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechAudioSetVolume (CAObjHandle objectHandle,
                                                 ERRORINFO *errorInfo,
                                                 long volume)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechAudio_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechAudio, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetVolume_ (__vtblIFacePtr, volume));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechAudio, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechAudioGetBufferNotifySize (CAObjHandle objectHandle,
                                                           ERRORINFO *errorInfo,
                                                           long *bufferNotifySize)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechAudio_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long bufferNotifySize__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechAudio, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetBufferNotifySize_ (__vtblIFacePtr,
	                                                          &bufferNotifySize__Temp));

	if (bufferNotifySize)
		{
		*bufferNotifySize = bufferNotifySize__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechAudio, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechAudioSetBufferNotifySize (CAObjHandle objectHandle,
                                                           ERRORINFO *errorInfo,
                                                           long bufferNotifySize)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechAudio_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechAudio, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetBufferNotifySize_ (__vtblIFacePtr,
	                                                          bufferNotifySize));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechAudio, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechAudioGetEventHandle (CAObjHandle objectHandle,
                                                      ERRORINFO *errorInfo,
                                                      long *eventHandle)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechAudio_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long eventHandle__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechAudio, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetEventHandle_ (__vtblIFacePtr,
	                                                     &eventHandle__Temp));

	if (eventHandle)
		{
		*eventHandle = eventHandle__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechAudio, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechAudioSetState (CAObjHandle objectHandle,
                                                ERRORINFO *errorInfo,
                                                enum SpeechLibEnum_SpeechAudioState state)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechAudio_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechAudio, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetState_ (__vtblIFacePtr, state));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechAudio, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechVoiceStatusGetCurrentStreamNumber (CAObjHandle objectHandle,
                                                                    ERRORINFO *errorInfo,
                                                                    long *streamNumber)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechVoiceStatus_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long streamNumber__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechVoiceStatus,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetCurrentStreamNumber_ (__vtblIFacePtr,
	                                                             &streamNumber__Temp));

	if (streamNumber)
		{
		*streamNumber = streamNumber__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechVoiceStatus,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechVoiceStatusGetLastStreamNumberQueued (CAObjHandle objectHandle,
                                                                       ERRORINFO *errorInfo,
                                                                       long *streamNumber)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechVoiceStatus_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long streamNumber__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechVoiceStatus,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetLastStreamNumberQueued_ (__vtblIFacePtr,
	                                                                &streamNumber__Temp));

	if (streamNumber)
		{
		*streamNumber = streamNumber__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechVoiceStatus,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechVoiceStatusGetLastHResult (CAObjHandle objectHandle,
                                                            ERRORINFO *errorInfo,
                                                            long *HResult)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechVoiceStatus_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long HResult__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechVoiceStatus,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetLastHResult_ (__vtblIFacePtr,
	                                                     &HResult__Temp));

	if (HResult)
		{
		*HResult = HResult__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechVoiceStatus,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechVoiceStatusGetRunningState (CAObjHandle objectHandle,
                                                             ERRORINFO *errorInfo,
                                                             enum SpeechLibEnum_SpeechRunState *state)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechVoiceStatus_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long state__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechVoiceStatus,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetRunningState_ (__vtblIFacePtr,
	                                                      (long *)&state__Temp));

	if (state)
		{
		*state = state__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechVoiceStatus,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechVoiceStatusGetInputWordPosition (CAObjHandle objectHandle,
                                                                  ERRORINFO *errorInfo,
                                                                  long *position)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechVoiceStatus_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long position__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechVoiceStatus,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetInputWordPosition_ (__vtblIFacePtr,
	                                                           &position__Temp));

	if (position)
		{
		*position = position__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechVoiceStatus,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechVoiceStatusGetInputWordLength (CAObjHandle objectHandle,
                                                                ERRORINFO *errorInfo,
                                                                long *length)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechVoiceStatus_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long length__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechVoiceStatus,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetInputWordLength_ (__vtblIFacePtr,
	                                                         &length__Temp));

	if (length)
		{
		*length = length__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechVoiceStatus,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechVoiceStatusGetInputSentencePosition (CAObjHandle objectHandle,
                                                                      ERRORINFO *errorInfo,
                                                                      long *position)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechVoiceStatus_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long position__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechVoiceStatus,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetInputSentencePosition_ (__vtblIFacePtr,
	                                                               &position__Temp));

	if (position)
		{
		*position = position__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechVoiceStatus,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechVoiceStatusGetInputSentenceLength (CAObjHandle objectHandle,
                                                                    ERRORINFO *errorInfo,
                                                                    long *length)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechVoiceStatus_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long length__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechVoiceStatus,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetInputSentenceLength_ (__vtblIFacePtr,
	                                                             &length__Temp));

	if (length)
		{
		*length = length__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechVoiceStatus,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechVoiceStatusGetLastBookmark (CAObjHandle objectHandle,
                                                             ERRORINFO *errorInfo,
                                                             char **bookmark)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechVoiceStatus_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR bookmark__AutoType = 0;

	if (bookmark)
		*bookmark = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechVoiceStatus,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetLastBookmark_ (__vtblIFacePtr,
	                                                      &bookmark__AutoType));

	if (bookmark)
		__caErrChk (CA_BSTRGetCString (bookmark__AutoType, bookmark));

Error:
	CA_FreeBSTR (bookmark__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (bookmark)
			{
			CA_FreeMemory (*bookmark);
			*bookmark = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechVoiceStatus,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechVoiceStatusGetLastBookmarkId (CAObjHandle objectHandle,
                                                               ERRORINFO *errorInfo,
                                                               long *bookmarkId)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechVoiceStatus_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long bookmarkId__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechVoiceStatus,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetLastBookmarkId_ (__vtblIFacePtr,
	                                                        &bookmarkId__Temp));

	if (bookmarkId)
		{
		*bookmarkId = bookmarkId__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechVoiceStatus,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechVoiceStatusGetPhonemeId (CAObjHandle objectHandle,
                                                          ERRORINFO *errorInfo,
                                                          short *phoneId)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechVoiceStatus_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	short phoneId__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechVoiceStatus,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetPhonemeId_ (__vtblIFacePtr,
	                                                   &phoneId__Temp));

	if (phoneId)
		{
		*phoneId = phoneId__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechVoiceStatus,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechVoiceStatusGetVisemeId (CAObjHandle objectHandle,
                                                         ERRORINFO *errorInfo,
                                                         short *visemeId)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechVoiceStatus_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	short visemeId__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechVoiceStatus,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetVisemeId_ (__vtblIFacePtr,
	                                                  &visemeId__Temp));

	if (visemeId)
		{
		*visemeId = visemeId__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechVoiceStatus,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecognizerStatusGetAudioStatus (CAObjHandle objectHandle,
                                                                 ERRORINFO *errorInfo,
                                                                 SpeechLibObj_ISpeechAudioStatus *audioStatus)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecognizerStatus_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH audioStatus__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (audioStatus)
		*audioStatus = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecognizerStatus,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetAudioStatus_ (__vtblIFacePtr,
	                                                     &audioStatus__AutoType));
	

	if (audioStatus)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (audioStatus__AutoType,
		                                             &SpeechLib_IID_ISpeechAudioStatus,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, audioStatus));
		audioStatus__AutoType = 0;
		}

Error:
	if (audioStatus__AutoType)
		audioStatus__AutoType->lpVtbl->Release (audioStatus__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (audioStatus)
			{
			CA_DiscardObjHandle (*audioStatus);
			*audioStatus = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecognizerStatus,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecognizerStatusGetCurrentStreamPosition (CAObjHandle objectHandle,
                                                                           ERRORINFO *errorInfo,
                                                                           VARIANT *pCurrentStreamPos)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecognizerStatus_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	VARIANT pCurrentStreamPos__Temp;

	if (pCurrentStreamPos)
		CA_VariantSetEmpty (pCurrentStreamPos);
	CA_VariantSetEmpty (&pCurrentStreamPos__Temp);

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecognizerStatus,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetCurrentStreamPosition_ (__vtblIFacePtr,
	                                                               &pCurrentStreamPos__Temp));

	if (pCurrentStreamPos)
		{
		*pCurrentStreamPos = pCurrentStreamPos__Temp;
		CA_VariantSetEmpty (&pCurrentStreamPos__Temp);
		}

Error:
	CA_VariantClear (&pCurrentStreamPos__Temp);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (pCurrentStreamPos)
			CA_VariantClear (pCurrentStreamPos);
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecognizerStatus,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecognizerStatusGetCurrentStreamNumber (CAObjHandle objectHandle,
                                                                         ERRORINFO *errorInfo,
                                                                         long *streamNumber)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecognizerStatus_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long streamNumber__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecognizerStatus,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetCurrentStreamNumber_ (__vtblIFacePtr,
	                                                             &streamNumber__Temp));

	if (streamNumber)
		{
		*streamNumber = streamNumber__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecognizerStatus,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecognizerStatusGetNumberOfActiveRules (CAObjHandle objectHandle,
                                                                         ERRORINFO *errorInfo,
                                                                         long *numberOfActiveRules)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecognizerStatus_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long numberOfActiveRules__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecognizerStatus,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetNumberOfActiveRules_ (__vtblIFacePtr,
	                                                             &numberOfActiveRules__Temp));

	if (numberOfActiveRules)
		{
		*numberOfActiveRules = numberOfActiveRules__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecognizerStatus,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecognizerStatusGetClsidEngine (CAObjHandle objectHandle,
                                                                 ERRORINFO *errorInfo,
                                                                 char **clsidEngine)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecognizerStatus_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR clsidEngine__AutoType = 0;

	if (clsidEngine)
		*clsidEngine = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecognizerStatus,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetClsidEngine_ (__vtblIFacePtr,
	                                                     &clsidEngine__AutoType));

	if (clsidEngine)
		__caErrChk (CA_BSTRGetCString (clsidEngine__AutoType, clsidEngine));

Error:
	CA_FreeBSTR (clsidEngine__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (clsidEngine)
			{
			CA_FreeMemory (*clsidEngine);
			*clsidEngine = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecognizerStatus,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecognizerStatusGetSupportedLanguages (CAObjHandle objectHandle,
                                                                        ERRORINFO *errorInfo,
                                                                        VARIANT *supportedLanguages)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecognizerStatus_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	VARIANT supportedLanguages__Temp;

	if (supportedLanguages)
		CA_VariantSetEmpty (supportedLanguages);
	CA_VariantSetEmpty (&supportedLanguages__Temp);

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecognizerStatus,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetSupportedLanguages_ (__vtblIFacePtr,
	                                                            &supportedLanguages__Temp));

	if (supportedLanguages)
		{
		*supportedLanguages = supportedLanguages__Temp;
		CA_VariantSetEmpty (&supportedLanguages__Temp);
		}

Error:
	CA_VariantClear (&supportedLanguages__Temp);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (supportedLanguages)
			CA_VariantClear (supportedLanguages);
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecognizerStatus,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoGrammarGetId (CAObjHandle objectHandle,
                                                   ERRORINFO *errorInfo,
                                                   VARIANT *id)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoGrammar_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	VARIANT id__Temp;

	if (id)
		CA_VariantSetEmpty (id);
	CA_VariantSetEmpty (&id__Temp);

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoGrammar,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetId_ (__vtblIFacePtr, &id__Temp));

	if (id)
		{
		*id = id__Temp;
		CA_VariantSetEmpty (&id__Temp);
		}

Error:
	CA_VariantClear (&id__Temp);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (id)
			CA_VariantClear (id);
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoGrammar,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoGrammarGetRecoContext (CAObjHandle objectHandle,
                                                            ERRORINFO *errorInfo,
                                                            SpeechLibObj_ISpeechRecoContext *recoContext)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoGrammar_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH recoContext__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (recoContext)
		*recoContext = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoGrammar,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetRecoContext_ (__vtblIFacePtr,
	                                                     &recoContext__AutoType));
	

	if (recoContext)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (recoContext__AutoType,
		                                             &SpeechLib_IID_ISpeechRecoContext,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, recoContext));
		recoContext__AutoType = 0;
		}

Error:
	if (recoContext__AutoType)
		recoContext__AutoType->lpVtbl->Release (recoContext__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (recoContext)
			{
			CA_DiscardObjHandle (*recoContext);
			*recoContext = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoGrammar,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoGrammarSetState (CAObjHandle objectHandle,
                                                      ERRORINFO *errorInfo,
                                                      enum SpeechLibEnum_SpeechGrammarState state)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoGrammar_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoGrammar,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetState_ (__vtblIFacePtr, state));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoGrammar,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoGrammarGetState (CAObjHandle objectHandle,
                                                      ERRORINFO *errorInfo,
                                                      enum SpeechLibEnum_SpeechGrammarState *state)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoGrammar_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long state__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoGrammar,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetState_ (__vtblIFacePtr,
	                                               (long *)&state__Temp));

	if (state)
		{
		*state = state__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoGrammar,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoGrammarGetRules (CAObjHandle objectHandle,
                                                      ERRORINFO *errorInfo,
                                                      SpeechLibObj_ISpeechGrammarRules *rules)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoGrammar_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH rules__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (rules)
		*rules = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoGrammar,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetRules_ (__vtblIFacePtr,
	                                               &rules__AutoType));
	

	if (rules)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (rules__AutoType,
		                                             &SpeechLib_IID_ISpeechGrammarRules,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, rules));
		rules__AutoType = 0;
		}

Error:
	if (rules__AutoType)
		rules__AutoType->lpVtbl->Release (rules__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (rules)
			{
			CA_DiscardObjHandle (*rules);
			*rules = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoGrammar,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoGrammarReset (CAObjHandle objectHandle,
                                                   ERRORINFO *errorInfo,
                                                   long newLanguage)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoGrammar_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoGrammar,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Reset_ (__vtblIFacePtr, newLanguage));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoGrammar,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoGrammarCmdLoadFromFile (CAObjHandle objectHandle,
                                                             ERRORINFO *errorInfo,
                                                             const char *fileName,
                                                             enum SpeechLibEnum_SpeechLoadOption loadOption)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoGrammar_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR fileName__AutoType = 0;

	__caErrChk (CA_CStringToBSTR (fileName, &fileName__AutoType));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoGrammar,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->CmdLoadFromFile_ (__vtblIFacePtr,
	                                                      fileName__AutoType,
	                                                      loadOption));

Error:
	CA_FreeBSTR (fileName__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoGrammar,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoGrammarCmdLoadFromObject (CAObjHandle objectHandle,
                                                               ERRORINFO *errorInfo,
                                                               const char *classId,
                                                               const char *grammarName,
                                                               enum SpeechLibEnum_SpeechLoadOption loadOption)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoGrammar_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR classId__AutoType = 0;
	BSTR grammarName__AutoType = 0;

	__caErrChk (CA_CStringToBSTR (classId, &classId__AutoType));
	__caErrChk (CA_CStringToBSTR (grammarName, &grammarName__AutoType));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoGrammar,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->CmdLoadFromObject_ (__vtblIFacePtr,
	                                                        classId__AutoType,
	                                                        grammarName__AutoType,
	                                                        loadOption));

Error:
	CA_FreeBSTR (classId__AutoType);
	CA_FreeBSTR (grammarName__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoGrammar,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoGrammarCmdLoadFromResource (CAObjHandle objectHandle,
                                                                 ERRORINFO *errorInfo,
                                                                 long hModule,
                                                                 VARIANT resourceName,
                                                                 VARIANT resourceType,
                                                                 long languageId,
                                                                 enum SpeechLibEnum_SpeechLoadOption loadOption)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoGrammar_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoGrammar,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->CmdLoadFromResource_ (__vtblIFacePtr,
	                                                          hModule,
	                                                          resourceName,
	                                                          resourceType,
	                                                          languageId,
	                                                          loadOption));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoGrammar,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoGrammarCmdLoadFromMemory (CAObjHandle objectHandle,
                                                               ERRORINFO *errorInfo,
                                                               VARIANT grammarData,
                                                               enum SpeechLibEnum_SpeechLoadOption loadOption)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoGrammar_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoGrammar,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->CmdLoadFromMemory_ (__vtblIFacePtr,
	                                                        grammarData,
	                                                        loadOption));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoGrammar,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoGrammarCmdLoadFromProprietaryGrammar (CAObjHandle objectHandle,
                                                                           ERRORINFO *errorInfo,
                                                                           const char *proprietaryGuid,
                                                                           const char *proprietaryString,
                                                                           VARIANT proprietaryData,
                                                                           enum SpeechLibEnum_SpeechLoadOption loadOption)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoGrammar_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR proprietaryGuid__AutoType = 0;
	BSTR proprietaryString__AutoType = 0;

	__caErrChk (CA_CStringToBSTR (proprietaryGuid, &proprietaryGuid__AutoType));
	__caErrChk (CA_CStringToBSTR (proprietaryString,
	                              &proprietaryString__AutoType));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoGrammar,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->CmdLoadFromProprietaryGrammar_ (__vtblIFacePtr,
	                                                                    proprietaryGuid__AutoType,
	                                                                    proprietaryString__AutoType,
	                                                                    proprietaryData,
	                                                                    loadOption));

Error:
	CA_FreeBSTR (proprietaryGuid__AutoType);
	CA_FreeBSTR (proprietaryString__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoGrammar,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoGrammarCmdSetRuleState (CAObjHandle objectHandle,
                                                             ERRORINFO *errorInfo,
                                                             const char *name,
                                                             enum SpeechLibEnum_SpeechRuleState state)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoGrammar_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR name__AutoType = 0;

	__caErrChk (CA_CStringToBSTR (name, &name__AutoType));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoGrammar,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->CmdSetRuleState_ (__vtblIFacePtr,
	                                                      name__AutoType,
	                                                      state));

Error:
	CA_FreeBSTR (name__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoGrammar,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoGrammarCmdSetRuleIdState (CAObjHandle objectHandle,
                                                               ERRORINFO *errorInfo,
                                                               long ruleId,
                                                               enum SpeechLibEnum_SpeechRuleState state)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoGrammar_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoGrammar,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->CmdSetRuleIdState_ (__vtblIFacePtr,
	                                                        ruleId, state));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoGrammar,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoGrammarDictationLoad (CAObjHandle objectHandle,
                                                           ERRORINFO *errorInfo,
                                                           const char *topicName,
                                                           enum SpeechLibEnum_SpeechLoadOption loadOption)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoGrammar_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR topicName__AutoType = 0;

	__caErrChk (CA_CStringToBSTR (topicName, &topicName__AutoType));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoGrammar,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->DictationLoad_ (__vtblIFacePtr,
	                                                    topicName__AutoType,
	                                                    loadOption));

Error:
	CA_FreeBSTR (topicName__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoGrammar,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoGrammarDictationUnload (CAObjHandle objectHandle,
                                                             ERRORINFO *errorInfo)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoGrammar_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoGrammar,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->DictationUnload_ (__vtblIFacePtr));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoGrammar,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoGrammarDictationSetState (CAObjHandle objectHandle,
                                                               ERRORINFO *errorInfo,
                                                               enum SpeechLibEnum_SpeechRuleState state)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoGrammar_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoGrammar,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->DictationSetState_ (__vtblIFacePtr,
	                                                        state));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoGrammar,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoGrammarSetWordSequenceData (CAObjHandle objectHandle,
                                                                 ERRORINFO *errorInfo,
                                                                 const char *text,
                                                                 long textLength,
                                                                 SpeechLibObj_ISpeechTextSelectionInformation info)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoGrammar_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR text__AutoType = 0;
	LPDISPATCH info__AutoType = 0;

	__caErrChk (CA_CStringToBSTR (text, &text__AutoType));
	if (info)
		{
		__caErrChk (CA_GetInterfaceFromObjHandle (info,
	                                          &SpeechLib_IID_ISpeechTextSelectionInformation,
	                                          1, &info__AutoType, NULL));
		}

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoGrammar,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetWordSequenceData_ (__vtblIFacePtr,
	                                                          text__AutoType,
	                                                          textLength,
	                                                          info__AutoType));

Error:
	CA_FreeBSTR (text__AutoType);
	if (info__AutoType)
		info__AutoType->lpVtbl->Release (info__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoGrammar,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoGrammarSetTextSelection (CAObjHandle objectHandle,
                                                              ERRORINFO *errorInfo,
                                                              SpeechLibObj_ISpeechTextSelectionInformation info)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoGrammar_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH info__AutoType = 0;

	if (info)
		{
		__caErrChk (CA_GetInterfaceFromObjHandle (info,
	                                          &SpeechLib_IID_ISpeechTextSelectionInformation,
	                                          1, &info__AutoType, NULL));
		}

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoGrammar,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetTextSelection_ (__vtblIFacePtr,
	                                                       info__AutoType));

Error:
	if (info__AutoType)
		info__AutoType->lpVtbl->Release (info__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoGrammar,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoGrammarIsPronounceable (CAObjHandle objectHandle,
                                                             ERRORINFO *errorInfo,
                                                             const char *word,
                                                             enum SpeechLibEnum_SpeechWordPronounceable *wordPronounceable)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoGrammar_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR word__AutoType = 0;
	long wordPronounceable__Temp;

	__caErrChk (CA_CStringToBSTR (word, &word__AutoType));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoGrammar,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->IsPronounceable_ (__vtblIFacePtr,
	                                                      word__AutoType,
	                                                      (long *)&wordPronounceable__Temp));

	if (wordPronounceable)
		{
		*wordPronounceable = wordPronounceable__Temp;
		}

Error:
	CA_FreeBSTR (word__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoGrammar,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechGrammarRulesGetCount (CAObjHandle objectHandle,
                                                       ERRORINFO *errorInfo,
                                                       long *count)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechGrammarRules_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long count__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechGrammarRules,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetCount_ (__vtblIFacePtr,
	                                               &count__Temp));

	if (count)
		{
		*count = count__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechGrammarRules,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechGrammarRulesFindRule (CAObjHandle objectHandle,
                                                       ERRORINFO *errorInfo,
                                                       VARIANT ruleNameOrId,
                                                       SpeechLibObj_ISpeechGrammarRule *rule)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechGrammarRules_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH rule__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (rule)
		*rule = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechGrammarRules,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->FindRule_ (__vtblIFacePtr,
	                                               ruleNameOrId,
	                                               &rule__AutoType));
	

	if (rule)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (rule__AutoType,
		                                             &SpeechLib_IID_ISpeechGrammarRule,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, rule));
		rule__AutoType = 0;
		}

Error:
	if (rule__AutoType)
		rule__AutoType->lpVtbl->Release (rule__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (rule)
			{
			CA_DiscardObjHandle (*rule);
			*rule = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechGrammarRules,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechGrammarRulesItem (CAObjHandle objectHandle,
                                                   ERRORINFO *errorInfo,
                                                   long index,
                                                   SpeechLibObj_ISpeechGrammarRule *rule)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechGrammarRules_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH rule__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (rule)
		*rule = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechGrammarRules,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Item_ (__vtblIFacePtr, index,
	                                           &rule__AutoType));
	

	if (rule)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (rule__AutoType,
		                                             &SpeechLib_IID_ISpeechGrammarRule,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, rule));
		rule__AutoType = 0;
		}

Error:
	if (rule__AutoType)
		rule__AutoType->lpVtbl->Release (rule__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (rule)
			{
			CA_DiscardObjHandle (*rule);
			*rule = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechGrammarRules,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechGrammarRulesGet_NewEnum (CAObjHandle objectHandle,
                                                          ERRORINFO *errorInfo,
                                                          LPUNKNOWN *enumVARIANT)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechGrammarRules_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN enumVARIANT__Temp = 0;

	if (enumVARIANT)
		*enumVARIANT = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechGrammarRules,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Get_NewEnum_ (__vtblIFacePtr,
	                                                  &enumVARIANT__Temp));

	if (enumVARIANT)
		{
		*enumVARIANT = enumVARIANT__Temp;
		enumVARIANT__Temp = 0;
		}

Error:
	if (enumVARIANT__Temp)
		enumVARIANT__Temp->lpVtbl->Release (enumVARIANT__Temp);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (enumVARIANT)
			{
			if (*enumVARIANT)
				(*enumVARIANT)->lpVtbl->Release (*enumVARIANT);
			*enumVARIANT = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechGrammarRules,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechGrammarRulesGetDynamic (CAObjHandle objectHandle,
                                                         ERRORINFO *errorInfo,
                                                         VBOOL *dynamic)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechGrammarRules_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	VBOOL dynamic__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechGrammarRules,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetDynamic_ (__vtblIFacePtr,
	                                                 &dynamic__Temp));

	if (dynamic)
		{
		*dynamic = dynamic__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechGrammarRules,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechGrammarRulesAdd (CAObjHandle objectHandle,
                                                  ERRORINFO *errorInfo,
                                                  const char *ruleName,
                                                  enum SpeechLibEnum_SpeechRuleAttributes attributes,
                                                  long ruleId,
                                                  SpeechLibObj_ISpeechGrammarRule *rule)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechGrammarRules_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR ruleName__AutoType = 0;
	LPDISPATCH rule__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (rule)
		*rule = 0;

	__caErrChk (CA_CStringToBSTR (ruleName, &ruleName__AutoType));
	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechGrammarRules,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Add_ (__vtblIFacePtr,
	                                          ruleName__AutoType, attributes,
	                                          ruleId, &rule__AutoType));
	

	if (rule)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (rule__AutoType,
		                                             &SpeechLib_IID_ISpeechGrammarRule,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, rule));
		rule__AutoType = 0;
		}

Error:
	CA_FreeBSTR (ruleName__AutoType);
	if (rule__AutoType)
		rule__AutoType->lpVtbl->Release (rule__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (rule)
			{
			CA_DiscardObjHandle (*rule);
			*rule = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechGrammarRules,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechGrammarRulesCommit (CAObjHandle objectHandle,
                                                     ERRORINFO *errorInfo)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechGrammarRules_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechGrammarRules,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Commit_ (__vtblIFacePtr));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechGrammarRules,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechGrammarRulesCommitAndSave (CAObjHandle objectHandle,
                                                            ERRORINFO *errorInfo,
                                                            char **errorText,
                                                            VARIANT *saveStream)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechGrammarRules_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR errorText__AutoType = 0;
	VARIANT saveStream__Temp;

	if (errorText)
		*errorText = 0;
	if (saveStream)
		CA_VariantSetEmpty (saveStream);
	CA_VariantSetEmpty (&saveStream__Temp);

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechGrammarRules,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->CommitAndSave_ (__vtblIFacePtr,
	                                                    &errorText__AutoType,
	                                                    &saveStream__Temp));

	if (errorText)
		__caErrChk (CA_BSTRGetCString (errorText__AutoType, errorText));
	if (saveStream)
		{
		*saveStream = saveStream__Temp;
		CA_VariantSetEmpty (&saveStream__Temp);
		}

Error:
	CA_FreeBSTR (errorText__AutoType);
	CA_VariantClear (&saveStream__Temp);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (errorText)
			{
			CA_FreeMemory (*errorText);
			*errorText = 0;
			}
		if (saveStream)
			CA_VariantClear (saveStream);
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechGrammarRules,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechGrammarRuleGetAttributes (CAObjHandle objectHandle,
                                                           ERRORINFO *errorInfo,
                                                           enum SpeechLibEnum_SpeechRuleAttributes *attributes)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechGrammarRule_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long attributes__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechGrammarRule,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetAttributes_ (__vtblIFacePtr,
	                                                    (long *)&attributes__Temp));

	if (attributes)
		{
		*attributes = attributes__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechGrammarRule,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechGrammarRuleGetInitialState (CAObjHandle objectHandle,
                                                             ERRORINFO *errorInfo,
                                                             SpeechLibObj_ISpeechGrammarRuleState *state)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechGrammarRule_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH state__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (state)
		*state = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechGrammarRule,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetInitialState_ (__vtblIFacePtr,
	                                                      &state__AutoType));
	

	if (state)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (state__AutoType,
		                                             &SpeechLib_IID_ISpeechGrammarRuleState,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, state));
		state__AutoType = 0;
		}

Error:
	if (state__AutoType)
		state__AutoType->lpVtbl->Release (state__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (state)
			{
			CA_DiscardObjHandle (*state);
			*state = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechGrammarRule,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechGrammarRuleGetName (CAObjHandle objectHandle,
                                                     ERRORINFO *errorInfo,
                                                     char **name)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechGrammarRule_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR name__AutoType = 0;

	if (name)
		*name = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechGrammarRule,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetName_ (__vtblIFacePtr,
	                                              &name__AutoType));

	if (name)
		__caErrChk (CA_BSTRGetCString (name__AutoType, name));

Error:
	CA_FreeBSTR (name__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (name)
			{
			CA_FreeMemory (*name);
			*name = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechGrammarRule,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechGrammarRuleGetId (CAObjHandle objectHandle,
                                                   ERRORINFO *errorInfo,
                                                   long *id)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechGrammarRule_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long id__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechGrammarRule,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetId_ (__vtblIFacePtr, &id__Temp));

	if (id)
		{
		*id = id__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechGrammarRule,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechGrammarRuleClear (CAObjHandle objectHandle,
                                                   ERRORINFO *errorInfo)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechGrammarRule_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechGrammarRule,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Clear_ (__vtblIFacePtr));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechGrammarRule,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechGrammarRuleAddResource (CAObjHandle objectHandle,
                                                         ERRORINFO *errorInfo,
                                                         const char *resourceName,
                                                         const char *resourceValue)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechGrammarRule_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR resourceName__AutoType = 0;
	BSTR resourceValue__AutoType = 0;

	__caErrChk (CA_CStringToBSTR (resourceName, &resourceName__AutoType));
	__caErrChk (CA_CStringToBSTR (resourceValue, &resourceValue__AutoType));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechGrammarRule,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->AddResource_ (__vtblIFacePtr,
	                                                  resourceName__AutoType,
	                                                  resourceValue__AutoType));

Error:
	CA_FreeBSTR (resourceName__AutoType);
	CA_FreeBSTR (resourceValue__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechGrammarRule,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechGrammarRuleAddState (CAObjHandle objectHandle,
                                                      ERRORINFO *errorInfo,
                                                      SpeechLibObj_ISpeechGrammarRuleState *state)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechGrammarRule_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH state__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (state)
		*state = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechGrammarRule,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->AddState_ (__vtblIFacePtr,
	                                               &state__AutoType));
	

	if (state)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (state__AutoType,
		                                             &SpeechLib_IID_ISpeechGrammarRuleState,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, state));
		state__AutoType = 0;
		}

Error:
	if (state__AutoType)
		state__AutoType->lpVtbl->Release (state__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (state)
			{
			CA_DiscardObjHandle (*state);
			*state = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechGrammarRule,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechGrammarRuleStateGetRule (CAObjHandle objectHandle,
                                                          ERRORINFO *errorInfo,
                                                          SpeechLibObj_ISpeechGrammarRule *rule)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechGrammarRuleState_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH rule__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (rule)
		*rule = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechGrammarRuleState,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetRule_ (__vtblIFacePtr,
	                                              &rule__AutoType));
	

	if (rule)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (rule__AutoType,
		                                             &SpeechLib_IID_ISpeechGrammarRule,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, rule));
		rule__AutoType = 0;
		}

Error:
	if (rule__AutoType)
		rule__AutoType->lpVtbl->Release (rule__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (rule)
			{
			CA_DiscardObjHandle (*rule);
			*rule = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechGrammarRuleState,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechGrammarRuleStateGetTransitions (CAObjHandle objectHandle,
                                                                 ERRORINFO *errorInfo,
                                                                 SpeechLibObj_ISpeechGrammarRuleStateTransitions *transitions)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechGrammarRuleState_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH transitions__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (transitions)
		*transitions = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechGrammarRuleState,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetTransitions_ (__vtblIFacePtr,
	                                                     &transitions__AutoType));
	

	if (transitions)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (transitions__AutoType,
		                                             &SpeechLib_IID_ISpeechGrammarRuleStateTransitions,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, transitions));
		transitions__AutoType = 0;
		}

Error:
	if (transitions__AutoType)
		transitions__AutoType->lpVtbl->Release (transitions__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (transitions)
			{
			CA_DiscardObjHandle (*transitions);
			*transitions = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechGrammarRuleState,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechGrammarRuleStateAddWordTransition (CAObjHandle objectHandle,
                                                                    ERRORINFO *errorInfo,
                                                                    SpeechLibObj_ISpeechGrammarRuleState destState,
                                                                    const char *words,
                                                                    const char *separators,
                                                                    enum SpeechLibEnum_SpeechGrammarWordType type,
                                                                    const char *propertyName,
                                                                    long propertyId,
                                                                    VARIANT propertyValue,
                                                                    float weight)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechGrammarRuleState_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH destState__AutoType = 0;
	BSTR words__AutoType = 0;
	BSTR separators__AutoType = 0;
	BSTR propertyName__AutoType = 0;

	if (destState)
		{
		__caErrChk (CA_GetInterfaceFromObjHandle (destState,
	                                          &SpeechLib_IID_ISpeechGrammarRuleState,
	                                          1, &destState__AutoType, NULL));
		}
	__caErrChk (CA_CStringToBSTR (words, &words__AutoType));
	__caErrChk (CA_CStringToBSTR (separators, &separators__AutoType));
	__caErrChk (CA_CStringToBSTR (propertyName, &propertyName__AutoType));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechGrammarRuleState,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->AddWordTransition_ (__vtblIFacePtr,
	                                                        destState__AutoType,
	                                                        words__AutoType,
	                                                        separators__AutoType,
	                                                        type,
	                                                        propertyName__AutoType,
	                                                        propertyId,
	                                                        &propertyValue,
	                                                        weight));

Error:
	if (destState__AutoType)
		destState__AutoType->lpVtbl->Release (destState__AutoType);
	CA_FreeBSTR (words__AutoType);
	CA_FreeBSTR (separators__AutoType);
	CA_FreeBSTR (propertyName__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechGrammarRuleState,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechGrammarRuleStateAddRuleTransition (CAObjHandle objectHandle,
                                                                    ERRORINFO *errorInfo,
                                                                    SpeechLibObj_ISpeechGrammarRuleState destinationState,
                                                                    SpeechLibObj_ISpeechGrammarRule rule,
                                                                    const char *propertyName,
                                                                    long propertyId,
                                                                    VARIANT propertyValue,
                                                                    float weight)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechGrammarRuleState_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH destinationState__AutoType = 0;
	LPDISPATCH rule__AutoType = 0;
	BSTR propertyName__AutoType = 0;

	if (destinationState)
		{
		__caErrChk (CA_GetInterfaceFromObjHandle (destinationState,
	                                          &SpeechLib_IID_ISpeechGrammarRuleState,
	                                          1, &destinationState__AutoType,
	                                          NULL));
		}
	if (rule)
		{
		__caErrChk (CA_GetInterfaceFromObjHandle (rule,
	                                          &SpeechLib_IID_ISpeechGrammarRule,
	                                          1, &rule__AutoType, NULL));
		}
	__caErrChk (CA_CStringToBSTR (propertyName, &propertyName__AutoType));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechGrammarRuleState,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->AddRuleTransition_ (__vtblIFacePtr,
	                                                        destinationState__AutoType,
	                                                        rule__AutoType,
	                                                        propertyName__AutoType,
	                                                        propertyId,
	                                                        &propertyValue,
	                                                        weight));

Error:
	if (destinationState__AutoType)
		destinationState__AutoType->lpVtbl->Release (destinationState__AutoType);
	if (rule__AutoType)
		rule__AutoType->lpVtbl->Release (rule__AutoType);
	CA_FreeBSTR (propertyName__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechGrammarRuleState,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechGrammarRuleStateAddSpecialTransition (CAObjHandle objectHandle,
                                                                       ERRORINFO *errorInfo,
                                                                       SpeechLibObj_ISpeechGrammarRuleState destinationState,
                                                                       enum SpeechLibEnum_SpeechSpecialTransitionType type,
                                                                       const char *propertyName,
                                                                       long propertyId,
                                                                       VARIANT propertyValue,
                                                                       float weight)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechGrammarRuleState_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH destinationState__AutoType = 0;
	BSTR propertyName__AutoType = 0;

	if (destinationState)
		{
		__caErrChk (CA_GetInterfaceFromObjHandle (destinationState,
	                                          &SpeechLib_IID_ISpeechGrammarRuleState,
	                                          1, &destinationState__AutoType,
	                                          NULL));
		}
	__caErrChk (CA_CStringToBSTR (propertyName, &propertyName__AutoType));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechGrammarRuleState,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->AddSpecialTransition_ (__vtblIFacePtr,
	                                                           destinationState__AutoType,
	                                                           type,
	                                                           propertyName__AutoType,
	                                                           propertyId,
	                                                           &propertyValue,
	                                                           weight));

Error:
	if (destinationState__AutoType)
		destinationState__AutoType->lpVtbl->Release (destinationState__AutoType);
	CA_FreeBSTR (propertyName__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechGrammarRuleState,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechGrammarRuleStateTransitionsGetCount (CAObjHandle objectHandle,
                                                                      ERRORINFO *errorInfo,
                                                                      long *count)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechGrammarRuleStateTransitions_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long count__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechGrammarRuleStateTransitions,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetCount_ (__vtblIFacePtr,
	                                               &count__Temp));

	if (count)
		{
		*count = count__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle,
	                    &SpeechLib_IID_ISpeechGrammarRuleStateTransitions,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechGrammarRuleStateTransitionsItem (CAObjHandle objectHandle,
                                                                  ERRORINFO *errorInfo,
                                                                  long index,
                                                                  SpeechLibObj_ISpeechGrammarRuleStateTransition *transition)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechGrammarRuleStateTransitions_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH transition__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (transition)
		*transition = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechGrammarRuleStateTransitions,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Item_ (__vtblIFacePtr, index,
	                                           &transition__AutoType));
	

	if (transition)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (transition__AutoType,
		                                             &SpeechLib_IID_ISpeechGrammarRuleStateTransition,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, transition));
		transition__AutoType = 0;
		}

Error:
	if (transition__AutoType)
		transition__AutoType->lpVtbl->Release (transition__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (transition)
			{
			CA_DiscardObjHandle (*transition);
			*transition = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle,
	                    &SpeechLib_IID_ISpeechGrammarRuleStateTransitions,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechGrammarRuleStateTransitionsGet_NewEnum (CAObjHandle objectHandle,
                                                                         ERRORINFO *errorInfo,
                                                                         LPUNKNOWN *enumVARIANT)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechGrammarRuleStateTransitions_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN enumVARIANT__Temp = 0;

	if (enumVARIANT)
		*enumVARIANT = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechGrammarRuleStateTransitions,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Get_NewEnum_ (__vtblIFacePtr,
	                                                  &enumVARIANT__Temp));

	if (enumVARIANT)
		{
		*enumVARIANT = enumVARIANT__Temp;
		enumVARIANT__Temp = 0;
		}

Error:
	if (enumVARIANT__Temp)
		enumVARIANT__Temp->lpVtbl->Release (enumVARIANT__Temp);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (enumVARIANT)
			{
			if (*enumVARIANT)
				(*enumVARIANT)->lpVtbl->Release (*enumVARIANT);
			*enumVARIANT = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle,
	                    &SpeechLib_IID_ISpeechGrammarRuleStateTransitions,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechGrammarRuleStateTransitionGetType (CAObjHandle objectHandle,
                                                                    ERRORINFO *errorInfo,
                                                                    enum SpeechLibEnum_SpeechGrammarRuleStateTransitionType *type)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechGrammarRuleStateTransition_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long type__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechGrammarRuleStateTransition,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetType_ (__vtblIFacePtr,
	                                              (long *)&type__Temp));

	if (type)
		{
		*type = type__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle,
	                    &SpeechLib_IID_ISpeechGrammarRuleStateTransition,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechGrammarRuleStateTransitionGetText (CAObjHandle objectHandle,
                                                                    ERRORINFO *errorInfo,
                                                                    char **text)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechGrammarRuleStateTransition_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR text__AutoType = 0;

	if (text)
		*text = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechGrammarRuleStateTransition,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetText_ (__vtblIFacePtr,
	                                              &text__AutoType));

	if (text)
		__caErrChk (CA_BSTRGetCString (text__AutoType, text));

Error:
	CA_FreeBSTR (text__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (text)
			{
			CA_FreeMemory (*text);
			*text = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle,
	                    &SpeechLib_IID_ISpeechGrammarRuleStateTransition,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechGrammarRuleStateTransitionGetRule (CAObjHandle objectHandle,
                                                                    ERRORINFO *errorInfo,
                                                                    SpeechLibObj_ISpeechGrammarRule *rule)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechGrammarRuleStateTransition_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH rule__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (rule)
		*rule = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechGrammarRuleStateTransition,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetRule_ (__vtblIFacePtr,
	                                              &rule__AutoType));
	

	if (rule)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (rule__AutoType,
		                                             &SpeechLib_IID_ISpeechGrammarRule,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, rule));
		rule__AutoType = 0;
		}

Error:
	if (rule__AutoType)
		rule__AutoType->lpVtbl->Release (rule__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (rule)
			{
			CA_DiscardObjHandle (*rule);
			*rule = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle,
	                    &SpeechLib_IID_ISpeechGrammarRuleStateTransition,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechGrammarRuleStateTransitionGetWeight (CAObjHandle objectHandle,
                                                                      ERRORINFO *errorInfo,
                                                                      VARIANT *weight)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechGrammarRuleStateTransition_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	VARIANT weight__Temp;

	if (weight)
		CA_VariantSetEmpty (weight);
	CA_VariantSetEmpty (&weight__Temp);

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechGrammarRuleStateTransition,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetWeight_ (__vtblIFacePtr,
	                                                &weight__Temp));

	if (weight)
		{
		*weight = weight__Temp;
		CA_VariantSetEmpty (&weight__Temp);
		}

Error:
	CA_VariantClear (&weight__Temp);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (weight)
			CA_VariantClear (weight);
		}
	CA_FillErrorInfoEx (objectHandle,
	                    &SpeechLib_IID_ISpeechGrammarRuleStateTransition,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechGrammarRuleStateTransitionGetPropertyName (CAObjHandle objectHandle,
                                                                            ERRORINFO *errorInfo,
                                                                            char **propertyName)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechGrammarRuleStateTransition_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR propertyName__AutoType = 0;

	if (propertyName)
		*propertyName = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechGrammarRuleStateTransition,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetPropertyName_ (__vtblIFacePtr,
	                                                      &propertyName__AutoType));

	if (propertyName)
		__caErrChk (CA_BSTRGetCString (propertyName__AutoType, propertyName));

Error:
	CA_FreeBSTR (propertyName__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (propertyName)
			{
			CA_FreeMemory (*propertyName);
			*propertyName = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle,
	                    &SpeechLib_IID_ISpeechGrammarRuleStateTransition,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechGrammarRuleStateTransitionGetPropertyId (CAObjHandle objectHandle,
                                                                          ERRORINFO *errorInfo,
                                                                          long *propertyId)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechGrammarRuleStateTransition_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long propertyId__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechGrammarRuleStateTransition,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetPropertyId_ (__vtblIFacePtr,
	                                                    &propertyId__Temp));

	if (propertyId)
		{
		*propertyId = propertyId__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle,
	                    &SpeechLib_IID_ISpeechGrammarRuleStateTransition,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechGrammarRuleStateTransitionGetPropertyValue (CAObjHandle objectHandle,
                                                                             ERRORINFO *errorInfo,
                                                                             VARIANT *propertyValue)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechGrammarRuleStateTransition_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	VARIANT propertyValue__Temp;

	if (propertyValue)
		CA_VariantSetEmpty (propertyValue);
	CA_VariantSetEmpty (&propertyValue__Temp);

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechGrammarRuleStateTransition,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetPropertyValue_ (__vtblIFacePtr,
	                                                       &propertyValue__Temp));

	if (propertyValue)
		{
		*propertyValue = propertyValue__Temp;
		CA_VariantSetEmpty (&propertyValue__Temp);
		}

Error:
	CA_VariantClear (&propertyValue__Temp);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (propertyValue)
			CA_VariantClear (propertyValue);
		}
	CA_FillErrorInfoEx (objectHandle,
	                    &SpeechLib_IID_ISpeechGrammarRuleStateTransition,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechGrammarRuleStateTransitionGetNextState (CAObjHandle objectHandle,
                                                                         ERRORINFO *errorInfo,
                                                                         SpeechLibObj_ISpeechGrammarRuleState *nextState)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechGrammarRuleStateTransition_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH nextState__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (nextState)
		*nextState = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechGrammarRuleStateTransition,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetNextState_ (__vtblIFacePtr,
	                                                   &nextState__AutoType));
	

	if (nextState)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (nextState__AutoType,
		                                             &SpeechLib_IID_ISpeechGrammarRuleState,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, nextState));
		nextState__AutoType = 0;
		}

Error:
	if (nextState__AutoType)
		nextState__AutoType->lpVtbl->Release (nextState__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (nextState)
			{
			CA_DiscardObjHandle (*nextState);
			*nextState = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle,
	                    &SpeechLib_IID_ISpeechGrammarRuleStateTransition,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoResultGetRecoContext (CAObjHandle objectHandle,
                                                           ERRORINFO *errorInfo,
                                                           SpeechLibObj_ISpeechRecoContext *recoContext)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoResult_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH recoContext__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (recoContext)
		*recoContext = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoResult,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetRecoContext_ (__vtblIFacePtr,
	                                                     &recoContext__AutoType));
	

	if (recoContext)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (recoContext__AutoType,
		                                             &SpeechLib_IID_ISpeechRecoContext,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, recoContext));
		recoContext__AutoType = 0;
		}

Error:
	if (recoContext__AutoType)
		recoContext__AutoType->lpVtbl->Release (recoContext__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (recoContext)
			{
			CA_DiscardObjHandle (*recoContext);
			*recoContext = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoResult,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoResultGetTimes (CAObjHandle objectHandle,
                                                     ERRORINFO *errorInfo,
                                                     SpeechLibObj_ISpeechRecoResultTimes *times)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoResult_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH times__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (times)
		*times = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoResult,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetTimes_ (__vtblIFacePtr,
	                                               &times__AutoType));
	

	if (times)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (times__AutoType,
		                                             &SpeechLib_IID_ISpeechRecoResultTimes,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, times));
		times__AutoType = 0;
		}

Error:
	if (times__AutoType)
		times__AutoType->lpVtbl->Release (times__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (times)
			{
			CA_DiscardObjHandle (*times);
			*times = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoResult,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoResultSetByRefAudioFormat (CAObjHandle objectHandle,
                                                                ERRORINFO *errorInfo,
                                                                SpeechLibObj_ISpeechAudioFormat format)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoResult_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH format__AutoType = 0;

	if (format)
		{
		__caErrChk (CA_GetInterfaceFromObjHandle (format,
	                                          &SpeechLib_IID_ISpeechAudioFormat,
	                                          1, &format__AutoType, NULL));
		}

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoResult,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetByRefAudioFormat_ (__vtblIFacePtr,
	                                                          format__AutoType));

Error:
	if (format__AutoType)
		format__AutoType->lpVtbl->Release (format__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoResult,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoResultGetAudioFormat (CAObjHandle objectHandle,
                                                           ERRORINFO *errorInfo,
                                                           SpeechLibObj_ISpeechAudioFormat *format)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoResult_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH format__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (format)
		*format = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoResult,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetAudioFormat_ (__vtblIFacePtr,
	                                                     &format__AutoType));
	

	if (format)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (format__AutoType,
		                                             &SpeechLib_IID_ISpeechAudioFormat,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, format));
		format__AutoType = 0;
		}

Error:
	if (format__AutoType)
		format__AutoType->lpVtbl->Release (format__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (format)
			{
			CA_DiscardObjHandle (*format);
			*format = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoResult,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoResultGetPhraseInfo (CAObjHandle objectHandle,
                                                          ERRORINFO *errorInfo,
                                                          SpeechLibObj_ISpeechPhraseInfo *phraseInfo)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoResult_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH phraseInfo__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (phraseInfo)
		*phraseInfo = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoResult,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetPhraseInfo_ (__vtblIFacePtr,
	                                                    &phraseInfo__AutoType));
	

	if (phraseInfo)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (phraseInfo__AutoType,
		                                             &SpeechLib_IID_ISpeechPhraseInfo,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, phraseInfo));
		phraseInfo__AutoType = 0;
		}

Error:
	if (phraseInfo__AutoType)
		phraseInfo__AutoType->lpVtbl->Release (phraseInfo__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (phraseInfo)
			{
			CA_DiscardObjHandle (*phraseInfo);
			*phraseInfo = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoResult,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoResultAlternates (CAObjHandle objectHandle,
                                                       ERRORINFO *errorInfo,
                                                       long requestCount,
                                                       long startElement,
                                                       long elements,
                                                       SpeechLibObj_ISpeechPhraseAlternates *alternates)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoResult_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH alternates__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (alternates)
		*alternates = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoResult,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Alternates_ (__vtblIFacePtr,
	                                                 requestCount,
	                                                 startElement, elements,
	                                                 &alternates__AutoType));
	

	if (alternates)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (alternates__AutoType,
		                                             &SpeechLib_IID_ISpeechPhraseAlternates,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, alternates));
		alternates__AutoType = 0;
		}

Error:
	if (alternates__AutoType)
		alternates__AutoType->lpVtbl->Release (alternates__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (alternates)
			{
			CA_DiscardObjHandle (*alternates);
			*alternates = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoResult,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoResultAudio (CAObjHandle objectHandle,
                                                  ERRORINFO *errorInfo,
                                                  long startElement,
                                                  long elements,
                                                  SpeechLibObj_ISpeechMemoryStream *stream)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoResult_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH stream__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (stream)
		*stream = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoResult,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Audio_ (__vtblIFacePtr, startElement,
	                                            elements, &stream__AutoType));
	

	if (stream)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (stream__AutoType,
		                                             &SpeechLib_IID_ISpeechMemoryStream,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, stream));
		stream__AutoType = 0;
		}

Error:
	if (stream__AutoType)
		stream__AutoType->lpVtbl->Release (stream__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (stream)
			{
			CA_DiscardObjHandle (*stream);
			*stream = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoResult,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoResultSpeakAudio (CAObjHandle objectHandle,
                                                       ERRORINFO *errorInfo,
                                                       long startElement,
                                                       long elements,
                                                       enum SpeechLibEnum_SpeechVoiceSpeakFlags flags,
                                                       long *streamNumber)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoResult_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long streamNumber__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoResult,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SpeakAudio_ (__vtblIFacePtr,
	                                                 startElement, elements,
	                                                 flags,
	                                                 &streamNumber__Temp));

	if (streamNumber)
		{
		*streamNumber = streamNumber__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoResult,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoResultSaveToMemory (CAObjHandle objectHandle,
                                                         ERRORINFO *errorInfo,
                                                         VARIANT *resultBlock)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoResult_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	VARIANT resultBlock__Temp;

	if (resultBlock)
		CA_VariantSetEmpty (resultBlock);
	CA_VariantSetEmpty (&resultBlock__Temp);

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoResult,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SaveToMemory_ (__vtblIFacePtr,
	                                                   &resultBlock__Temp));

	if (resultBlock)
		{
		*resultBlock = resultBlock__Temp;
		CA_VariantSetEmpty (&resultBlock__Temp);
		}

Error:
	CA_VariantClear (&resultBlock__Temp);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (resultBlock)
			CA_VariantClear (resultBlock);
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoResult,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoResultDiscardResultInfo (CAObjHandle objectHandle,
                                                              ERRORINFO *errorInfo,
                                                              enum SpeechLibEnum_SpeechDiscardType valueTypes)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoResult_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoResult,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->DiscardResultInfo_ (__vtblIFacePtr,
	                                                        valueTypes));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoResult,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoResultTimesGetStreamTime (CAObjHandle objectHandle,
                                                               ERRORINFO *errorInfo,
                                                               VARIANT *time)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoResultTimes_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	VARIANT time__Temp;

	if (time)
		CA_VariantSetEmpty (time);
	CA_VariantSetEmpty (&time__Temp);

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoResultTimes,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetStreamTime_ (__vtblIFacePtr,
	                                                    &time__Temp));

	if (time)
		{
		*time = time__Temp;
		CA_VariantSetEmpty (&time__Temp);
		}

Error:
	CA_VariantClear (&time__Temp);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (time)
			CA_VariantClear (time);
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoResultTimes,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoResultTimesGetLength (CAObjHandle objectHandle,
                                                           ERRORINFO *errorInfo,
                                                           VARIANT *length)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoResultTimes_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	VARIANT length__Temp;

	if (length)
		CA_VariantSetEmpty (length);
	CA_VariantSetEmpty (&length__Temp);

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoResultTimes,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetLength_ (__vtblIFacePtr,
	                                                &length__Temp));

	if (length)
		{
		*length = length__Temp;
		CA_VariantSetEmpty (&length__Temp);
		}

Error:
	CA_VariantClear (&length__Temp);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (length)
			CA_VariantClear (length);
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoResultTimes,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoResultTimesGetTickCount (CAObjHandle objectHandle,
                                                              ERRORINFO *errorInfo,
                                                              long *tickCount)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoResultTimes_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long tickCount__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoResultTimes,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetTickCount_ (__vtblIFacePtr,
	                                                   &tickCount__Temp));

	if (tickCount)
		{
		*tickCount = tickCount__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoResultTimes,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoResultTimesGetOffsetFromStart (CAObjHandle objectHandle,
                                                                    ERRORINFO *errorInfo,
                                                                    VARIANT *offsetFromStart)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoResultTimes_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	VARIANT offsetFromStart__Temp;

	if (offsetFromStart)
		CA_VariantSetEmpty (offsetFromStart);
	CA_VariantSetEmpty (&offsetFromStart__Temp);

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoResultTimes,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetOffsetFromStart_ (__vtblIFacePtr,
	                                                         &offsetFromStart__Temp));

	if (offsetFromStart)
		{
		*offsetFromStart = offsetFromStart__Temp;
		CA_VariantSetEmpty (&offsetFromStart__Temp);
		}

Error:
	CA_VariantClear (&offsetFromStart__Temp);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (offsetFromStart)
			CA_VariantClear (offsetFromStart);
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoResultTimes,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseInfoGetLanguageId (CAObjHandle objectHandle,
                                                          ERRORINFO *errorInfo,
                                                          long *languageId)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseInfo_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long languageId__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseInfo,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetLanguageId_ (__vtblIFacePtr,
	                                                    &languageId__Temp));

	if (languageId)
		{
		*languageId = languageId__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseInfo,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseInfoGetGrammarId (CAObjHandle objectHandle,
                                                         ERRORINFO *errorInfo,
                                                         VARIANT *grammarId)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseInfo_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	VARIANT grammarId__Temp;

	if (grammarId)
		CA_VariantSetEmpty (grammarId);
	CA_VariantSetEmpty (&grammarId__Temp);

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseInfo,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetGrammarId_ (__vtblIFacePtr,
	                                                   &grammarId__Temp));

	if (grammarId)
		{
		*grammarId = grammarId__Temp;
		CA_VariantSetEmpty (&grammarId__Temp);
		}

Error:
	CA_VariantClear (&grammarId__Temp);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (grammarId)
			CA_VariantClear (grammarId);
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseInfo,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseInfoGetStartTime (CAObjHandle objectHandle,
                                                         ERRORINFO *errorInfo,
                                                         VARIANT *startTime)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseInfo_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	VARIANT startTime__Temp;

	if (startTime)
		CA_VariantSetEmpty (startTime);
	CA_VariantSetEmpty (&startTime__Temp);

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseInfo,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetStartTime_ (__vtblIFacePtr,
	                                                   &startTime__Temp));

	if (startTime)
		{
		*startTime = startTime__Temp;
		CA_VariantSetEmpty (&startTime__Temp);
		}

Error:
	CA_VariantClear (&startTime__Temp);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (startTime)
			CA_VariantClear (startTime);
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseInfo,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseInfoGetAudioStreamPosition (CAObjHandle objectHandle,
                                                                   ERRORINFO *errorInfo,
                                                                   VARIANT *audioStreamPosition)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseInfo_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	VARIANT audioStreamPosition__Temp;

	if (audioStreamPosition)
		CA_VariantSetEmpty (audioStreamPosition);
	CA_VariantSetEmpty (&audioStreamPosition__Temp);

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseInfo,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetAudioStreamPosition_ (__vtblIFacePtr,
	                                                             &audioStreamPosition__Temp));

	if (audioStreamPosition)
		{
		*audioStreamPosition = audioStreamPosition__Temp;
		CA_VariantSetEmpty (&audioStreamPosition__Temp);
		}

Error:
	CA_VariantClear (&audioStreamPosition__Temp);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (audioStreamPosition)
			CA_VariantClear (audioStreamPosition);
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseInfo,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseInfoGetAudioSizeBytes (CAObjHandle objectHandle,
                                                              ERRORINFO *errorInfo,
                                                              long *pAudioSizeBytes)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseInfo_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long pAudioSizeBytes__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseInfo,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetAudioSizeBytes_ (__vtblIFacePtr,
	                                                        &pAudioSizeBytes__Temp));

	if (pAudioSizeBytes)
		{
		*pAudioSizeBytes = pAudioSizeBytes__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseInfo,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseInfoGetRetainedSizeBytes (CAObjHandle objectHandle,
                                                                 ERRORINFO *errorInfo,
                                                                 long *retainedSizeBytes)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseInfo_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long retainedSizeBytes__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseInfo,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetRetainedSizeBytes_ (__vtblIFacePtr,
	                                                           &retainedSizeBytes__Temp));

	if (retainedSizeBytes)
		{
		*retainedSizeBytes = retainedSizeBytes__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseInfo,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseInfoGetAudioSizeTime (CAObjHandle objectHandle,
                                                             ERRORINFO *errorInfo,
                                                             long *audioSizeTime)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseInfo_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long audioSizeTime__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseInfo,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetAudioSizeTime_ (__vtblIFacePtr,
	                                                       &audioSizeTime__Temp));

	if (audioSizeTime)
		{
		*audioSizeTime = audioSizeTime__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseInfo,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseInfoGetRule (CAObjHandle objectHandle,
                                                    ERRORINFO *errorInfo,
                                                    SpeechLibObj_ISpeechPhraseRule *rule)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseInfo_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH rule__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (rule)
		*rule = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseInfo,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetRule_ (__vtblIFacePtr,
	                                              &rule__AutoType));
	

	if (rule)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (rule__AutoType,
		                                             &SpeechLib_IID_ISpeechPhraseRule,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, rule));
		rule__AutoType = 0;
		}

Error:
	if (rule__AutoType)
		rule__AutoType->lpVtbl->Release (rule__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (rule)
			{
			CA_DiscardObjHandle (*rule);
			*rule = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseInfo,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseInfoGetProperties (CAObjHandle objectHandle,
                                                          ERRORINFO *errorInfo,
                                                          SpeechLibObj_ISpeechPhraseProperties *properties)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseInfo_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH properties__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (properties)
		*properties = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseInfo,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetProperties_ (__vtblIFacePtr,
	                                                    &properties__AutoType));
	

	if (properties)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (properties__AutoType,
		                                             &SpeechLib_IID_ISpeechPhraseProperties,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, properties));
		properties__AutoType = 0;
		}

Error:
	if (properties__AutoType)
		properties__AutoType->lpVtbl->Release (properties__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (properties)
			{
			CA_DiscardObjHandle (*properties);
			*properties = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseInfo,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseInfoGetElements (CAObjHandle objectHandle,
                                                        ERRORINFO *errorInfo,
                                                        SpeechLibObj_ISpeechPhraseElements *elements)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseInfo_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH elements__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (elements)
		*elements = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseInfo,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetElements_ (__vtblIFacePtr,
	                                                  &elements__AutoType));
	

	if (elements)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (elements__AutoType,
		                                             &SpeechLib_IID_ISpeechPhraseElements,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, elements));
		elements__AutoType = 0;
		}

Error:
	if (elements__AutoType)
		elements__AutoType->lpVtbl->Release (elements__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (elements)
			{
			CA_DiscardObjHandle (*elements);
			*elements = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseInfo,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseInfoGetReplacements (CAObjHandle objectHandle,
                                                            ERRORINFO *errorInfo,
                                                            SpeechLibObj_ISpeechPhraseReplacements *replacements)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseInfo_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH replacements__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (replacements)
		*replacements = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseInfo,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetReplacements_ (__vtblIFacePtr,
	                                                      &replacements__AutoType));
	

	if (replacements)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (replacements__AutoType,
		                                             &SpeechLib_IID_ISpeechPhraseReplacements,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, replacements));
		replacements__AutoType = 0;
		}

Error:
	if (replacements__AutoType)
		replacements__AutoType->lpVtbl->Release (replacements__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (replacements)
			{
			CA_DiscardObjHandle (*replacements);
			*replacements = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseInfo,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseInfoGetEngineId (CAObjHandle objectHandle,
                                                        ERRORINFO *errorInfo,
                                                        char **engineIdGuid)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseInfo_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR engineIdGuid__AutoType = 0;

	if (engineIdGuid)
		*engineIdGuid = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseInfo,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetEngineId_ (__vtblIFacePtr,
	                                                  &engineIdGuid__AutoType));

	if (engineIdGuid)
		__caErrChk (CA_BSTRGetCString (engineIdGuid__AutoType, engineIdGuid));

Error:
	CA_FreeBSTR (engineIdGuid__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (engineIdGuid)
			{
			CA_FreeMemory (*engineIdGuid);
			*engineIdGuid = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseInfo,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseInfoGetEnginePrivateData (CAObjHandle objectHandle,
                                                                 ERRORINFO *errorInfo,
                                                                 VARIANT *privateData)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseInfo_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	VARIANT privateData__Temp;

	if (privateData)
		CA_VariantSetEmpty (privateData);
	CA_VariantSetEmpty (&privateData__Temp);

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseInfo,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetEnginePrivateData_ (__vtblIFacePtr,
	                                                           &privateData__Temp));

	if (privateData)
		{
		*privateData = privateData__Temp;
		CA_VariantSetEmpty (&privateData__Temp);
		}

Error:
	CA_VariantClear (&privateData__Temp);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (privateData)
			CA_VariantClear (privateData);
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseInfo,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseInfoSaveToMemory (CAObjHandle objectHandle,
                                                         ERRORINFO *errorInfo,
                                                         VARIANT *phraseBlock)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseInfo_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	VARIANT phraseBlock__Temp;

	if (phraseBlock)
		CA_VariantSetEmpty (phraseBlock);
	CA_VariantSetEmpty (&phraseBlock__Temp);

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseInfo,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SaveToMemory_ (__vtblIFacePtr,
	                                                   &phraseBlock__Temp));

	if (phraseBlock)
		{
		*phraseBlock = phraseBlock__Temp;
		CA_VariantSetEmpty (&phraseBlock__Temp);
		}

Error:
	CA_VariantClear (&phraseBlock__Temp);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (phraseBlock)
			CA_VariantClear (phraseBlock);
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseInfo,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseInfoGetText (CAObjHandle objectHandle,
                                                    ERRORINFO *errorInfo,
                                                    long startElement,
                                                    long elements,
                                                    VBOOL useReplacements,
                                                    char **text)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseInfo_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR text__AutoType = 0;

	if (text)
		*text = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseInfo,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetText_ (__vtblIFacePtr, startElement,
	                                              elements, useReplacements,
	                                              &text__AutoType));

	if (text)
		__caErrChk (CA_BSTRGetCString (text__AutoType, text));

Error:
	CA_FreeBSTR (text__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (text)
			{
			CA_FreeMemory (*text);
			*text = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseInfo,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseInfoGetDisplayAttributes (CAObjHandle objectHandle,
                                                                 ERRORINFO *errorInfo,
                                                                 long startElement,
                                                                 long elements,
                                                                 VBOOL useReplacements,
                                                                 enum SpeechLibEnum_SpeechDisplayAttributes *displayAttributes)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseInfo_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long displayAttributes__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseInfo,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetDisplayAttributes_ (__vtblIFacePtr,
	                                                           startElement,
	                                                           elements,
	                                                           useReplacements,
	                                                           (long *)&displayAttributes__Temp));

	if (displayAttributes)
		{
		*displayAttributes = displayAttributes__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseInfo,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseRuleGetName (CAObjHandle objectHandle,
                                                    ERRORINFO *errorInfo,
                                                    char **name)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseRule_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR name__AutoType = 0;

	if (name)
		*name = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseRule,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetName_ (__vtblIFacePtr,
	                                              &name__AutoType));

	if (name)
		__caErrChk (CA_BSTRGetCString (name__AutoType, name));

Error:
	CA_FreeBSTR (name__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (name)
			{
			CA_FreeMemory (*name);
			*name = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseRule,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseRuleGetId (CAObjHandle objectHandle,
                                                  ERRORINFO *errorInfo, long *id)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseRule_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long id__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseRule,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetId_ (__vtblIFacePtr, &id__Temp));

	if (id)
		{
		*id = id__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseRule,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseRuleGetFirstElement (CAObjHandle objectHandle,
                                                            ERRORINFO *errorInfo,
                                                            long *firstElement)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseRule_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long firstElement__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseRule,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetFirstElement_ (__vtblIFacePtr,
	                                                      &firstElement__Temp));

	if (firstElement)
		{
		*firstElement = firstElement__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseRule,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseRuleGetNumberOfElements (CAObjHandle objectHandle,
                                                                ERRORINFO *errorInfo,
                                                                long *numberOfElements)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseRule_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long numberOfElements__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseRule,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetNumberOfElements_ (__vtblIFacePtr,
	                                                          &numberOfElements__Temp));

	if (numberOfElements)
		{
		*numberOfElements = numberOfElements__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseRule,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseRuleGetParent (CAObjHandle objectHandle,
                                                      ERRORINFO *errorInfo,
                                                      SpeechLibObj_ISpeechPhraseRule *parent)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseRule_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH parent__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (parent)
		*parent = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseRule,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetParent_ (__vtblIFacePtr,
	                                                &parent__AutoType));
	

	if (parent)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (parent__AutoType,
		                                             &SpeechLib_IID_ISpeechPhraseRule,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, parent));
		parent__AutoType = 0;
		}

Error:
	if (parent__AutoType)
		parent__AutoType->lpVtbl->Release (parent__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (parent)
			{
			CA_DiscardObjHandle (*parent);
			*parent = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseRule,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseRuleGetChildren (CAObjHandle objectHandle,
                                                        ERRORINFO *errorInfo,
                                                        SpeechLibObj_ISpeechPhraseRules *children)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseRule_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH children__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (children)
		*children = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseRule,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetChildren_ (__vtblIFacePtr,
	                                                  &children__AutoType));
	

	if (children)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (children__AutoType,
		                                             &SpeechLib_IID_ISpeechPhraseRules,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, children));
		children__AutoType = 0;
		}

Error:
	if (children__AutoType)
		children__AutoType->lpVtbl->Release (children__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (children)
			{
			CA_DiscardObjHandle (*children);
			*children = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseRule,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseRuleGetConfidence (CAObjHandle objectHandle,
                                                          ERRORINFO *errorInfo,
                                                          enum SpeechLibEnum_SpeechEngineConfidence *actualConfidence)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseRule_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long actualConfidence__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseRule,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetConfidence_ (__vtblIFacePtr,
	                                                    (long *)&actualConfidence__Temp));

	if (actualConfidence)
		{
		*actualConfidence = actualConfidence__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseRule,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseRuleGetEngineConfidence (CAObjHandle objectHandle,
                                                                ERRORINFO *errorInfo,
                                                                float *engineConfidence)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseRule_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	float engineConfidence__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseRule,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetEngineConfidence_ (__vtblIFacePtr,
	                                                          &engineConfidence__Temp));

	if (engineConfidence)
		{
		*engineConfidence = engineConfidence__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseRule,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseRulesGetCount (CAObjHandle objectHandle,
                                                      ERRORINFO *errorInfo,
                                                      long *count)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseRules_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long count__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseRules,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetCount_ (__vtblIFacePtr,
	                                               &count__Temp));

	if (count)
		{
		*count = count__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseRules,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseRulesItem (CAObjHandle objectHandle,
                                                  ERRORINFO *errorInfo,
                                                  long index,
                                                  SpeechLibObj_ISpeechPhraseRule *rule)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseRules_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH rule__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (rule)
		*rule = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseRules,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Item_ (__vtblIFacePtr, index,
	                                           &rule__AutoType));
	

	if (rule)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (rule__AutoType,
		                                             &SpeechLib_IID_ISpeechPhraseRule,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, rule));
		rule__AutoType = 0;
		}

Error:
	if (rule__AutoType)
		rule__AutoType->lpVtbl->Release (rule__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (rule)
			{
			CA_DiscardObjHandle (*rule);
			*rule = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseRules,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseRulesGet_NewEnum (CAObjHandle objectHandle,
                                                         ERRORINFO *errorInfo,
                                                         LPUNKNOWN *enumVARIANT)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseRules_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN enumVARIANT__Temp = 0;

	if (enumVARIANT)
		*enumVARIANT = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseRules,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Get_NewEnum_ (__vtblIFacePtr,
	                                                  &enumVARIANT__Temp));

	if (enumVARIANT)
		{
		*enumVARIANT = enumVARIANT__Temp;
		enumVARIANT__Temp = 0;
		}

Error:
	if (enumVARIANT__Temp)
		enumVARIANT__Temp->lpVtbl->Release (enumVARIANT__Temp);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (enumVARIANT)
			{
			if (*enumVARIANT)
				(*enumVARIANT)->lpVtbl->Release (*enumVARIANT);
			*enumVARIANT = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseRules,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhrasePropertiesGetCount (CAObjHandle objectHandle,
                                                           ERRORINFO *errorInfo,
                                                           long *count)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseProperties_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long count__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseProperties,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetCount_ (__vtblIFacePtr,
	                                               &count__Temp));

	if (count)
		{
		*count = count__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseProperties,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhrasePropertiesItem (CAObjHandle objectHandle,
                                                       ERRORINFO *errorInfo,
                                                       long index,
                                                       SpeechLibObj_ISpeechPhraseProperty *property)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseProperties_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH property__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (property)
		*property = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseProperties,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Item_ (__vtblIFacePtr, index,
	                                           &property__AutoType));
	

	if (property)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (property__AutoType,
		                                             &SpeechLib_IID_ISpeechPhraseProperty,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, property));
		property__AutoType = 0;
		}

Error:
	if (property__AutoType)
		property__AutoType->lpVtbl->Release (property__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (property)
			{
			CA_DiscardObjHandle (*property);
			*property = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseProperties,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhrasePropertiesGet_NewEnum (CAObjHandle objectHandle,
                                                              ERRORINFO *errorInfo,
                                                              LPUNKNOWN *enumVARIANT)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseProperties_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN enumVARIANT__Temp = 0;

	if (enumVARIANT)
		*enumVARIANT = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseProperties,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Get_NewEnum_ (__vtblIFacePtr,
	                                                  &enumVARIANT__Temp));

	if (enumVARIANT)
		{
		*enumVARIANT = enumVARIANT__Temp;
		enumVARIANT__Temp = 0;
		}

Error:
	if (enumVARIANT__Temp)
		enumVARIANT__Temp->lpVtbl->Release (enumVARIANT__Temp);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (enumVARIANT)
			{
			if (*enumVARIANT)
				(*enumVARIANT)->lpVtbl->Release (*enumVARIANT);
			*enumVARIANT = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseProperties,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhrasePropertyGetName (CAObjHandle objectHandle,
                                                        ERRORINFO *errorInfo,
                                                        char **name)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseProperty_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR name__AutoType = 0;

	if (name)
		*name = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseProperty,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetName_ (__vtblIFacePtr,
	                                              &name__AutoType));

	if (name)
		__caErrChk (CA_BSTRGetCString (name__AutoType, name));

Error:
	CA_FreeBSTR (name__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (name)
			{
			CA_FreeMemory (*name);
			*name = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseProperty,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhrasePropertyGetId (CAObjHandle objectHandle,
                                                      ERRORINFO *errorInfo,
                                                      long *id)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseProperty_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long id__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseProperty,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetId_ (__vtblIFacePtr, &id__Temp));

	if (id)
		{
		*id = id__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseProperty,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhrasePropertyGetValue (CAObjHandle objectHandle,
                                                         ERRORINFO *errorInfo,
                                                         VARIANT *value)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseProperty_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	VARIANT value__Temp;

	if (value)
		CA_VariantSetEmpty (value);
	CA_VariantSetEmpty (&value__Temp);

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseProperty,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetValue_ (__vtblIFacePtr,
	                                               &value__Temp));

	if (value)
		{
		*value = value__Temp;
		CA_VariantSetEmpty (&value__Temp);
		}

Error:
	CA_VariantClear (&value__Temp);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (value)
			CA_VariantClear (value);
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseProperty,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhrasePropertyGetFirstElement (CAObjHandle objectHandle,
                                                                ERRORINFO *errorInfo,
                                                                long *firstElement)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseProperty_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long firstElement__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseProperty,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetFirstElement_ (__vtblIFacePtr,
	                                                      &firstElement__Temp));

	if (firstElement)
		{
		*firstElement = firstElement__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseProperty,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhrasePropertyGetNumberOfElements (CAObjHandle objectHandle,
                                                                    ERRORINFO *errorInfo,
                                                                    long *numberOfElements)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseProperty_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long numberOfElements__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseProperty,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetNumberOfElements_ (__vtblIFacePtr,
	                                                          &numberOfElements__Temp));

	if (numberOfElements)
		{
		*numberOfElements = numberOfElements__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseProperty,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhrasePropertyGetEngineConfidence (CAObjHandle objectHandle,
                                                                    ERRORINFO *errorInfo,
                                                                    float *confidence)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseProperty_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	float confidence__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseProperty,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetEngineConfidence_ (__vtblIFacePtr,
	                                                          &confidence__Temp));

	if (confidence)
		{
		*confidence = confidence__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseProperty,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhrasePropertyGetConfidence (CAObjHandle objectHandle,
                                                              ERRORINFO *errorInfo,
                                                              enum SpeechLibEnum_SpeechEngineConfidence *confidence)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseProperty_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long confidence__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseProperty,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetConfidence_ (__vtblIFacePtr,
	                                                    (long *)&confidence__Temp));

	if (confidence)
		{
		*confidence = confidence__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseProperty,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhrasePropertyGetParent (CAObjHandle objectHandle,
                                                          ERRORINFO *errorInfo,
                                                          SpeechLibObj_ISpeechPhraseProperty *parentProperty)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseProperty_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH parentProperty__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (parentProperty)
		*parentProperty = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseProperty,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetParent_ (__vtblIFacePtr,
	                                                &parentProperty__AutoType));
	

	if (parentProperty)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (parentProperty__AutoType,
		                                             &SpeechLib_IID_ISpeechPhraseProperty,
		                                             __supportMultithreading,
		                                             __locale, 0, 0,
		                                             parentProperty));
		parentProperty__AutoType = 0;
		}

Error:
	if (parentProperty__AutoType)
		parentProperty__AutoType->lpVtbl->Release (parentProperty__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (parentProperty)
			{
			CA_DiscardObjHandle (*parentProperty);
			*parentProperty = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseProperty,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhrasePropertyGetChildren (CAObjHandle objectHandle,
                                                            ERRORINFO *errorInfo,
                                                            SpeechLibObj_ISpeechPhraseProperties *children)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseProperty_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH children__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (children)
		*children = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseProperty,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetChildren_ (__vtblIFacePtr,
	                                                  &children__AutoType));
	

	if (children)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (children__AutoType,
		                                             &SpeechLib_IID_ISpeechPhraseProperties,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, children));
		children__AutoType = 0;
		}

Error:
	if (children__AutoType)
		children__AutoType->lpVtbl->Release (children__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (children)
			{
			CA_DiscardObjHandle (*children);
			*children = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseProperty,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseElementsGetCount (CAObjHandle objectHandle,
                                                         ERRORINFO *errorInfo,
                                                         long *count)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseElements_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long count__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseElements,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetCount_ (__vtblIFacePtr,
	                                               &count__Temp));

	if (count)
		{
		*count = count__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseElements,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseElementsItem (CAObjHandle objectHandle,
                                                     ERRORINFO *errorInfo,
                                                     long index,
                                                     SpeechLibObj_ISpeechPhraseElement *element)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseElements_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH element__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (element)
		*element = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseElements,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Item_ (__vtblIFacePtr, index,
	                                           &element__AutoType));
	

	if (element)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (element__AutoType,
		                                             &SpeechLib_IID_ISpeechPhraseElement,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, element));
		element__AutoType = 0;
		}

Error:
	if (element__AutoType)
		element__AutoType->lpVtbl->Release (element__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (element)
			{
			CA_DiscardObjHandle (*element);
			*element = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseElements,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseElementsGet_NewEnum (CAObjHandle objectHandle,
                                                            ERRORINFO *errorInfo,
                                                            LPUNKNOWN *enumVARIANT)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseElements_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN enumVARIANT__Temp = 0;

	if (enumVARIANT)
		*enumVARIANT = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseElements,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Get_NewEnum_ (__vtblIFacePtr,
	                                                  &enumVARIANT__Temp));

	if (enumVARIANT)
		{
		*enumVARIANT = enumVARIANT__Temp;
		enumVARIANT__Temp = 0;
		}

Error:
	if (enumVARIANT__Temp)
		enumVARIANT__Temp->lpVtbl->Release (enumVARIANT__Temp);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (enumVARIANT)
			{
			if (*enumVARIANT)
				(*enumVARIANT)->lpVtbl->Release (*enumVARIANT);
			*enumVARIANT = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseElements,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseElementGetAudioTimeOffset (CAObjHandle objectHandle,
                                                                  ERRORINFO *errorInfo,
                                                                  long *audioTimeOffset)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseElement_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long audioTimeOffset__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseElement,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetAudioTimeOffset_ (__vtblIFacePtr,
	                                                         &audioTimeOffset__Temp));

	if (audioTimeOffset)
		{
		*audioTimeOffset = audioTimeOffset__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseElement,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseElementGetAudioSizeTime (CAObjHandle objectHandle,
                                                                ERRORINFO *errorInfo,
                                                                long *audioSizeTime)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseElement_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long audioSizeTime__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseElement,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetAudioSizeTime_ (__vtblIFacePtr,
	                                                       &audioSizeTime__Temp));

	if (audioSizeTime)
		{
		*audioSizeTime = audioSizeTime__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseElement,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseElementGetAudioStreamOffset (CAObjHandle objectHandle,
                                                                    ERRORINFO *errorInfo,
                                                                    long *audioStreamOffset)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseElement_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long audioStreamOffset__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseElement,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetAudioStreamOffset_ (__vtblIFacePtr,
	                                                           &audioStreamOffset__Temp));

	if (audioStreamOffset)
		{
		*audioStreamOffset = audioStreamOffset__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseElement,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseElementGetAudioSizeBytes (CAObjHandle objectHandle,
                                                                 ERRORINFO *errorInfo,
                                                                 long *audioSizeBytes)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseElement_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long audioSizeBytes__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseElement,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetAudioSizeBytes_ (__vtblIFacePtr,
	                                                        &audioSizeBytes__Temp));

	if (audioSizeBytes)
		{
		*audioSizeBytes = audioSizeBytes__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseElement,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseElementGetRetainedStreamOffset (CAObjHandle objectHandle,
                                                                       ERRORINFO *errorInfo,
                                                                       long *retainedStreamOffset)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseElement_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long retainedStreamOffset__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseElement,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetRetainedStreamOffset_ (__vtblIFacePtr,
	                                                              &retainedStreamOffset__Temp));

	if (retainedStreamOffset)
		{
		*retainedStreamOffset = retainedStreamOffset__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseElement,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseElementGetRetainedSizeBytes (CAObjHandle objectHandle,
                                                                    ERRORINFO *errorInfo,
                                                                    long *retainedSizeBytes)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseElement_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long retainedSizeBytes__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseElement,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetRetainedSizeBytes_ (__vtblIFacePtr,
	                                                           &retainedSizeBytes__Temp));

	if (retainedSizeBytes)
		{
		*retainedSizeBytes = retainedSizeBytes__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseElement,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseElementGetDisplayText (CAObjHandle objectHandle,
                                                              ERRORINFO *errorInfo,
                                                              char **displayText)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseElement_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR displayText__AutoType = 0;

	if (displayText)
		*displayText = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseElement,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetDisplayText_ (__vtblIFacePtr,
	                                                     &displayText__AutoType));

	if (displayText)
		__caErrChk (CA_BSTRGetCString (displayText__AutoType, displayText));

Error:
	CA_FreeBSTR (displayText__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (displayText)
			{
			CA_FreeMemory (*displayText);
			*displayText = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseElement,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseElementGetLexicalForm (CAObjHandle objectHandle,
                                                              ERRORINFO *errorInfo,
                                                              char **lexicalForm)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseElement_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR lexicalForm__AutoType = 0;

	if (lexicalForm)
		*lexicalForm = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseElement,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetLexicalForm_ (__vtblIFacePtr,
	                                                     &lexicalForm__AutoType));

	if (lexicalForm)
		__caErrChk (CA_BSTRGetCString (lexicalForm__AutoType, lexicalForm));

Error:
	CA_FreeBSTR (lexicalForm__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (lexicalForm)
			{
			CA_FreeMemory (*lexicalForm);
			*lexicalForm = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseElement,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseElementGetPronunciation (CAObjHandle objectHandle,
                                                                ERRORINFO *errorInfo,
                                                                VARIANT *pronunciation)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseElement_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	VARIANT pronunciation__Temp;

	if (pronunciation)
		CA_VariantSetEmpty (pronunciation);
	CA_VariantSetEmpty (&pronunciation__Temp);

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseElement,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetPronunciation_ (__vtblIFacePtr,
	                                                       &pronunciation__Temp));

	if (pronunciation)
		{
		*pronunciation = pronunciation__Temp;
		CA_VariantSetEmpty (&pronunciation__Temp);
		}

Error:
	CA_VariantClear (&pronunciation__Temp);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (pronunciation)
			CA_VariantClear (pronunciation);
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseElement,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseElementGetDisplayAttributes (CAObjHandle objectHandle,
                                                                    ERRORINFO *errorInfo,
                                                                    enum SpeechLibEnum_SpeechDisplayAttributes *displayAttributes)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseElement_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long displayAttributes__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseElement,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetDisplayAttributes_ (__vtblIFacePtr,
	                                                           (long *)&displayAttributes__Temp));

	if (displayAttributes)
		{
		*displayAttributes = displayAttributes__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseElement,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseElementGetRequiredConfidence (CAObjHandle objectHandle,
                                                                     ERRORINFO *errorInfo,
                                                                     enum SpeechLibEnum_SpeechEngineConfidence *requiredConfidence)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseElement_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long requiredConfidence__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseElement,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetRequiredConfidence_ (__vtblIFacePtr,
	                                                            (long *)&requiredConfidence__Temp));

	if (requiredConfidence)
		{
		*requiredConfidence = requiredConfidence__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseElement,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseElementGetActualConfidence (CAObjHandle objectHandle,
                                                                   ERRORINFO *errorInfo,
                                                                   enum SpeechLibEnum_SpeechEngineConfidence *actualConfidence)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseElement_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long actualConfidence__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseElement,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetActualConfidence_ (__vtblIFacePtr,
	                                                          (long *)&actualConfidence__Temp));

	if (actualConfidence)
		{
		*actualConfidence = actualConfidence__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseElement,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseElementGetEngineConfidence (CAObjHandle objectHandle,
                                                                   ERRORINFO *errorInfo,
                                                                   float *engineConfidence)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseElement_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	float engineConfidence__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseElement,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetEngineConfidence_ (__vtblIFacePtr,
	                                                          &engineConfidence__Temp));

	if (engineConfidence)
		{
		*engineConfidence = engineConfidence__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseElement,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseReplacementsGetCount (CAObjHandle objectHandle,
                                                             ERRORINFO *errorInfo,
                                                             long *count)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseReplacements_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long count__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseReplacements,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetCount_ (__vtblIFacePtr,
	                                               &count__Temp));

	if (count)
		{
		*count = count__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseReplacements,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseReplacementsItem (CAObjHandle objectHandle,
                                                         ERRORINFO *errorInfo,
                                                         long index,
                                                         SpeechLibObj_ISpeechPhraseReplacement *reps)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseReplacements_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH reps__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (reps)
		*reps = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseReplacements,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Item_ (__vtblIFacePtr, index,
	                                           &reps__AutoType));
	

	if (reps)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (reps__AutoType,
		                                             &SpeechLib_IID_ISpeechPhraseReplacement,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, reps));
		reps__AutoType = 0;
		}

Error:
	if (reps__AutoType)
		reps__AutoType->lpVtbl->Release (reps__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (reps)
			{
			CA_DiscardObjHandle (*reps);
			*reps = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseReplacements,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseReplacementsGet_NewEnum (CAObjHandle objectHandle,
                                                                ERRORINFO *errorInfo,
                                                                LPUNKNOWN *enumVARIANT)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseReplacements_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN enumVARIANT__Temp = 0;

	if (enumVARIANT)
		*enumVARIANT = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseReplacements,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Get_NewEnum_ (__vtblIFacePtr,
	                                                  &enumVARIANT__Temp));

	if (enumVARIANT)
		{
		*enumVARIANT = enumVARIANT__Temp;
		enumVARIANT__Temp = 0;
		}

Error:
	if (enumVARIANT__Temp)
		enumVARIANT__Temp->lpVtbl->Release (enumVARIANT__Temp);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (enumVARIANT)
			{
			if (*enumVARIANT)
				(*enumVARIANT)->lpVtbl->Release (*enumVARIANT);
			*enumVARIANT = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseReplacements,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseReplacementGetDisplayAttributes (CAObjHandle objectHandle,
                                                                        ERRORINFO *errorInfo,
                                                                        enum SpeechLibEnum_SpeechDisplayAttributes *displayAttributes)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseReplacement_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long displayAttributes__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseReplacement,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetDisplayAttributes_ (__vtblIFacePtr,
	                                                           (long *)&displayAttributes__Temp));

	if (displayAttributes)
		{
		*displayAttributes = displayAttributes__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseReplacement,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseReplacementGetText (CAObjHandle objectHandle,
                                                           ERRORINFO *errorInfo,
                                                           char **text)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseReplacement_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR text__AutoType = 0;

	if (text)
		*text = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseReplacement,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetText_ (__vtblIFacePtr,
	                                              &text__AutoType));

	if (text)
		__caErrChk (CA_BSTRGetCString (text__AutoType, text));

Error:
	CA_FreeBSTR (text__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (text)
			{
			CA_FreeMemory (*text);
			*text = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseReplacement,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseReplacementGetFirstElement (CAObjHandle objectHandle,
                                                                   ERRORINFO *errorInfo,
                                                                   long *firstElement)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseReplacement_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long firstElement__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseReplacement,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetFirstElement_ (__vtblIFacePtr,
	                                                      &firstElement__Temp));

	if (firstElement)
		{
		*firstElement = firstElement__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseReplacement,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseReplacementGetNumberOfElements (CAObjHandle objectHandle,
                                                                       ERRORINFO *errorInfo,
                                                                       long *numberOfElements)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseReplacement_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long numberOfElements__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseReplacement,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetNumberOfElements_ (__vtblIFacePtr,
	                                                          &numberOfElements__Temp));

	if (numberOfElements)
		{
		*numberOfElements = numberOfElements__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseReplacement,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseAlternatesGetCount (CAObjHandle objectHandle,
                                                           ERRORINFO *errorInfo,
                                                           long *count)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseAlternates_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long count__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseAlternates,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetCount_ (__vtblIFacePtr,
	                                               &count__Temp));

	if (count)
		{
		*count = count__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseAlternates,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseAlternatesItem (CAObjHandle objectHandle,
                                                       ERRORINFO *errorInfo,
                                                       long index,
                                                       SpeechLibObj_ISpeechPhraseAlternate *phraseAlternate)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseAlternates_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH phraseAlternate__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (phraseAlternate)
		*phraseAlternate = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseAlternates,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Item_ (__vtblIFacePtr, index,
	                                           &phraseAlternate__AutoType));
	

	if (phraseAlternate)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (phraseAlternate__AutoType,
		                                             &SpeechLib_IID_ISpeechPhraseAlternate,
		                                             __supportMultithreading,
		                                             __locale, 0, 0,
		                                             phraseAlternate));
		phraseAlternate__AutoType = 0;
		}

Error:
	if (phraseAlternate__AutoType)
		phraseAlternate__AutoType->lpVtbl->Release (phraseAlternate__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (phraseAlternate)
			{
			CA_DiscardObjHandle (*phraseAlternate);
			*phraseAlternate = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseAlternates,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseAlternatesGet_NewEnum (CAObjHandle objectHandle,
                                                              ERRORINFO *errorInfo,
                                                              LPUNKNOWN *enumVARIANT)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseAlternates_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN enumVARIANT__Temp = 0;

	if (enumVARIANT)
		*enumVARIANT = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseAlternates,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Get_NewEnum_ (__vtblIFacePtr,
	                                                  &enumVARIANT__Temp));

	if (enumVARIANT)
		{
		*enumVARIANT = enumVARIANT__Temp;
		enumVARIANT__Temp = 0;
		}

Error:
	if (enumVARIANT__Temp)
		enumVARIANT__Temp->lpVtbl->Release (enumVARIANT__Temp);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (enumVARIANT)
			{
			if (*enumVARIANT)
				(*enumVARIANT)->lpVtbl->Release (*enumVARIANT);
			*enumVARIANT = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseAlternates,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseAlternateGetRecoResult (CAObjHandle objectHandle,
                                                               ERRORINFO *errorInfo,
                                                               SpeechLibObj_ISpeechRecoResult *recoResult)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseAlternate_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH recoResult__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (recoResult)
		*recoResult = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseAlternate,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetRecoResult_ (__vtblIFacePtr,
	                                                    &recoResult__AutoType));
	

	if (recoResult)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (recoResult__AutoType,
		                                             &SpeechLib_IID_ISpeechRecoResult,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, recoResult));
		recoResult__AutoType = 0;
		}

Error:
	if (recoResult__AutoType)
		recoResult__AutoType->lpVtbl->Release (recoResult__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (recoResult)
			{
			CA_DiscardObjHandle (*recoResult);
			*recoResult = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseAlternate,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseAlternateGetStartElementInResult (CAObjHandle objectHandle,
                                                                         ERRORINFO *errorInfo,
                                                                         long *startElement)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseAlternate_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long startElement__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseAlternate,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetStartElementInResult_ (__vtblIFacePtr,
	                                                              &startElement__Temp));

	if (startElement)
		{
		*startElement = startElement__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseAlternate,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseAlternateGetNumberOfElementsInResult (CAObjHandle objectHandle,
                                                                             ERRORINFO *errorInfo,
                                                                             long *numberOfElements)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseAlternate_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long numberOfElements__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseAlternate,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetNumberOfElementsInResult_ (__vtblIFacePtr,
	                                                                  &numberOfElements__Temp));

	if (numberOfElements)
		{
		*numberOfElements = numberOfElements__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseAlternate,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseAlternateGetPhraseInfo (CAObjHandle objectHandle,
                                                               ERRORINFO *errorInfo,
                                                               SpeechLibObj_ISpeechPhraseInfo *phraseInfo)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseAlternate_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH phraseInfo__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (phraseInfo)
		*phraseInfo = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseAlternate,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetPhraseInfo_ (__vtblIFacePtr,
	                                                    &phraseInfo__AutoType));
	

	if (phraseInfo)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (phraseInfo__AutoType,
		                                             &SpeechLib_IID_ISpeechPhraseInfo,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, phraseInfo));
		phraseInfo__AutoType = 0;
		}

Error:
	if (phraseInfo__AutoType)
		phraseInfo__AutoType->lpVtbl->Release (phraseInfo__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (phraseInfo)
			{
			CA_DiscardObjHandle (*phraseInfo);
			*phraseInfo = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseAlternate,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechPhraseAlternateCommit (CAObjHandle objectHandle,
                                                        ERRORINFO *errorInfo)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechPhraseAlternate_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechPhraseAlternate,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Commit_ (__vtblIFacePtr));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechPhraseAlternate,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoResult2GetRecoContext (CAObjHandle objectHandle,
                                                            ERRORINFO *errorInfo,
                                                            SpeechLibObj_ISpeechRecoContext *recoContext)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoResult2_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH recoContext__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (recoContext)
		*recoContext = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoResult2,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetRecoContext_ (__vtblIFacePtr,
	                                                     &recoContext__AutoType));
	

	if (recoContext)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (recoContext__AutoType,
		                                             &SpeechLib_IID_ISpeechRecoContext,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, recoContext));
		recoContext__AutoType = 0;
		}

Error:
	if (recoContext__AutoType)
		recoContext__AutoType->lpVtbl->Release (recoContext__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (recoContext)
			{
			CA_DiscardObjHandle (*recoContext);
			*recoContext = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoResult2,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoResult2GetTimes (CAObjHandle objectHandle,
                                                      ERRORINFO *errorInfo,
                                                      SpeechLibObj_ISpeechRecoResultTimes *times)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoResult2_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH times__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (times)
		*times = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoResult2,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetTimes_ (__vtblIFacePtr,
	                                               &times__AutoType));
	

	if (times)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (times__AutoType,
		                                             &SpeechLib_IID_ISpeechRecoResultTimes,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, times));
		times__AutoType = 0;
		}

Error:
	if (times__AutoType)
		times__AutoType->lpVtbl->Release (times__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (times)
			{
			CA_DiscardObjHandle (*times);
			*times = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoResult2,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoResult2SetByRefAudioFormat (CAObjHandle objectHandle,
                                                                 ERRORINFO *errorInfo,
                                                                 SpeechLibObj_ISpeechAudioFormat format)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoResult2_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH format__AutoType = 0;

	if (format)
		{
		__caErrChk (CA_GetInterfaceFromObjHandle (format,
	                                          &SpeechLib_IID_ISpeechAudioFormat,
	                                          1, &format__AutoType, NULL));
		}

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoResult2,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetByRefAudioFormat_ (__vtblIFacePtr,
	                                                          format__AutoType));

Error:
	if (format__AutoType)
		format__AutoType->lpVtbl->Release (format__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoResult2,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoResult2GetAudioFormat (CAObjHandle objectHandle,
                                                            ERRORINFO *errorInfo,
                                                            SpeechLibObj_ISpeechAudioFormat *format)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoResult2_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH format__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (format)
		*format = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoResult2,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetAudioFormat_ (__vtblIFacePtr,
	                                                     &format__AutoType));
	

	if (format)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (format__AutoType,
		                                             &SpeechLib_IID_ISpeechAudioFormat,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, format));
		format__AutoType = 0;
		}

Error:
	if (format__AutoType)
		format__AutoType->lpVtbl->Release (format__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (format)
			{
			CA_DiscardObjHandle (*format);
			*format = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoResult2,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoResult2GetPhraseInfo (CAObjHandle objectHandle,
                                                           ERRORINFO *errorInfo,
                                                           SpeechLibObj_ISpeechPhraseInfo *phraseInfo)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoResult2_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH phraseInfo__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (phraseInfo)
		*phraseInfo = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoResult2,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetPhraseInfo_ (__vtblIFacePtr,
	                                                    &phraseInfo__AutoType));
	

	if (phraseInfo)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (phraseInfo__AutoType,
		                                             &SpeechLib_IID_ISpeechPhraseInfo,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, phraseInfo));
		phraseInfo__AutoType = 0;
		}

Error:
	if (phraseInfo__AutoType)
		phraseInfo__AutoType->lpVtbl->Release (phraseInfo__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (phraseInfo)
			{
			CA_DiscardObjHandle (*phraseInfo);
			*phraseInfo = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoResult2,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoResult2Alternates (CAObjHandle objectHandle,
                                                        ERRORINFO *errorInfo,
                                                        long requestCount,
                                                        long startElement,
                                                        long elements,
                                                        SpeechLibObj_ISpeechPhraseAlternates *alternates)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoResult2_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH alternates__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (alternates)
		*alternates = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoResult2,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Alternates_ (__vtblIFacePtr,
	                                                 requestCount,
	                                                 startElement, elements,
	                                                 &alternates__AutoType));
	

	if (alternates)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (alternates__AutoType,
		                                             &SpeechLib_IID_ISpeechPhraseAlternates,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, alternates));
		alternates__AutoType = 0;
		}

Error:
	if (alternates__AutoType)
		alternates__AutoType->lpVtbl->Release (alternates__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (alternates)
			{
			CA_DiscardObjHandle (*alternates);
			*alternates = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoResult2,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoResult2Audio (CAObjHandle objectHandle,
                                                   ERRORINFO *errorInfo,
                                                   long startElement,
                                                   long elements,
                                                   SpeechLibObj_ISpeechMemoryStream *stream)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoResult2_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH stream__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (stream)
		*stream = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoResult2,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Audio_ (__vtblIFacePtr, startElement,
	                                            elements, &stream__AutoType));
	

	if (stream)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (stream__AutoType,
		                                             &SpeechLib_IID_ISpeechMemoryStream,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, stream));
		stream__AutoType = 0;
		}

Error:
	if (stream__AutoType)
		stream__AutoType->lpVtbl->Release (stream__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (stream)
			{
			CA_DiscardObjHandle (*stream);
			*stream = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoResult2,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoResult2SpeakAudio (CAObjHandle objectHandle,
                                                        ERRORINFO *errorInfo,
                                                        long startElement,
                                                        long elements,
                                                        enum SpeechLibEnum_SpeechVoiceSpeakFlags flags,
                                                        long *streamNumber)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoResult2_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long streamNumber__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoResult2,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SpeakAudio_ (__vtblIFacePtr,
	                                                 startElement, elements,
	                                                 flags,
	                                                 &streamNumber__Temp));

	if (streamNumber)
		{
		*streamNumber = streamNumber__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoResult2,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoResult2SaveToMemory (CAObjHandle objectHandle,
                                                          ERRORINFO *errorInfo,
                                                          VARIANT *resultBlock)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoResult2_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	VARIANT resultBlock__Temp;

	if (resultBlock)
		CA_VariantSetEmpty (resultBlock);
	CA_VariantSetEmpty (&resultBlock__Temp);

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoResult2,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SaveToMemory_ (__vtblIFacePtr,
	                                                   &resultBlock__Temp));

	if (resultBlock)
		{
		*resultBlock = resultBlock__Temp;
		CA_VariantSetEmpty (&resultBlock__Temp);
		}

Error:
	CA_VariantClear (&resultBlock__Temp);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (resultBlock)
			CA_VariantClear (resultBlock);
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoResult2,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoResult2DiscardResultInfo (CAObjHandle objectHandle,
                                                               ERRORINFO *errorInfo,
                                                               enum SpeechLibEnum_SpeechDiscardType valueTypes)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoResult2_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoResult2,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->DiscardResultInfo_ (__vtblIFacePtr,
	                                                        valueTypes));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoResult2,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoResult2SetTextFeedback (CAObjHandle objectHandle,
                                                             ERRORINFO *errorInfo,
                                                             const char *feedback,
                                                             VBOOL wasSuccessful)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoResult2_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR feedback__AutoType = 0;

	__caErrChk (CA_CStringToBSTR (feedback, &feedback__AutoType));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoResult2,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetTextFeedback_ (__vtblIFacePtr,
	                                                      feedback__AutoType,
	                                                      wasSuccessful));

Error:
	CA_FreeBSTR (feedback__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoResult2,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechLexiconWordsGetCount (CAObjHandle objectHandle,
                                                       ERRORINFO *errorInfo,
                                                       long *count)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechLexiconWords_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long count__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechLexiconWords,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetCount_ (__vtblIFacePtr,
	                                               &count__Temp));

	if (count)
		{
		*count = count__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechLexiconWords,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechLexiconWordsItem (CAObjHandle objectHandle,
                                                   ERRORINFO *errorInfo,
                                                   long index,
                                                   SpeechLibObj_ISpeechLexiconWord *word)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechLexiconWords_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH word__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (word)
		*word = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechLexiconWords,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Item_ (__vtblIFacePtr, index,
	                                           &word__AutoType));
	

	if (word)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (word__AutoType,
		                                             &SpeechLib_IID_ISpeechLexiconWord,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, word));
		word__AutoType = 0;
		}

Error:
	if (word__AutoType)
		word__AutoType->lpVtbl->Release (word__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (word)
			{
			CA_DiscardObjHandle (*word);
			*word = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechLexiconWords,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechLexiconWordsGet_NewEnum (CAObjHandle objectHandle,
                                                          ERRORINFO *errorInfo,
                                                          LPUNKNOWN *enumVARIANT)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechLexiconWords_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN enumVARIANT__Temp = 0;

	if (enumVARIANT)
		*enumVARIANT = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechLexiconWords,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Get_NewEnum_ (__vtblIFacePtr,
	                                                  &enumVARIANT__Temp));

	if (enumVARIANT)
		{
		*enumVARIANT = enumVARIANT__Temp;
		enumVARIANT__Temp = 0;
		}

Error:
	if (enumVARIANT__Temp)
		enumVARIANT__Temp->lpVtbl->Release (enumVARIANT__Temp);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (enumVARIANT)
			{
			if (*enumVARIANT)
				(*enumVARIANT)->lpVtbl->Release (*enumVARIANT);
			*enumVARIANT = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechLexiconWords,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechLexiconWordGetLangId (CAObjHandle objectHandle,
                                                       ERRORINFO *errorInfo,
                                                       long *langId)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechLexiconWord_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long langId__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechLexiconWord,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetLangId_ (__vtblIFacePtr,
	                                                &langId__Temp));

	if (langId)
		{
		*langId = langId__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechLexiconWord,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechLexiconWordGetType (CAObjHandle objectHandle,
                                                     ERRORINFO *errorInfo,
                                                     enum SpeechLibEnum_SpeechWordType *wordType)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechLexiconWord_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long wordType__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechLexiconWord,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetType_ (__vtblIFacePtr,
	                                              (long *)&wordType__Temp));

	if (wordType)
		{
		*wordType = wordType__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechLexiconWord,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechLexiconWordGetWord (CAObjHandle objectHandle,
                                                     ERRORINFO *errorInfo,
                                                     char **word)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechLexiconWord_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR word__AutoType = 0;

	if (word)
		*word = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechLexiconWord,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetWord_ (__vtblIFacePtr,
	                                              &word__AutoType));

	if (word)
		__caErrChk (CA_BSTRGetCString (word__AutoType, word));

Error:
	CA_FreeBSTR (word__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (word)
			{
			CA_FreeMemory (*word);
			*word = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechLexiconWord,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechLexiconWordGetPronunciations (CAObjHandle objectHandle,
                                                               ERRORINFO *errorInfo,
                                                               SpeechLibObj_ISpeechLexiconPronunciations *pronunciations)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechLexiconWord_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH pronunciations__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (pronunciations)
		*pronunciations = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechLexiconWord,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetPronunciations_ (__vtblIFacePtr,
	                                                        &pronunciations__AutoType));
	

	if (pronunciations)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (pronunciations__AutoType,
		                                             &SpeechLib_IID_ISpeechLexiconPronunciations,
		                                             __supportMultithreading,
		                                             __locale, 0, 0,
		                                             pronunciations));
		pronunciations__AutoType = 0;
		}

Error:
	if (pronunciations__AutoType)
		pronunciations__AutoType->lpVtbl->Release (pronunciations__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (pronunciations)
			{
			CA_DiscardObjHandle (*pronunciations);
			*pronunciations = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechLexiconWord,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechLexiconPronunciationsGetCount (CAObjHandle objectHandle,
                                                                ERRORINFO *errorInfo,
                                                                long *count)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechLexiconPronunciations_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long count__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechLexiconPronunciations,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetCount_ (__vtblIFacePtr,
	                                               &count__Temp));

	if (count)
		{
		*count = count__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle,
	                    &SpeechLib_IID_ISpeechLexiconPronunciations, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechLexiconPronunciationsItem (CAObjHandle objectHandle,
                                                            ERRORINFO *errorInfo,
                                                            long index,
                                                            SpeechLibObj_ISpeechLexiconPronunciation *pronunciation)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechLexiconPronunciations_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH pronunciation__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (pronunciation)
		*pronunciation = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechLexiconPronunciations,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Item_ (__vtblIFacePtr, index,
	                                           &pronunciation__AutoType));
	

	if (pronunciation)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (pronunciation__AutoType,
		                                             &SpeechLib_IID_ISpeechLexiconPronunciation,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, pronunciation));
		pronunciation__AutoType = 0;
		}

Error:
	if (pronunciation__AutoType)
		pronunciation__AutoType->lpVtbl->Release (pronunciation__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (pronunciation)
			{
			CA_DiscardObjHandle (*pronunciation);
			*pronunciation = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle,
	                    &SpeechLib_IID_ISpeechLexiconPronunciations, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechLexiconPronunciationsGet_NewEnum (CAObjHandle objectHandle,
                                                                   ERRORINFO *errorInfo,
                                                                   LPUNKNOWN *enumVARIANT)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechLexiconPronunciations_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN enumVARIANT__Temp = 0;

	if (enumVARIANT)
		*enumVARIANT = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechLexiconPronunciations,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Get_NewEnum_ (__vtblIFacePtr,
	                                                  &enumVARIANT__Temp));

	if (enumVARIANT)
		{
		*enumVARIANT = enumVARIANT__Temp;
		enumVARIANT__Temp = 0;
		}

Error:
	if (enumVARIANT__Temp)
		enumVARIANT__Temp->lpVtbl->Release (enumVARIANT__Temp);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (enumVARIANT)
			{
			if (*enumVARIANT)
				(*enumVARIANT)->lpVtbl->Release (*enumVARIANT);
			*enumVARIANT = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle,
	                    &SpeechLib_IID_ISpeechLexiconPronunciations, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechLexiconPronunciationGetType (CAObjHandle objectHandle,
                                                              ERRORINFO *errorInfo,
                                                              enum SpeechLibEnum_SpeechLexiconType *lexiconType)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechLexiconPronunciation_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long lexiconType__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechLexiconPronunciation,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetType_ (__vtblIFacePtr,
	                                              (long *)&lexiconType__Temp));

	if (lexiconType)
		{
		*lexiconType = lexiconType__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle,
	                    &SpeechLib_IID_ISpeechLexiconPronunciation, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechLexiconPronunciationGetLangId (CAObjHandle objectHandle,
                                                                ERRORINFO *errorInfo,
                                                                long *langId)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechLexiconPronunciation_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long langId__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechLexiconPronunciation,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetLangId_ (__vtblIFacePtr,
	                                                &langId__Temp));

	if (langId)
		{
		*langId = langId__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle,
	                    &SpeechLib_IID_ISpeechLexiconPronunciation, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechLexiconPronunciationGetPartOfSpeech (CAObjHandle objectHandle,
                                                                      ERRORINFO *errorInfo,
                                                                      enum SpeechLibEnum_SpeechPartOfSpeech *partOfSpeech)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechLexiconPronunciation_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long partOfSpeech__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechLexiconPronunciation,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetPartOfSpeech_ (__vtblIFacePtr,
	                                                      (long *)&partOfSpeech__Temp));

	if (partOfSpeech)
		{
		*partOfSpeech = partOfSpeech__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle,
	                    &SpeechLib_IID_ISpeechLexiconPronunciation, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechLexiconPronunciationGetPhoneIds (CAObjHandle objectHandle,
                                                                  ERRORINFO *errorInfo,
                                                                  VARIANT *phoneIds)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechLexiconPronunciation_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	VARIANT phoneIds__Temp;

	if (phoneIds)
		CA_VariantSetEmpty (phoneIds);
	CA_VariantSetEmpty (&phoneIds__Temp);

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechLexiconPronunciation,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetPhoneIds_ (__vtblIFacePtr,
	                                                  &phoneIds__Temp));

	if (phoneIds)
		{
		*phoneIds = phoneIds__Temp;
		CA_VariantSetEmpty (&phoneIds__Temp);
		}

Error:
	CA_VariantClear (&phoneIds__Temp);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (phoneIds)
			CA_VariantClear (phoneIds);
		}
	CA_FillErrorInfoEx (objectHandle,
	                    &SpeechLib_IID_ISpeechLexiconPronunciation, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechLexiconPronunciationGetSymbolic (CAObjHandle objectHandle,
                                                                  ERRORINFO *errorInfo,
                                                                  char **symbolic)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechLexiconPronunciation_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR symbolic__AutoType = 0;

	if (symbolic)
		*symbolic = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechLexiconPronunciation,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetSymbolic_ (__vtblIFacePtr,
	                                                  &symbolic__AutoType));

	if (symbolic)
		__caErrChk (CA_BSTRGetCString (symbolic__AutoType, symbolic));

Error:
	CA_FreeBSTR (symbolic__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (symbolic)
			{
			CA_FreeMemory (*symbolic);
			*symbolic = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle,
	                    &SpeechLib_IID_ISpeechLexiconPronunciation, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechXMLRecoResultGetRecoContext (CAObjHandle objectHandle,
                                                              ERRORINFO *errorInfo,
                                                              SpeechLibObj_ISpeechRecoContext *recoContext)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechXMLRecoResult_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH recoContext__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (recoContext)
		*recoContext = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechXMLRecoResult,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetRecoContext_ (__vtblIFacePtr,
	                                                     &recoContext__AutoType));
	

	if (recoContext)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (recoContext__AutoType,
		                                             &SpeechLib_IID_ISpeechRecoContext,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, recoContext));
		recoContext__AutoType = 0;
		}

Error:
	if (recoContext__AutoType)
		recoContext__AutoType->lpVtbl->Release (recoContext__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (recoContext)
			{
			CA_DiscardObjHandle (*recoContext);
			*recoContext = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechXMLRecoResult,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechXMLRecoResultGetTimes (CAObjHandle objectHandle,
                                                        ERRORINFO *errorInfo,
                                                        SpeechLibObj_ISpeechRecoResultTimes *times)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechXMLRecoResult_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH times__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (times)
		*times = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechXMLRecoResult,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetTimes_ (__vtblIFacePtr,
	                                               &times__AutoType));
	

	if (times)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (times__AutoType,
		                                             &SpeechLib_IID_ISpeechRecoResultTimes,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, times));
		times__AutoType = 0;
		}

Error:
	if (times__AutoType)
		times__AutoType->lpVtbl->Release (times__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (times)
			{
			CA_DiscardObjHandle (*times);
			*times = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechXMLRecoResult,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechXMLRecoResultSetByRefAudioFormat (CAObjHandle objectHandle,
                                                                   ERRORINFO *errorInfo,
                                                                   SpeechLibObj_ISpeechAudioFormat format)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechXMLRecoResult_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH format__AutoType = 0;

	if (format)
		{
		__caErrChk (CA_GetInterfaceFromObjHandle (format,
	                                          &SpeechLib_IID_ISpeechAudioFormat,
	                                          1, &format__AutoType, NULL));
		}

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechXMLRecoResult,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetByRefAudioFormat_ (__vtblIFacePtr,
	                                                          format__AutoType));

Error:
	if (format__AutoType)
		format__AutoType->lpVtbl->Release (format__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechXMLRecoResult,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechXMLRecoResultGetAudioFormat (CAObjHandle objectHandle,
                                                              ERRORINFO *errorInfo,
                                                              SpeechLibObj_ISpeechAudioFormat *format)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechXMLRecoResult_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH format__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (format)
		*format = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechXMLRecoResult,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetAudioFormat_ (__vtblIFacePtr,
	                                                     &format__AutoType));
	

	if (format)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (format__AutoType,
		                                             &SpeechLib_IID_ISpeechAudioFormat,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, format));
		format__AutoType = 0;
		}

Error:
	if (format__AutoType)
		format__AutoType->lpVtbl->Release (format__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (format)
			{
			CA_DiscardObjHandle (*format);
			*format = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechXMLRecoResult,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechXMLRecoResultGetPhraseInfo (CAObjHandle objectHandle,
                                                             ERRORINFO *errorInfo,
                                                             SpeechLibObj_ISpeechPhraseInfo *phraseInfo)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechXMLRecoResult_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH phraseInfo__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (phraseInfo)
		*phraseInfo = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechXMLRecoResult,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetPhraseInfo_ (__vtblIFacePtr,
	                                                    &phraseInfo__AutoType));
	

	if (phraseInfo)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (phraseInfo__AutoType,
		                                             &SpeechLib_IID_ISpeechPhraseInfo,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, phraseInfo));
		phraseInfo__AutoType = 0;
		}

Error:
	if (phraseInfo__AutoType)
		phraseInfo__AutoType->lpVtbl->Release (phraseInfo__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (phraseInfo)
			{
			CA_DiscardObjHandle (*phraseInfo);
			*phraseInfo = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechXMLRecoResult,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechXMLRecoResultAlternates (CAObjHandle objectHandle,
                                                          ERRORINFO *errorInfo,
                                                          long requestCount,
                                                          long startElement,
                                                          long elements,
                                                          SpeechLibObj_ISpeechPhraseAlternates *alternates)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechXMLRecoResult_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH alternates__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (alternates)
		*alternates = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechXMLRecoResult,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Alternates_ (__vtblIFacePtr,
	                                                 requestCount,
	                                                 startElement, elements,
	                                                 &alternates__AutoType));
	

	if (alternates)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (alternates__AutoType,
		                                             &SpeechLib_IID_ISpeechPhraseAlternates,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, alternates));
		alternates__AutoType = 0;
		}

Error:
	if (alternates__AutoType)
		alternates__AutoType->lpVtbl->Release (alternates__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (alternates)
			{
			CA_DiscardObjHandle (*alternates);
			*alternates = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechXMLRecoResult,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechXMLRecoResultAudio (CAObjHandle objectHandle,
                                                     ERRORINFO *errorInfo,
                                                     long startElement,
                                                     long elements,
                                                     SpeechLibObj_ISpeechMemoryStream *stream)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechXMLRecoResult_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH stream__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (stream)
		*stream = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechXMLRecoResult,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Audio_ (__vtblIFacePtr, startElement,
	                                            elements, &stream__AutoType));
	

	if (stream)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (stream__AutoType,
		                                             &SpeechLib_IID_ISpeechMemoryStream,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, stream));
		stream__AutoType = 0;
		}

Error:
	if (stream__AutoType)
		stream__AutoType->lpVtbl->Release (stream__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (stream)
			{
			CA_DiscardObjHandle (*stream);
			*stream = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechXMLRecoResult,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechXMLRecoResultSpeakAudio (CAObjHandle objectHandle,
                                                          ERRORINFO *errorInfo,
                                                          long startElement,
                                                          long elements,
                                                          enum SpeechLibEnum_SpeechVoiceSpeakFlags flags,
                                                          long *streamNumber)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechXMLRecoResult_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long streamNumber__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechXMLRecoResult,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SpeakAudio_ (__vtblIFacePtr,
	                                                 startElement, elements,
	                                                 flags,
	                                                 &streamNumber__Temp));

	if (streamNumber)
		{
		*streamNumber = streamNumber__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechXMLRecoResult,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechXMLRecoResultSaveToMemory (CAObjHandle objectHandle,
                                                            ERRORINFO *errorInfo,
                                                            VARIANT *resultBlock)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechXMLRecoResult_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	VARIANT resultBlock__Temp;

	if (resultBlock)
		CA_VariantSetEmpty (resultBlock);
	CA_VariantSetEmpty (&resultBlock__Temp);

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechXMLRecoResult,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SaveToMemory_ (__vtblIFacePtr,
	                                                   &resultBlock__Temp));

	if (resultBlock)
		{
		*resultBlock = resultBlock__Temp;
		CA_VariantSetEmpty (&resultBlock__Temp);
		}

Error:
	CA_VariantClear (&resultBlock__Temp);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (resultBlock)
			CA_VariantClear (resultBlock);
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechXMLRecoResult,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechXMLRecoResultDiscardResultInfo (CAObjHandle objectHandle,
                                                                 ERRORINFO *errorInfo,
                                                                 enum SpeechLibEnum_SpeechDiscardType valueTypes)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechXMLRecoResult_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechXMLRecoResult,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->DiscardResultInfo_ (__vtblIFacePtr,
	                                                        valueTypes));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechXMLRecoResult,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechXMLRecoResultGetXMLResult (CAObjHandle objectHandle,
                                                            ERRORINFO *errorInfo,
                                                            enum SpeechLibEnum_SPXMLRESULTOPTIONS options,
                                                            char **pResult)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechXMLRecoResult_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR pResult__AutoType = 0;

	if (pResult)
		*pResult = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechXMLRecoResult,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetXMLResult_ (__vtblIFacePtr, options,
	                                                   &pResult__AutoType));

	if (pResult)
		__caErrChk (CA_BSTRGetCString (pResult__AutoType, pResult));

Error:
	CA_FreeBSTR (pResult__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (pResult)
			{
			CA_FreeMemory (*pResult);
			*pResult = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechXMLRecoResult,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechXMLRecoResultGetXMLErrorInfo (CAObjHandle objectHandle,
                                                               ERRORINFO *errorInfo,
                                                               long *lineNumber,
                                                               char **scriptLine,
                                                               char **source,
                                                               char **description,
                                                               long *resultCode,
                                                               VBOOL *isError)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechXMLRecoResult_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long lineNumber__Temp;
	BSTR scriptLine__AutoType = 0;
	BSTR source__AutoType = 0;
	BSTR description__AutoType = 0;
	long resultCode__Temp;
	VBOOL isError__Temp;

	if (scriptLine)
		*scriptLine = 0;
	if (source)
		*source = 0;
	if (description)
		*description = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechXMLRecoResult,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetXMLErrorInfo_ (__vtblIFacePtr,
	                                                      &lineNumber__Temp,
	                                                      &scriptLine__AutoType,
	                                                      &source__AutoType,
	                                                      &description__AutoType,
	                                                      &resultCode__Temp,
	                                                      &isError__Temp));

	if (lineNumber)
		{
		*lineNumber = lineNumber__Temp;
		}
	if (scriptLine)
		__caErrChk (CA_BSTRGetCString (scriptLine__AutoType, scriptLine));
	if (source)
		__caErrChk (CA_BSTRGetCString (source__AutoType, source));
	if (description)
		__caErrChk (CA_BSTRGetCString (description__AutoType, description));
	if (resultCode)
		{
		*resultCode = resultCode__Temp;
		}
	if (isError)
		{
		*isError = isError__Temp;
		}

Error:
	CA_FreeBSTR (scriptLine__AutoType);
	CA_FreeBSTR (source__AutoType);
	CA_FreeBSTR (description__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (scriptLine)
			{
			CA_FreeMemory (*scriptLine);
			*scriptLine = 0;
			}
		if (source)
			{
			CA_FreeMemory (*source);
			*source = 0;
			}
		if (description)
			{
			CA_FreeMemory (*description);
			*description = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechXMLRecoResult,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoResultDispatchGetRecoContext (CAObjHandle objectHandle,
                                                                   ERRORINFO *errorInfo,
                                                                   SpeechLibObj_ISpeechRecoContext *recoContext)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoResultDispatch_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH recoContext__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (recoContext)
		*recoContext = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoResultDispatch,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetRecoContext_ (__vtblIFacePtr,
	                                                     &recoContext__AutoType));
	

	if (recoContext)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (recoContext__AutoType,
		                                             &SpeechLib_IID_ISpeechRecoContext,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, recoContext));
		recoContext__AutoType = 0;
		}

Error:
	if (recoContext__AutoType)
		recoContext__AutoType->lpVtbl->Release (recoContext__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (recoContext)
			{
			CA_DiscardObjHandle (*recoContext);
			*recoContext = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoResultDispatch,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoResultDispatchGetTimes (CAObjHandle objectHandle,
                                                             ERRORINFO *errorInfo,
                                                             SpeechLibObj_ISpeechRecoResultTimes *times)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoResultDispatch_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH times__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (times)
		*times = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoResultDispatch,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetTimes_ (__vtblIFacePtr,
	                                               &times__AutoType));
	

	if (times)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (times__AutoType,
		                                             &SpeechLib_IID_ISpeechRecoResultTimes,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, times));
		times__AutoType = 0;
		}

Error:
	if (times__AutoType)
		times__AutoType->lpVtbl->Release (times__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (times)
			{
			CA_DiscardObjHandle (*times);
			*times = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoResultDispatch,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoResultDispatchSetByRefAudioFormat (CAObjHandle objectHandle,
                                                                        ERRORINFO *errorInfo,
                                                                        SpeechLibObj_ISpeechAudioFormat format)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoResultDispatch_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH format__AutoType = 0;

	if (format)
		{
		__caErrChk (CA_GetInterfaceFromObjHandle (format,
	                                          &SpeechLib_IID_ISpeechAudioFormat,
	                                          1, &format__AutoType, NULL));
		}

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoResultDispatch,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetByRefAudioFormat_ (__vtblIFacePtr,
	                                                          format__AutoType));

Error:
	if (format__AutoType)
		format__AutoType->lpVtbl->Release (format__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoResultDispatch,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoResultDispatchGetAudioFormat (CAObjHandle objectHandle,
                                                                   ERRORINFO *errorInfo,
                                                                   SpeechLibObj_ISpeechAudioFormat *format)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoResultDispatch_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH format__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (format)
		*format = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoResultDispatch,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetAudioFormat_ (__vtblIFacePtr,
	                                                     &format__AutoType));
	

	if (format)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (format__AutoType,
		                                             &SpeechLib_IID_ISpeechAudioFormat,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, format));
		format__AutoType = 0;
		}

Error:
	if (format__AutoType)
		format__AutoType->lpVtbl->Release (format__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (format)
			{
			CA_DiscardObjHandle (*format);
			*format = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoResultDispatch,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoResultDispatchGetPhraseInfo (CAObjHandle objectHandle,
                                                                  ERRORINFO *errorInfo,
                                                                  SpeechLibObj_ISpeechPhraseInfo *phraseInfo)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoResultDispatch_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH phraseInfo__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (phraseInfo)
		*phraseInfo = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoResultDispatch,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetPhraseInfo_ (__vtblIFacePtr,
	                                                    &phraseInfo__AutoType));
	

	if (phraseInfo)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (phraseInfo__AutoType,
		                                             &SpeechLib_IID_ISpeechPhraseInfo,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, phraseInfo));
		phraseInfo__AutoType = 0;
		}

Error:
	if (phraseInfo__AutoType)
		phraseInfo__AutoType->lpVtbl->Release (phraseInfo__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (phraseInfo)
			{
			CA_DiscardObjHandle (*phraseInfo);
			*phraseInfo = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoResultDispatch,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoResultDispatchAlternates (CAObjHandle objectHandle,
                                                               ERRORINFO *errorInfo,
                                                               long requestCount,
                                                               long startElement,
                                                               long elements,
                                                               SpeechLibObj_ISpeechPhraseAlternates *alternates)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoResultDispatch_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH alternates__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (alternates)
		*alternates = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoResultDispatch,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Alternates_ (__vtblIFacePtr,
	                                                 requestCount,
	                                                 startElement, elements,
	                                                 &alternates__AutoType));
	

	if (alternates)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (alternates__AutoType,
		                                             &SpeechLib_IID_ISpeechPhraseAlternates,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, alternates));
		alternates__AutoType = 0;
		}

Error:
	if (alternates__AutoType)
		alternates__AutoType->lpVtbl->Release (alternates__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (alternates)
			{
			CA_DiscardObjHandle (*alternates);
			*alternates = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoResultDispatch,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoResultDispatchAudio (CAObjHandle objectHandle,
                                                          ERRORINFO *errorInfo,
                                                          long startElement,
                                                          long elements,
                                                          SpeechLibObj_ISpeechMemoryStream *stream)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoResultDispatch_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH stream__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (stream)
		*stream = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoResultDispatch,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Audio_ (__vtblIFacePtr, startElement,
	                                            elements, &stream__AutoType));
	

	if (stream)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (stream__AutoType,
		                                             &SpeechLib_IID_ISpeechMemoryStream,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, stream));
		stream__AutoType = 0;
		}

Error:
	if (stream__AutoType)
		stream__AutoType->lpVtbl->Release (stream__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (stream)
			{
			CA_DiscardObjHandle (*stream);
			*stream = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoResultDispatch,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoResultDispatchSpeakAudio (CAObjHandle objectHandle,
                                                               ERRORINFO *errorInfo,
                                                               long startElement,
                                                               long elements,
                                                               enum SpeechLibEnum_SpeechVoiceSpeakFlags flags,
                                                               long *streamNumber)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoResultDispatch_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long streamNumber__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoResultDispatch,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SpeakAudio_ (__vtblIFacePtr,
	                                                 startElement, elements,
	                                                 flags,
	                                                 &streamNumber__Temp));

	if (streamNumber)
		{
		*streamNumber = streamNumber__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoResultDispatch,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoResultDispatchSaveToMemory (CAObjHandle objectHandle,
                                                                 ERRORINFO *errorInfo,
                                                                 VARIANT *resultBlock)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoResultDispatch_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	VARIANT resultBlock__Temp;

	if (resultBlock)
		CA_VariantSetEmpty (resultBlock);
	CA_VariantSetEmpty (&resultBlock__Temp);

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoResultDispatch,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SaveToMemory_ (__vtblIFacePtr,
	                                                   &resultBlock__Temp));

	if (resultBlock)
		{
		*resultBlock = resultBlock__Temp;
		CA_VariantSetEmpty (&resultBlock__Temp);
		}

Error:
	CA_VariantClear (&resultBlock__Temp);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (resultBlock)
			CA_VariantClear (resultBlock);
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoResultDispatch,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoResultDispatchDiscardResultInfo (CAObjHandle objectHandle,
                                                                      ERRORINFO *errorInfo,
                                                                      enum SpeechLibEnum_SpeechDiscardType valueTypes)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoResultDispatch_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoResultDispatch,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->DiscardResultInfo_ (__vtblIFacePtr,
	                                                        valueTypes));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoResultDispatch,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoResultDispatchGetXMLResult (CAObjHandle objectHandle,
                                                                 ERRORINFO *errorInfo,
                                                                 enum SpeechLibEnum_SPXMLRESULTOPTIONS options,
                                                                 char **pResult)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoResultDispatch_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR pResult__AutoType = 0;

	if (pResult)
		*pResult = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoResultDispatch,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetXMLResult_ (__vtblIFacePtr, options,
	                                                   &pResult__AutoType));

	if (pResult)
		__caErrChk (CA_BSTRGetCString (pResult__AutoType, pResult));

Error:
	CA_FreeBSTR (pResult__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (pResult)
			{
			CA_FreeMemory (*pResult);
			*pResult = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoResultDispatch,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoResultDispatchGetXMLErrorInfo (CAObjHandle objectHandle,
                                                                    ERRORINFO *errorInfo,
                                                                    long *lineNumber,
                                                                    char **scriptLine,
                                                                    char **source,
                                                                    char **description,
                                                                    long *resultCode,
                                                                    VBOOL *isError)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoResultDispatch_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long lineNumber__Temp;
	BSTR scriptLine__AutoType = 0;
	BSTR source__AutoType = 0;
	BSTR description__AutoType = 0;
	long resultCode__Temp;
	VBOOL isError__Temp;

	if (scriptLine)
		*scriptLine = 0;
	if (source)
		*source = 0;
	if (description)
		*description = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoResultDispatch,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetXMLErrorInfo_ (__vtblIFacePtr,
	                                                      &lineNumber__Temp,
	                                                      &scriptLine__AutoType,
	                                                      &source__AutoType,
	                                                      &description__AutoType,
	                                                      &resultCode__Temp,
	                                                      &isError__Temp));

	if (lineNumber)
		{
		*lineNumber = lineNumber__Temp;
		}
	if (scriptLine)
		__caErrChk (CA_BSTRGetCString (scriptLine__AutoType, scriptLine));
	if (source)
		__caErrChk (CA_BSTRGetCString (source__AutoType, source));
	if (description)
		__caErrChk (CA_BSTRGetCString (description__AutoType, description));
	if (resultCode)
		{
		*resultCode = resultCode__Temp;
		}
	if (isError)
		{
		*isError = isError__Temp;
		}

Error:
	CA_FreeBSTR (scriptLine__AutoType);
	CA_FreeBSTR (source__AutoType);
	CA_FreeBSTR (description__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (scriptLine)
			{
			CA_FreeMemory (*scriptLine);
			*scriptLine = 0;
			}
		if (source)
			{
			CA_FreeMemory (*source);
			*source = 0;
			}
		if (description)
			{
			CA_FreeMemory (*description);
			*description = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoResultDispatch,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechRecoResultDispatchSetTextFeedback (CAObjHandle objectHandle,
                                                                    ERRORINFO *errorInfo,
                                                                    const char *feedback,
                                                                    VBOOL wasSuccessful)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechRecoResultDispatch_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR feedback__AutoType = 0;

	__caErrChk (CA_CStringToBSTR (feedback, &feedback__AutoType));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechRecoResultDispatch,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetTextFeedback_ (__vtblIFacePtr,
	                                                      feedback__AutoType,
	                                                      wasSuccessful));

Error:
	CA_FreeBSTR (feedback__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechRecoResultDispatch,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpNotifySinkNotify (CAObjHandle objectHandle,
                                               ERRORINFO *errorInfo)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpNotifySink_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpNotifySink, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Notify_ (__vtblIFacePtr));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpNotifySink, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpStreamFormatRemoteRead (CAObjHandle objectHandle,
                                                     ERRORINFO *errorInfo,
                                                     unsigned char *pv,
                                                     unsigned long cb,
                                                     unsigned long *pcbRead)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpStreamFormat_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	unsigned char pv__Temp;
	unsigned long pcbRead__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpStreamFormat,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->RemoteRead_ (__vtblIFacePtr, &pv__Temp,
	                                                 cb, &pcbRead__Temp));

	if (pv)
		{
		*pv = pv__Temp;
		}
	if (pcbRead)
		{
		*pcbRead = pcbRead__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpStreamFormat, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpStreamFormatRemoteWrite (CAObjHandle objectHandle,
                                                      ERRORINFO *errorInfo,
                                                      unsigned char *pv,
                                                      unsigned long cb,
                                                      unsigned long *pcbWritten)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpStreamFormat_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	unsigned long pcbWritten__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpStreamFormat,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->RemoteWrite_ (__vtblIFacePtr, pv, cb,
	                                                  &pcbWritten__Temp));

	if (pcbWritten)
		{
		*pcbWritten = pcbWritten__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpStreamFormat, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpStreamFormatCommit (CAObjHandle objectHandle,
                                                 ERRORINFO *errorInfo,
                                                 unsigned long grfCommitFlags)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpStreamFormat_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpStreamFormat,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Commit_ (__vtblIFacePtr,
	                                             grfCommitFlags));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpStreamFormat, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpStreamFormatRevert (CAObjHandle objectHandle,
                                                 ERRORINFO *errorInfo)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpStreamFormat_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpStreamFormat,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Revert_ (__vtblIFacePtr));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpStreamFormat, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpStreamFormatClone (CAObjHandle objectHandle,
                                                ERRORINFO *errorInfo,
                                                SpeechLibObj_IStream *ppstm)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpStreamFormat_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN ppstm__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (ppstm)
		*ppstm = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpStreamFormat,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Clone_ (__vtblIFacePtr,
	                                            &ppstm__AutoType));
	

	if (ppstm)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (ppstm__AutoType,
		                                             &SpeechLib_IID_IStream,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, ppstm));
		ppstm__AutoType = 0;
		}

Error:
	if (ppstm__AutoType)
		ppstm__AutoType->lpVtbl->Release (ppstm__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (ppstm)
			{
			CA_DiscardObjHandle (*ppstm);
			*ppstm = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpStreamFormat, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_IStreamRemoteRead (CAObjHandle objectHandle,
                                             ERRORINFO *errorInfo,
                                             unsigned char *pv, unsigned long cb,
                                             unsigned long *pcbRead)
{
	HRESULT __result = S_OK;
	SpeechLib_IStream_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	unsigned char pv__Temp;
	unsigned long pcbRead__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_IStream, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->RemoteRead_ (__vtblIFacePtr, &pv__Temp,
	                                                 cb, &pcbRead__Temp));

	if (pv)
		{
		*pv = pv__Temp;
		}
	if (pcbRead)
		{
		*pcbRead = pcbRead__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_IStream, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_IStreamRemoteWrite (CAObjHandle objectHandle,
                                              ERRORINFO *errorInfo,
                                              unsigned char *pv,
                                              unsigned long cb,
                                              unsigned long *pcbWritten)
{
	HRESULT __result = S_OK;
	SpeechLib_IStream_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	unsigned long pcbWritten__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_IStream, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->RemoteWrite_ (__vtblIFacePtr, pv, cb,
	                                                  &pcbWritten__Temp));

	if (pcbWritten)
		{
		*pcbWritten = pcbWritten__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_IStream, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_IStreamCommit (CAObjHandle objectHandle,
                                         ERRORINFO *errorInfo,
                                         unsigned long grfCommitFlags)
{
	HRESULT __result = S_OK;
	SpeechLib_IStream_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_IStream, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Commit_ (__vtblIFacePtr,
	                                             grfCommitFlags));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_IStream, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_IStreamRevert (CAObjHandle objectHandle,
                                         ERRORINFO *errorInfo)
{
	HRESULT __result = S_OK;
	SpeechLib_IStream_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_IStream, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Revert_ (__vtblIFacePtr));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_IStream, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_IStreamClone (CAObjHandle objectHandle,
                                        ERRORINFO *errorInfo,
                                        SpeechLibObj_IStream *ppstm)
{
	HRESULT __result = S_OK;
	SpeechLib_IStream_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN ppstm__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (ppstm)
		*ppstm = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_IStream, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Clone_ (__vtblIFacePtr,
	                                            &ppstm__AutoType));
	

	if (ppstm)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (ppstm__AutoType,
		                                             &SpeechLib_IID_IStream,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, ppstm));
		ppstm__AutoType = 0;
		}

Error:
	if (ppstm__AutoType)
		ppstm__AutoType->lpVtbl->Release (ppstm__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (ppstm)
			{
			CA_DiscardObjHandle (*ppstm);
			*ppstm = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_IStream, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISequentialStreamRemoteRead (CAObjHandle objectHandle,
                                                       ERRORINFO *errorInfo,
                                                       unsigned char *pv,
                                                       unsigned long cb,
                                                       unsigned long *pcbRead)
{
	HRESULT __result = S_OK;
	SpeechLib_ISequentialStream_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	unsigned char pv__Temp;
	unsigned long pcbRead__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISequentialStream,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->RemoteRead_ (__vtblIFacePtr, &pv__Temp,
	                                                 cb, &pcbRead__Temp));

	if (pv)
		{
		*pv = pv__Temp;
		}
	if (pcbRead)
		{
		*pcbRead = pcbRead__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISequentialStream,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISequentialStreamRemoteWrite (CAObjHandle objectHandle,
                                                        ERRORINFO *errorInfo,
                                                        unsigned char *pv,
                                                        unsigned long cb,
                                                        unsigned long *pcbWritten)
{
	HRESULT __result = S_OK;
	SpeechLib_ISequentialStream_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	unsigned long pcbWritten__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISequentialStream,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->RemoteWrite_ (__vtblIFacePtr, pv, cb,
	                                                  &pcbWritten__Temp));

	if (pcbWritten)
		{
		*pcbWritten = pcbWritten__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISequentialStream,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpNotifySourceSetNotifySink (CAObjHandle objectHandle,
                                                        ERRORINFO *errorInfo,
                                                        SpeechLibObj_ISpNotifySink pNotifySink)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpNotifySource_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN pNotifySink__AutoType = 0;

	if (pNotifySink)
		{
		__caErrChk (CA_GetInterfaceFromObjHandle (pNotifySink,
	                                          &SpeechLib_IID_ISpNotifySink, 1,
	                                          &pNotifySink__AutoType, NULL));
		}

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpNotifySource,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetNotifySink_ (__vtblIFacePtr,
	                                                    pNotifySink__AutoType));

Error:
	if (pNotifySink__AutoType)
		pNotifySink__AutoType->lpVtbl->Release (pNotifySink__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpNotifySource, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpNotifySourceSetNotifyWin32Event (CAObjHandle objectHandle,
                                                              ERRORINFO *errorInfo)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpNotifySource_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpNotifySource,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetNotifyWin32Event_ (__vtblIFacePtr));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpNotifySource, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpNotifySourceWaitForNotifyEvent (CAObjHandle objectHandle,
                                                             ERRORINFO *errorInfo,
                                                             unsigned long dwMilliseconds)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpNotifySource_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpNotifySource,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->WaitForNotifyEvent_ (__vtblIFacePtr,
	                                                         dwMilliseconds));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpNotifySource, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpNotifySourceGetNotifyEventHandle (CAObjHandle objectHandle,
                                                               ERRORINFO *errorInfo)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpNotifySource_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpNotifySource,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetNotifyEventHandle_ (__vtblIFacePtr));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpNotifySource, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpAudioRemoteRead (CAObjHandle objectHandle,
                                              ERRORINFO *errorInfo,
                                              unsigned char *pv,
                                              unsigned long cb,
                                              unsigned long *pcbRead)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpAudio_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	unsigned char pv__Temp;
	unsigned long pcbRead__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpAudio, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->RemoteRead_ (__vtblIFacePtr, &pv__Temp,
	                                                 cb, &pcbRead__Temp));

	if (pv)
		{
		*pv = pv__Temp;
		}
	if (pcbRead)
		{
		*pcbRead = pcbRead__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpAudio, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpAudioRemoteWrite (CAObjHandle objectHandle,
                                               ERRORINFO *errorInfo,
                                               unsigned char *pv,
                                               unsigned long cb,
                                               unsigned long *pcbWritten)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpAudio_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	unsigned long pcbWritten__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpAudio, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->RemoteWrite_ (__vtblIFacePtr, pv, cb,
	                                                  &pcbWritten__Temp));

	if (pcbWritten)
		{
		*pcbWritten = pcbWritten__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpAudio, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpAudioCommit (CAObjHandle objectHandle,
                                          ERRORINFO *errorInfo,
                                          unsigned long grfCommitFlags)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpAudio_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpAudio, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Commit_ (__vtblIFacePtr,
	                                             grfCommitFlags));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpAudio, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpAudioRevert (CAObjHandle objectHandle,
                                          ERRORINFO *errorInfo)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpAudio_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpAudio, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Revert_ (__vtblIFacePtr));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpAudio, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpAudioClone (CAObjHandle objectHandle,
                                         ERRORINFO *errorInfo,
                                         SpeechLibObj_IStream *ppstm)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpAudio_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN ppstm__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (ppstm)
		*ppstm = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpAudio, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Clone_ (__vtblIFacePtr,
	                                            &ppstm__AutoType));
	

	if (ppstm)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (ppstm__AutoType,
		                                             &SpeechLib_IID_IStream,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, ppstm));
		ppstm__AutoType = 0;
		}

Error:
	if (ppstm__AutoType)
		ppstm__AutoType->lpVtbl->Release (ppstm__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (ppstm)
			{
			CA_DiscardObjHandle (*ppstm);
			*ppstm = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpAudio, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpAudioEventHandle (CAObjHandle objectHandle,
                                               ERRORINFO *errorInfo)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpAudio_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpAudio, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->EventHandle_ (__vtblIFacePtr));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpAudio, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpAudioGetVolumeLevel (CAObjHandle objectHandle,
                                                  ERRORINFO *errorInfo,
                                                  unsigned long *pLevel)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpAudio_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	unsigned long pLevel__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpAudio, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetVolumeLevel_ (__vtblIFacePtr,
	                                                     &pLevel__Temp));

	if (pLevel)
		{
		*pLevel = pLevel__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpAudio, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpAudioSetVolumeLevel (CAObjHandle objectHandle,
                                                  ERRORINFO *errorInfo,
                                                  unsigned long level)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpAudio_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpAudio, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetVolumeLevel_ (__vtblIFacePtr, level));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpAudio, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpAudioGetBufferNotifySize (CAObjHandle objectHandle,
                                                       ERRORINFO *errorInfo,
                                                       unsigned long *pcbSize)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpAudio_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	unsigned long pcbSize__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpAudio, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetBufferNotifySize_ (__vtblIFacePtr,
	                                                          &pcbSize__Temp));

	if (pcbSize)
		{
		*pcbSize = pcbSize__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpAudio, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpAudioSetBufferNotifySize (CAObjHandle objectHandle,
                                                       ERRORINFO *errorInfo,
                                                       unsigned long cbSize)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpAudio_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpAudio, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetBufferNotifySize_ (__vtblIFacePtr,
	                                                          cbSize));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpAudio, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpPhraseDiscard (CAObjHandle objectHandle,
                                            ERRORINFO *errorInfo,
                                            unsigned long dwValueTypes)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpPhrase_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpPhrase, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Discard_ (__vtblIFacePtr, dwValueTypes));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpPhrase, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpRecoGrammarResetGrammar (CAObjHandle objectHandle,
                                                      ERRORINFO *errorInfo,
                                                      unsigned short newLanguage)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpRecoGrammar_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpRecoGrammar, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->ResetGrammar_ (__vtblIFacePtr,
	                                                   newLanguage));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpRecoGrammar, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpRecoGrammarClearRule (CAObjHandle objectHandle,
                                                   ERRORINFO *errorInfo,
                                                   void *hState)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpRecoGrammar_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpRecoGrammar, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->ClearRule_ (__vtblIFacePtr, hState));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpRecoGrammar, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpRecoGrammarCommit (CAObjHandle objectHandle,
                                                ERRORINFO *errorInfo,
                                                unsigned long dwReserved)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpRecoGrammar_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpRecoGrammar, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Commit_ (__vtblIFacePtr, dwReserved));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpRecoGrammar, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpRecoGrammarGetRecoContext (CAObjHandle objectHandle,
                                                        ERRORINFO *errorInfo,
                                                        SpeechLibObj_ISpRecoContext *ppRecoCtxt)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpRecoGrammar_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN ppRecoCtxt__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (ppRecoCtxt)
		*ppRecoCtxt = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpRecoGrammar, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetRecoContext_ (__vtblIFacePtr,
	                                                     &ppRecoCtxt__AutoType));
	

	if (ppRecoCtxt)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (ppRecoCtxt__AutoType,
		                                             &SpeechLib_IID_ISpRecoContext,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, ppRecoCtxt));
		ppRecoCtxt__AutoType = 0;
		}

Error:
	if (ppRecoCtxt__AutoType)
		ppRecoCtxt__AutoType->lpVtbl->Release (ppRecoCtxt__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (ppRecoCtxt)
			{
			CA_DiscardObjHandle (*ppRecoCtxt);
			*ppRecoCtxt = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpRecoGrammar, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpRecoGrammarSetRuleIdState (CAObjHandle objectHandle,
                                                        ERRORINFO *errorInfo,
                                                        unsigned long ulRuleId,
                                                        enum SpeechLibEnum_SPRULESTATE newState)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpRecoGrammar_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpRecoGrammar, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetRuleIdState_ (__vtblIFacePtr,
	                                                     ulRuleId, newState));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpRecoGrammar, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpRecoGrammarUnloadDictation (CAObjHandle objectHandle,
                                                         ERRORINFO *errorInfo)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpRecoGrammar_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpRecoGrammar, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->UnloadDictation_ (__vtblIFacePtr));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpRecoGrammar, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpRecoGrammarSetDictationState (CAObjHandle objectHandle,
                                                           ERRORINFO *errorInfo,
                                                           enum SpeechLibEnum_SPRULESTATE newState)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpRecoGrammar_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpRecoGrammar, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetDictationState_ (__vtblIFacePtr,
	                                                        newState));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpRecoGrammar, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpRecoGrammarSetGrammarState (CAObjHandle objectHandle,
                                                         ERRORINFO *errorInfo,
                                                         enum SpeechLibEnum_SPGRAMMARSTATE eGrammarState)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpRecoGrammar_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpRecoGrammar, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetGrammarState_ (__vtblIFacePtr,
	                                                      eGrammarState));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpRecoGrammar, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpRecoGrammarGetGrammarState (CAObjHandle objectHandle,
                                                         ERRORINFO *errorInfo,
                                                         enum SpeechLibEnum_SPGRAMMARSTATE *peGrammarState)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpRecoGrammar_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long peGrammarState__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpRecoGrammar, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetGrammarState_ (__vtblIFacePtr,
	                                                      (long *)&peGrammarState__Temp));

	if (peGrammarState)
		{
		*peGrammarState = peGrammarState__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpRecoGrammar, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpGrammarBuilderResetGrammar (CAObjHandle objectHandle,
                                                         ERRORINFO *errorInfo,
                                                         unsigned short newLanguage)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpGrammarBuilder_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpGrammarBuilder,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->ResetGrammar_ (__vtblIFacePtr,
	                                                   newLanguage));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpGrammarBuilder,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpGrammarBuilderClearRule (CAObjHandle objectHandle,
                                                      ERRORINFO *errorInfo,
                                                      void *hState)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpGrammarBuilder_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpGrammarBuilder,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->ClearRule_ (__vtblIFacePtr, hState));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpGrammarBuilder,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpGrammarBuilderCommit (CAObjHandle objectHandle,
                                                   ERRORINFO *errorInfo,
                                                   unsigned long dwReserved)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpGrammarBuilder_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpGrammarBuilder,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Commit_ (__vtblIFacePtr, dwReserved));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpGrammarBuilder,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpRecoResultDiscard (CAObjHandle objectHandle,
                                                ERRORINFO *errorInfo,
                                                unsigned long dwValueTypes)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpRecoResult_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpRecoResult, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Discard_ (__vtblIFacePtr, dwValueTypes));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpRecoResult, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpRecoResultGetAlternates (CAObjHandle objectHandle,
                                                      ERRORINFO *errorInfo,
                                                      unsigned long ulStartElement,
                                                      unsigned long cElements,
                                                      unsigned long ulRequestCount,
                                                      SpeechLibObj_ISpPhraseAlt *ppPhrases,
                                                      unsigned long *pcPhrasesReturned)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpRecoResult_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN ppPhrases__AutoType = 0;
	unsigned long pcPhrasesReturned__Temp;
	LCID __locale;
	int __supportMultithreading;

	if (ppPhrases)
		*ppPhrases = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpRecoResult, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetAlternates_ (__vtblIFacePtr,
	                                                    ulStartElement,
	                                                    cElements,
	                                                    ulRequestCount,
	                                                    &ppPhrases__AutoType,
	                                                    &pcPhrasesReturned__Temp));
	

	if (ppPhrases)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (ppPhrases__AutoType,
		                                             &SpeechLib_IID_ISpPhraseAlt,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, ppPhrases));
		ppPhrases__AutoType = 0;
		}
	if (pcPhrasesReturned)
		{
		*pcPhrasesReturned = pcPhrasesReturned__Temp;
		}

Error:
	if (ppPhrases__AutoType)
		ppPhrases__AutoType->lpVtbl->Release (ppPhrases__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (ppPhrases)
			{
			CA_DiscardObjHandle (*ppPhrases);
			*ppPhrases = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpRecoResult, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpRecoResultGetAudio (CAObjHandle objectHandle,
                                                 ERRORINFO *errorInfo,
                                                 unsigned long ulStartElement,
                                                 unsigned long cElements,
                                                 SpeechLibObj_ISpStreamFormat *ppStream)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpRecoResult_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN ppStream__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (ppStream)
		*ppStream = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpRecoResult, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetAudio_ (__vtblIFacePtr,
	                                               ulStartElement, cElements,
	                                               &ppStream__AutoType));
	

	if (ppStream)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (ppStream__AutoType,
		                                             &SpeechLib_IID_ISpStreamFormat,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, ppStream));
		ppStream__AutoType = 0;
		}

Error:
	if (ppStream__AutoType)
		ppStream__AutoType->lpVtbl->Release (ppStream__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (ppStream)
			{
			CA_DiscardObjHandle (*ppStream);
			*ppStream = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpRecoResult, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpRecoResultSpeakAudio (CAObjHandle objectHandle,
                                                   ERRORINFO *errorInfo,
                                                   unsigned long ulStartElement,
                                                   unsigned long cElements,
                                                   unsigned long dwFlags,
                                                   unsigned long *pulStreamNumber)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpRecoResult_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	unsigned long pulStreamNumber__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpRecoResult, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SpeakAudio_ (__vtblIFacePtr,
	                                                 ulStartElement, cElements,
	                                                 dwFlags,
	                                                 &pulStreamNumber__Temp));

	if (pulStreamNumber)
		{
		*pulStreamNumber = pulStreamNumber__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpRecoResult, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpRecoResultGetRecoContext (CAObjHandle objectHandle,
                                                       ERRORINFO *errorInfo,
                                                       SpeechLibObj_ISpRecoContext *ppRecoContext)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpRecoResult_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN ppRecoContext__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (ppRecoContext)
		*ppRecoContext = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpRecoResult, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetRecoContext_ (__vtblIFacePtr,
	                                                     &ppRecoContext__AutoType));
	

	if (ppRecoContext)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (ppRecoContext__AutoType,
		                                             &SpeechLib_IID_ISpRecoContext,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, ppRecoContext));
		ppRecoContext__AutoType = 0;
		}

Error:
	if (ppRecoContext__AutoType)
		ppRecoContext__AutoType->lpVtbl->Release (ppRecoContext__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (ppRecoContext)
			{
			CA_DiscardObjHandle (*ppRecoContext);
			*ppRecoContext = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpRecoResult, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpPhraseAltDiscard (CAObjHandle objectHandle,
                                               ERRORINFO *errorInfo,
                                               unsigned long dwValueTypes)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpPhraseAlt_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpPhraseAlt, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Discard_ (__vtblIFacePtr, dwValueTypes));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpPhraseAlt, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpPhraseAltGetAltInfo (CAObjHandle objectHandle,
                                                  ERRORINFO *errorInfo,
                                                  SpeechLibObj_ISpPhrase *ppParent,
                                                  unsigned long *pulStartElementInParent,
                                                  unsigned long *pcElementsInParent,
                                                  unsigned long *pcElementsInAlt)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpPhraseAlt_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN ppParent__AutoType = 0;
	unsigned long pulStartElementInParent__Temp;
	unsigned long pcElementsInParent__Temp;
	unsigned long pcElementsInAlt__Temp;
	LCID __locale;
	int __supportMultithreading;

	if (ppParent)
		*ppParent = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpPhraseAlt, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetAltInfo_ (__vtblIFacePtr,
	                                                 &ppParent__AutoType,
	                                                 &pulStartElementInParent__Temp,
	                                                 &pcElementsInParent__Temp,
	                                                 &pcElementsInAlt__Temp));
	

	if (ppParent)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (ppParent__AutoType,
		                                             &SpeechLib_IID_ISpPhrase,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, ppParent));
		ppParent__AutoType = 0;
		}
	if (pulStartElementInParent)
		{
		*pulStartElementInParent = pulStartElementInParent__Temp;
		}
	if (pcElementsInParent)
		{
		*pcElementsInParent = pcElementsInParent__Temp;
		}
	if (pcElementsInAlt)
		{
		*pcElementsInAlt = pcElementsInAlt__Temp;
		}

Error:
	if (ppParent__AutoType)
		ppParent__AutoType->lpVtbl->Release (ppParent__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (ppParent)
			{
			CA_DiscardObjHandle (*ppParent);
			*ppParent = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpPhraseAlt, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpPhraseAltCommit (CAObjHandle objectHandle,
                                              ERRORINFO *errorInfo)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpPhraseAlt_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpPhraseAlt, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Commit_ (__vtblIFacePtr));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpPhraseAlt, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpRecoCategoryGetType (CAObjHandle objectHandle,
                                                  ERRORINFO *errorInfo,
                                                  enum SpeechLibEnum_SPCATEGORYTYPE *peCategoryType)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpRecoCategory_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	long peCategoryType__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpRecoCategory,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetType_ (__vtblIFacePtr,
	                                              (long *)&peCategoryType__Temp));

	if (peCategoryType)
		{
		*peCategoryType = peCategoryType__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpRecoCategory, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpXMLRecoResultDiscard (CAObjHandle objectHandle,
                                                   ERRORINFO *errorInfo,
                                                   unsigned long dwValueTypes)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpXMLRecoResult_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpXMLRecoResult,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Discard_ (__vtblIFacePtr, dwValueTypes));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpXMLRecoResult,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpXMLRecoResultGetAlternates (CAObjHandle objectHandle,
                                                         ERRORINFO *errorInfo,
                                                         unsigned long ulStartElement,
                                                         unsigned long cElements,
                                                         unsigned long ulRequestCount,
                                                         SpeechLibObj_ISpPhraseAlt *ppPhrases,
                                                         unsigned long *pcPhrasesReturned)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpXMLRecoResult_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN ppPhrases__AutoType = 0;
	unsigned long pcPhrasesReturned__Temp;
	LCID __locale;
	int __supportMultithreading;

	if (ppPhrases)
		*ppPhrases = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpXMLRecoResult,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetAlternates_ (__vtblIFacePtr,
	                                                    ulStartElement,
	                                                    cElements,
	                                                    ulRequestCount,
	                                                    &ppPhrases__AutoType,
	                                                    &pcPhrasesReturned__Temp));
	

	if (ppPhrases)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (ppPhrases__AutoType,
		                                             &SpeechLib_IID_ISpPhraseAlt,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, ppPhrases));
		ppPhrases__AutoType = 0;
		}
	if (pcPhrasesReturned)
		{
		*pcPhrasesReturned = pcPhrasesReturned__Temp;
		}

Error:
	if (ppPhrases__AutoType)
		ppPhrases__AutoType->lpVtbl->Release (ppPhrases__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (ppPhrases)
			{
			CA_DiscardObjHandle (*ppPhrases);
			*ppPhrases = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpXMLRecoResult,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpXMLRecoResultGetAudio (CAObjHandle objectHandle,
                                                    ERRORINFO *errorInfo,
                                                    unsigned long ulStartElement,
                                                    unsigned long cElements,
                                                    SpeechLibObj_ISpStreamFormat *ppStream)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpXMLRecoResult_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN ppStream__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (ppStream)
		*ppStream = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpXMLRecoResult,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetAudio_ (__vtblIFacePtr,
	                                               ulStartElement, cElements,
	                                               &ppStream__AutoType));
	

	if (ppStream)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (ppStream__AutoType,
		                                             &SpeechLib_IID_ISpStreamFormat,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, ppStream));
		ppStream__AutoType = 0;
		}

Error:
	if (ppStream__AutoType)
		ppStream__AutoType->lpVtbl->Release (ppStream__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (ppStream)
			{
			CA_DiscardObjHandle (*ppStream);
			*ppStream = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpXMLRecoResult,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpXMLRecoResultSpeakAudio (CAObjHandle objectHandle,
                                                      ERRORINFO *errorInfo,
                                                      unsigned long ulStartElement,
                                                      unsigned long cElements,
                                                      unsigned long dwFlags,
                                                      unsigned long *pulStreamNumber)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpXMLRecoResult_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	unsigned long pulStreamNumber__Temp;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpXMLRecoResult,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SpeakAudio_ (__vtblIFacePtr,
	                                                 ulStartElement, cElements,
	                                                 dwFlags,
	                                                 &pulStreamNumber__Temp));

	if (pulStreamNumber)
		{
		*pulStreamNumber = pulStreamNumber__Temp;
		}

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpXMLRecoResult,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpXMLRecoResultGetRecoContext (CAObjHandle objectHandle,
                                                          ERRORINFO *errorInfo,
                                                          SpeechLibObj_ISpRecoContext *ppRecoContext)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpXMLRecoResult_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN ppRecoContext__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (ppRecoContext)
		*ppRecoContext = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpXMLRecoResult,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetRecoContext_ (__vtblIFacePtr,
	                                                     &ppRecoContext__AutoType));
	

	if (ppRecoContext)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (ppRecoContext__AutoType,
		                                             &SpeechLib_IID_ISpRecoContext,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, ppRecoContext));
		ppRecoContext__AutoType = 0;
		}

Error:
	if (ppRecoContext__AutoType)
		ppRecoContext__AutoType->lpVtbl->Release (ppRecoContext__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (ppRecoContext)
			{
			CA_DiscardObjHandle (*ppRecoContext);
			*ppRecoContext = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpXMLRecoResult,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpRecoGrammar2SetDictationWeight (CAObjHandle objectHandle,
                                                             ERRORINFO *errorInfo,
                                                             float flWeight)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpRecoGrammar2_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpRecoGrammar2,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetDictationWeight_ (__vtblIFacePtr,
	                                                         flWeight));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpRecoGrammar2, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpRecoGrammar2SetGrammarLoader (CAObjHandle objectHandle,
                                                           ERRORINFO *errorInfo,
                                                           SpeechLibObj_ISpeechResourceLoader pLoader)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpRecoGrammar2_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPDISPATCH pLoader__AutoType = 0;

	if (pLoader)
		{
		__caErrChk (CA_GetInterfaceFromObjHandle (pLoader,
	                                          &SpeechLib_IID_ISpeechResourceLoader,
	                                          1, &pLoader__AutoType, NULL));
		}

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpRecoGrammar2,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetGrammarLoader_ (__vtblIFacePtr,
	                                                       pLoader__AutoType));

Error:
	if (pLoader__AutoType)
		pLoader__AutoType->lpVtbl->Release (pLoader__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpRecoGrammar2, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpRecoGrammar2SetSMLSecurityManager (CAObjHandle objectHandle,
                                                                ERRORINFO *errorInfo,
                                                                SpeechLibObj_IInternetSecurityManager pSMLSecurityManager)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpRecoGrammar2_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN pSMLSecurityManager__AutoType = 0;

	if (pSMLSecurityManager)
		{
		__caErrChk (CA_GetInterfaceFromObjHandle (pSMLSecurityManager,
	                                          &SpeechLib_IID_IInternetSecurityManager,
	                                          1,
	                                          &pSMLSecurityManager__AutoType,
	                                          NULL));
		}

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpRecoGrammar2,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetSMLSecurityManager_ (__vtblIFacePtr,
	                                                            pSMLSecurityManager__AutoType));

Error:
	if (pSMLSecurityManager__AutoType)
		pSMLSecurityManager__AutoType->lpVtbl->Release (pSMLSecurityManager__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpRecoGrammar2, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechResourceLoaderLoadResource (CAObjHandle objectHandle,
                                                             ERRORINFO *errorInfo,
                                                             const char *bstrResourceUri,
                                                             VBOOL fAlwaysReload,
                                                             LPUNKNOWN *pStream,
                                                             char **pbstrMIMEType,
                                                             VBOOL *pfModified,
                                                             char **pbstrRedirectUrl)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechResourceLoader_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR bstrResourceUri__AutoType = 0;
	LPUNKNOWN pStream__Temp = 0;
	BSTR pbstrMIMEType__AutoType = 0;
	VBOOL pfModified__Temp;
	BSTR pbstrRedirectUrl__AutoType = 0;

	if (pStream)
		*pStream = 0;
	if (pbstrMIMEType)
		*pbstrMIMEType = 0;
	if (pbstrRedirectUrl)
		*pbstrRedirectUrl = 0;

	__caErrChk (CA_CStringToBSTR (bstrResourceUri, &bstrResourceUri__AutoType));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechResourceLoader,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->LoadResource_ (__vtblIFacePtr,
	                                                   bstrResourceUri__AutoType,
	                                                   fAlwaysReload,
	                                                   &pStream__Temp,
	                                                   &pbstrMIMEType__AutoType,
	                                                   &pfModified__Temp,
	                                                   &pbstrRedirectUrl__AutoType));

	if (pStream)
		{
		*pStream = pStream__Temp;
		pStream__Temp = 0;
		}
	if (pbstrMIMEType)
		__caErrChk (CA_BSTRGetCString (pbstrMIMEType__AutoType, pbstrMIMEType));
	if (pfModified)
		{
		*pfModified = pfModified__Temp;
		}
	if (pbstrRedirectUrl)
		__caErrChk (CA_BSTRGetCString (pbstrRedirectUrl__AutoType,
	                               pbstrRedirectUrl));

Error:
	CA_FreeBSTR (bstrResourceUri__AutoType);
	if (pStream__Temp)
		pStream__Temp->lpVtbl->Release (pStream__Temp);
	CA_FreeBSTR (pbstrMIMEType__AutoType);
	CA_FreeBSTR (pbstrRedirectUrl__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (pStream)
			{
			if (*pStream)
				(*pStream)->lpVtbl->Release (*pStream);
			*pStream = 0;
			}
		if (pbstrMIMEType)
			{
			CA_FreeMemory (*pbstrMIMEType);
			*pbstrMIMEType = 0;
			}
		if (pbstrRedirectUrl)
			{
			CA_FreeMemory (*pbstrRedirectUrl);
			*pbstrRedirectUrl = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechResourceLoader,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechResourceLoaderGetLocalCopy (CAObjHandle objectHandle,
                                                             ERRORINFO *errorInfo,
                                                             const char *bstrResourceUri,
                                                             char **pbstrLocalPath,
                                                             char **pbstrMIMEType,
                                                             char **pbstrRedirectUrl)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechResourceLoader_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR bstrResourceUri__AutoType = 0;
	BSTR pbstrLocalPath__AutoType = 0;
	BSTR pbstrMIMEType__AutoType = 0;
	BSTR pbstrRedirectUrl__AutoType = 0;

	if (pbstrLocalPath)
		*pbstrLocalPath = 0;
	if (pbstrMIMEType)
		*pbstrMIMEType = 0;
	if (pbstrRedirectUrl)
		*pbstrRedirectUrl = 0;

	__caErrChk (CA_CStringToBSTR (bstrResourceUri, &bstrResourceUri__AutoType));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechResourceLoader,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetLocalCopy_ (__vtblIFacePtr,
	                                                   bstrResourceUri__AutoType,
	                                                   &pbstrLocalPath__AutoType,
	                                                   &pbstrMIMEType__AutoType,
	                                                   &pbstrRedirectUrl__AutoType));

	if (pbstrLocalPath)
		__caErrChk (CA_BSTRGetCString (pbstrLocalPath__AutoType, pbstrLocalPath));
	if (pbstrMIMEType)
		__caErrChk (CA_BSTRGetCString (pbstrMIMEType__AutoType, pbstrMIMEType));
	if (pbstrRedirectUrl)
		__caErrChk (CA_BSTRGetCString (pbstrRedirectUrl__AutoType,
	                               pbstrRedirectUrl));

Error:
	CA_FreeBSTR (bstrResourceUri__AutoType);
	CA_FreeBSTR (pbstrLocalPath__AutoType);
	CA_FreeBSTR (pbstrMIMEType__AutoType);
	CA_FreeBSTR (pbstrRedirectUrl__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (pbstrLocalPath)
			{
			CA_FreeMemory (*pbstrLocalPath);
			*pbstrLocalPath = 0;
			}
		if (pbstrMIMEType)
			{
			CA_FreeMemory (*pbstrMIMEType);
			*pbstrMIMEType = 0;
			}
		if (pbstrRedirectUrl)
			{
			CA_FreeMemory (*pbstrRedirectUrl);
			*pbstrRedirectUrl = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechResourceLoader,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_ISpeechResourceLoaderReleaseLocalCopy (CAObjHandle objectHandle,
                                                                 ERRORINFO *errorInfo,
                                                                 const char *pbstrLocalPath)
{
	HRESULT __result = S_OK;
	SpeechLib_ISpeechResourceLoader_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	BSTR pbstrLocalPath__AutoType = 0;

	__caErrChk (CA_CStringToBSTR (pbstrLocalPath, &pbstrLocalPath__AutoType));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_ISpeechResourceLoader,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->ReleaseLocalCopy_ (__vtblIFacePtr,
	                                                       pbstrLocalPath__AutoType));

Error:
	CA_FreeBSTR (pbstrLocalPath__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_ISpeechResourceLoader,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_IInternetSecurityManagerSetSecuritySite (CAObjHandle objectHandle,
                                                                   ERRORINFO *errorInfo,
                                                                   SpeechLibObj_IInternetSecurityMgrSite pSite)
{
	HRESULT __result = S_OK;
	SpeechLib_IInternetSecurityManager_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN pSite__AutoType = 0;

	if (pSite)
		{
		__caErrChk (CA_GetInterfaceFromObjHandle (pSite,
	                                          &SpeechLib_IID_IInternetSecurityMgrSite,
	                                          1, &pSite__AutoType, NULL));
		}

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_IInternetSecurityManager,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->SetSecuritySite_ (__vtblIFacePtr,
	                                                      pSite__AutoType));

Error:
	if (pSite__AutoType)
		pSite__AutoType->lpVtbl->Release (pSite__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_IInternetSecurityManager,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_IInternetSecurityManagerGetSecuritySite (CAObjHandle objectHandle,
                                                                   ERRORINFO *errorInfo,
                                                                   SpeechLibObj_IInternetSecurityMgrSite *ppSite)
{
	HRESULT __result = S_OK;
	SpeechLib_IInternetSecurityManager_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN ppSite__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (ppSite)
		*ppSite = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_IInternetSecurityManager,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetSecuritySite_ (__vtblIFacePtr,
	                                                      &ppSite__AutoType));
	

	if (ppSite)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (ppSite__AutoType,
		                                             &SpeechLib_IID_IInternetSecurityMgrSite,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, ppSite));
		ppSite__AutoType = 0;
		}

Error:
	if (ppSite__AutoType)
		ppSite__AutoType->lpVtbl->Release (ppSite__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (ppSite)
			{
			CA_DiscardObjHandle (*ppSite);
			*ppSite = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_IInternetSecurityManager,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_IInternetSecurityManagerGetZoneMappings (CAObjHandle objectHandle,
                                                                   ERRORINFO *errorInfo,
                                                                   unsigned long dwZone,
                                                                   SpeechLibObj_IEnumString *ppenumString,
                                                                   unsigned long dwFlags)
{
	HRESULT __result = S_OK;
	SpeechLib_IInternetSecurityManager_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN ppenumString__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (ppenumString)
		*ppenumString = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_IInternetSecurityManager,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->GetZoneMappings_ (__vtblIFacePtr,
	                                                      dwZone,
	                                                      &ppenumString__AutoType,
	                                                      dwFlags));
	

	if (ppenumString)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (ppenumString__AutoType,
		                                             &SpeechLib_IID_IEnumString,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, ppenumString));
		ppenumString__AutoType = 0;
		}

Error:
	if (ppenumString__AutoType)
		ppenumString__AutoType->lpVtbl->Release (ppenumString__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (ppenumString)
			{
			CA_DiscardObjHandle (*ppenumString);
			*ppenumString = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_IInternetSecurityManager,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_IInternetSecurityMgrSiteEnableModeless (CAObjHandle objectHandle,
                                                                  ERRORINFO *errorInfo,
                                                                  long fEnable)
{
	HRESULT __result = S_OK;
	SpeechLib_IInternetSecurityMgrSite_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_IInternetSecurityMgrSite,
	                                          0, &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->EnableModeless_ (__vtblIFacePtr,
	                                                     fEnable));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_IInternetSecurityMgrSite,
	                    __result, errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_IEnumStringSkip (CAObjHandle objectHandle,
                                           ERRORINFO *errorInfo,
                                           unsigned long celt)
{
	HRESULT __result = S_OK;
	SpeechLib_IEnumString_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_IEnumString, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Skip_ (__vtblIFacePtr, celt));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_IEnumString, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_IEnumStringReset (CAObjHandle objectHandle,
                                            ERRORINFO *errorInfo)
{
	HRESULT __result = S_OK;
	SpeechLib_IEnumString_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_IEnumString, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Reset_ (__vtblIFacePtr));

Error:
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_IEnumString, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

HRESULT CVIFUNC SpeechLib_IEnumStringClone (CAObjHandle objectHandle,
                                            ERRORINFO *errorInfo,
                                            SpeechLibObj_IEnumString *ppEnum)
{
	HRESULT __result = S_OK;
	SpeechLib_IEnumString_Interface * __vtblIFacePtr = 0;
	int __didAddRef = 0;
	int __errorInfoPresent = 0;
	LPUNKNOWN ppEnum__AutoType = 0;
	LCID __locale;
	int __supportMultithreading;

	if (ppEnum)
		*ppEnum = 0;

	__caErrChk (CA_GetLocale (objectHandle, &__locale));
	__caErrChk (CA_GetSupportForMultithreading (objectHandle,
	                                            &__supportMultithreading));

	__caErrChk (CA_GetInterfaceFromObjHandle (objectHandle,
	                                          &SpeechLib_IID_IEnumString, 0,
	                                          &__vtblIFacePtr, &__didAddRef));
	__caErrChk (__vtblIFacePtr->lpVtbl->Clone_ (__vtblIFacePtr,
	                                            &ppEnum__AutoType));
	

	if (ppEnum)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (ppEnum__AutoType,
		                                             &SpeechLib_IID_IEnumString,
		                                             __supportMultithreading,
		                                             __locale, 0, 0, ppEnum));
		ppEnum__AutoType = 0;
		}

Error:
	if (ppEnum__AutoType)
		ppEnum__AutoType->lpVtbl->Release (ppEnum__AutoType);
	if (__vtblIFacePtr && __didAddRef)
		__vtblIFacePtr->lpVtbl->Release (__vtblIFacePtr);
	if (FAILED(__result))
		{
		if (ppEnum)
			{
			CA_DiscardObjHandle (*ppEnum);
			*ppEnum = 0;
			}
		}
	CA_FillErrorInfoEx (objectHandle, &SpeechLib_IID_IEnumString, __result,
	                    errorInfo, &__errorInfoPresent);
	if (__errorInfoPresent)
		__result = DISP_E_EXCEPTION;
	return __result;
}

static void CVIFUNC _ISpeechVoiceEventsRegOnStartStream_EventVTableFunc (void *thisPtr,
                                                                         long streamNumber,
                                                                         VARIANT streamPosition)
{
	HRESULT __result = S_OK;
	void * __callbackData;
	CAObjHandle __serverObjHandle;
	_ISpeechVoiceEventsRegOnStartStream_CallbackType __callbackFunction;
	
	

	__caErrChk (CA_GetEventCallback (thisPtr, 0, &__callbackFunction,
	                                 &__callbackData, &__serverObjHandle));

	if (__callbackFunction != NULL)
		{
	
		__result = __callbackFunction (__serverObjHandle, __callbackData, streamNumber,
		                               streamPosition);
	
		__caErrChk (__result);
		
		}
Error:

	return;
}

static void CVIFUNC _ISpeechVoiceEventsRegOnEndStream_EventVTableFunc (void *thisPtr,
                                                                       long streamNumber,
                                                                       VARIANT streamPosition)
{
	HRESULT __result = S_OK;
	void * __callbackData;
	CAObjHandle __serverObjHandle;
	_ISpeechVoiceEventsRegOnEndStream_CallbackType __callbackFunction;
	
	

	__caErrChk (CA_GetEventCallback (thisPtr, 1, &__callbackFunction,
	                                 &__callbackData, &__serverObjHandle));

	if (__callbackFunction != NULL)
		{
	
		__result = __callbackFunction (__serverObjHandle, __callbackData, streamNumber,
		                               streamPosition);
	
		__caErrChk (__result);
		
		}
Error:

	return;
}

static void CVIFUNC _ISpeechVoiceEventsRegOnVoiceChange_EventVTableFunc (void *thisPtr,
                                                                         long streamNumber,
                                                                         VARIANT streamPosition,
                                                                         LPDISPATCH voiceObjectToken)
{
	HRESULT __result = S_OK;
	void * __callbackData;
	CAObjHandle __serverObjHandle;
	_ISpeechVoiceEventsRegOnVoiceChange_CallbackType __callbackFunction;
	CAObjHandle voiceObjectToken__CType = 0;
	
	

	__caErrChk (CA_GetEventCallback (thisPtr, 2, &__callbackFunction,
	                                 &__callbackData, &__serverObjHandle));

	if (__callbackFunction != NULL)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (voiceObjectToken,
		                                             &IID_IDispatch, 0,
		                                             LOCALE_NEUTRAL, 0, 1,
		                                             &voiceObjectToken__CType));
	
		__result = __callbackFunction (__serverObjHandle, __callbackData, streamNumber,
		                               streamPosition, voiceObjectToken__CType);
	
		__caErrChk (__result);
		
		}
Error:
	CA_DiscardObjHandle (voiceObjectToken__CType);

	return;
}

static void CVIFUNC _ISpeechVoiceEventsRegOnBookmark_EventVTableFunc (void *thisPtr,
                                                                      long streamNumber,
                                                                      VARIANT streamPosition,
                                                                      BSTR bookmark,
                                                                      long bookmarkId)
{
	HRESULT __result = S_OK;
	void * __callbackData;
	CAObjHandle __serverObjHandle;
	_ISpeechVoiceEventsRegOnBookmark_CallbackType __callbackFunction;
	char * bookmark__CType = 0;
	
	

	__caErrChk (CA_GetEventCallback (thisPtr, 3, &__callbackFunction,
	                                 &__callbackData, &__serverObjHandle));

	if (__callbackFunction != NULL)
		{
		__caErrChk (CA_BSTRGetCString (bookmark, &bookmark__CType));
	
		__result = __callbackFunction (__serverObjHandle, __callbackData, streamNumber,
		                               streamPosition, bookmark__CType, bookmarkId);
	
		__caErrChk (__result);
		
		}
Error:
	CA_FreeMemory (bookmark__CType);

	return;
}

static void CVIFUNC _ISpeechVoiceEventsRegOnWord_EventVTableFunc (void *thisPtr,
                                                                  long streamNumber,
                                                                  VARIANT streamPosition,
                                                                  long characterPosition,
                                                                  long length)
{
	HRESULT __result = S_OK;
	void * __callbackData;
	CAObjHandle __serverObjHandle;
	_ISpeechVoiceEventsRegOnWord_CallbackType __callbackFunction;
	
	

	__caErrChk (CA_GetEventCallback (thisPtr, 4, &__callbackFunction,
	                                 &__callbackData, &__serverObjHandle));

	if (__callbackFunction != NULL)
		{
	
		__result = __callbackFunction (__serverObjHandle, __callbackData, streamNumber,
		                               streamPosition, characterPosition, length);
	
		__caErrChk (__result);
		
		}
Error:

	return;
}

static void CVIFUNC _ISpeechVoiceEventsRegOnSentence_EventVTableFunc (void *thisPtr,
                                                                      long streamNumber,
                                                                      VARIANT streamPosition,
                                                                      long characterPosition,
                                                                      long length)
{
	HRESULT __result = S_OK;
	void * __callbackData;
	CAObjHandle __serverObjHandle;
	_ISpeechVoiceEventsRegOnSentence_CallbackType __callbackFunction;
	
	

	__caErrChk (CA_GetEventCallback (thisPtr, 5, &__callbackFunction,
	                                 &__callbackData, &__serverObjHandle));

	if (__callbackFunction != NULL)
		{
	
		__result = __callbackFunction (__serverObjHandle, __callbackData, streamNumber,
		                               streamPosition, characterPosition, length);
	
		__caErrChk (__result);
		
		}
Error:

	return;
}

static void CVIFUNC _ISpeechVoiceEventsRegOnPhoneme_EventVTableFunc (void *thisPtr,
                                                                     long streamNumber,
                                                                     VARIANT streamPosition,
                                                                     long duration,
                                                                     short nextPhoneId,
                                                                     long feature,
                                                                     short currentPhoneId)
{
	HRESULT __result = S_OK;
	void * __callbackData;
	CAObjHandle __serverObjHandle;
	_ISpeechVoiceEventsRegOnPhoneme_CallbackType __callbackFunction;
	
	

	__caErrChk (CA_GetEventCallback (thisPtr, 6, &__callbackFunction,
	                                 &__callbackData, &__serverObjHandle));

	if (__callbackFunction != NULL)
		{
	
		__result = __callbackFunction (__serverObjHandle, __callbackData, streamNumber,
		                               streamPosition, duration, nextPhoneId, feature,
		                               currentPhoneId);
	
		__caErrChk (__result);
		
		}
Error:

	return;
}

static void CVIFUNC _ISpeechVoiceEventsRegOnViseme_EventVTableFunc (void *thisPtr,
                                                                    long streamNumber,
                                                                    VARIANT streamPosition,
                                                                    long duration,
                                                                    long nextVisemeId,
                                                                    long feature,
                                                                    long currentVisemeId)
{
	HRESULT __result = S_OK;
	void * __callbackData;
	CAObjHandle __serverObjHandle;
	_ISpeechVoiceEventsRegOnViseme_CallbackType __callbackFunction;
	
	

	__caErrChk (CA_GetEventCallback (thisPtr, 7, &__callbackFunction,
	                                 &__callbackData, &__serverObjHandle));

	if (__callbackFunction != NULL)
		{
	
		__result = __callbackFunction (__serverObjHandle, __callbackData, streamNumber,
		                               streamPosition, duration, nextVisemeId, feature,
		                               currentVisemeId);
	
		__caErrChk (__result);
		
		}
Error:

	return;
}

static void CVIFUNC _ISpeechVoiceEventsRegOnAudioLevel_EventVTableFunc (void *thisPtr,
                                                                        long streamNumber,
                                                                        VARIANT streamPosition,
                                                                        long audioLevel)
{
	HRESULT __result = S_OK;
	void * __callbackData;
	CAObjHandle __serverObjHandle;
	_ISpeechVoiceEventsRegOnAudioLevel_CallbackType __callbackFunction;
	
	

	__caErrChk (CA_GetEventCallback (thisPtr, 8, &__callbackFunction,
	                                 &__callbackData, &__serverObjHandle));

	if (__callbackFunction != NULL)
		{
	
		__result = __callbackFunction (__serverObjHandle, __callbackData, streamNumber,
		                               streamPosition, audioLevel);
	
		__caErrChk (__result);
		
		}
Error:

	return;
}

static void CVIFUNC _ISpeechVoiceEventsRegOnEnginePrivate_EventVTableFunc (void *thisPtr,
                                                                           long streamNumber,
                                                                           long streamPosition,
                                                                           VARIANT engineData)
{
	HRESULT __result = S_OK;
	void * __callbackData;
	CAObjHandle __serverObjHandle;
	_ISpeechVoiceEventsRegOnEnginePrivate_CallbackType __callbackFunction;
	
	

	__caErrChk (CA_GetEventCallback (thisPtr, 9, &__callbackFunction,
	                                 &__callbackData, &__serverObjHandle));

	if (__callbackFunction != NULL)
		{
	
		__result = __callbackFunction (__serverObjHandle, __callbackData, streamNumber,
		                               streamPosition, engineData);
	
		__caErrChk (__result);
		
		}
Error:

	return;
}

static void CVIFUNC _ISpeechRecoContextEventsRegOnStartStream_EventVTableFunc (void *thisPtr,
                                                                               long streamNumber,
                                                                               VARIANT streamPosition)
{
	HRESULT __result = S_OK;
	void * __callbackData;
	CAObjHandle __serverObjHandle;
	_ISpeechRecoContextEventsRegOnStartStream_CallbackType __callbackFunction;
	
	

	__caErrChk (CA_GetEventCallback (thisPtr, 0, &__callbackFunction,
	                                 &__callbackData, &__serverObjHandle));

	if (__callbackFunction != NULL)
		{
	
		__result = __callbackFunction (__serverObjHandle, __callbackData, streamNumber,
		                               streamPosition);
	
		__caErrChk (__result);
		
		}
Error:

	return;
}

static void CVIFUNC _ISpeechRecoContextEventsRegOnEndStream_EventVTableFunc (void *thisPtr,
                                                                             long streamNumber,
                                                                             VARIANT streamPosition,
                                                                             VBOOL streamReleased)
{
	HRESULT __result = S_OK;
	void * __callbackData;
	CAObjHandle __serverObjHandle;
	_ISpeechRecoContextEventsRegOnEndStream_CallbackType __callbackFunction;
	
	

	__caErrChk (CA_GetEventCallback (thisPtr, 1, &__callbackFunction,
	                                 &__callbackData, &__serverObjHandle));

	if (__callbackFunction != NULL)
		{
	
		__result = __callbackFunction (__serverObjHandle, __callbackData, streamNumber,
		                               streamPosition, streamReleased);
	
		__caErrChk (__result);
		
		}
Error:

	return;
}

static void CVIFUNC _ISpeechRecoContextEventsRegOnBookmark_EventVTableFunc (void *thisPtr,
                                                                            long streamNumber,
                                                                            VARIANT streamPosition,
                                                                            VARIANT bookmarkId,
                                                                            long options)
{
	HRESULT __result = S_OK;
	void * __callbackData;
	CAObjHandle __serverObjHandle;
	_ISpeechRecoContextEventsRegOnBookmark_CallbackType __callbackFunction;
	
	

	__caErrChk (CA_GetEventCallback (thisPtr, 2, &__callbackFunction,
	                                 &__callbackData, &__serverObjHandle));

	if (__callbackFunction != NULL)
		{
	
		__result = __callbackFunction (__serverObjHandle, __callbackData, streamNumber,
		                               streamPosition, bookmarkId, options);
	
		__caErrChk (__result);
		
		}
Error:

	return;
}

static void CVIFUNC _ISpeechRecoContextEventsRegOnSoundStart_EventVTableFunc (void *thisPtr,
                                                                              long streamNumber,
                                                                              VARIANT streamPosition)
{
	HRESULT __result = S_OK;
	void * __callbackData;
	CAObjHandle __serverObjHandle;
	_ISpeechRecoContextEventsRegOnSoundStart_CallbackType __callbackFunction;
	
	

	__caErrChk (CA_GetEventCallback (thisPtr, 3, &__callbackFunction,
	                                 &__callbackData, &__serverObjHandle));

	if (__callbackFunction != NULL)
		{
	
		__result = __callbackFunction (__serverObjHandle, __callbackData, streamNumber,
		                               streamPosition);
	
		__caErrChk (__result);
		
		}
Error:

	return;
}

static void CVIFUNC _ISpeechRecoContextEventsRegOnSoundEnd_EventVTableFunc (void *thisPtr,
                                                                            long streamNumber,
                                                                            VARIANT streamPosition)
{
	HRESULT __result = S_OK;
	void * __callbackData;
	CAObjHandle __serverObjHandle;
	_ISpeechRecoContextEventsRegOnSoundEnd_CallbackType __callbackFunction;
	
	

	__caErrChk (CA_GetEventCallback (thisPtr, 4, &__callbackFunction,
	                                 &__callbackData, &__serverObjHandle));

	if (__callbackFunction != NULL)
		{
	
		__result = __callbackFunction (__serverObjHandle, __callbackData, streamNumber,
		                               streamPosition);
	
		__caErrChk (__result);
		
		}
Error:

	return;
}

static void CVIFUNC _ISpeechRecoContextEventsRegOnPhraseStart_EventVTableFunc (void *thisPtr,
                                                                               long streamNumber,
                                                                               VARIANT streamPosition)
{
	HRESULT __result = S_OK;
	void * __callbackData;
	CAObjHandle __serverObjHandle;
	_ISpeechRecoContextEventsRegOnPhraseStart_CallbackType __callbackFunction;
	
	

	__caErrChk (CA_GetEventCallback (thisPtr, 5, &__callbackFunction,
	                                 &__callbackData, &__serverObjHandle));

	if (__callbackFunction != NULL)
		{
	
		__result = __callbackFunction (__serverObjHandle, __callbackData, streamNumber,
		                               streamPosition);
	
		__caErrChk (__result);
		
		}
Error:

	return;
}

static void CVIFUNC _ISpeechRecoContextEventsRegOnRecognition_EventVTableFunc (void *thisPtr,
                                                                               long streamNumber,
                                                                               VARIANT streamPosition,
                                                                               long recognitionType,
                                                                               LPDISPATCH result)
{
	HRESULT __result = S_OK;
	void * __callbackData;
	CAObjHandle __serverObjHandle;
	_ISpeechRecoContextEventsRegOnRecognition_CallbackType __callbackFunction;
	CAObjHandle result__CType = 0;
	
	

	__caErrChk (CA_GetEventCallback (thisPtr, 6, &__callbackFunction,
	                                 &__callbackData, &__serverObjHandle));

	if (__callbackFunction != NULL)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (result, &IID_IDispatch, 0,
		                                             LOCALE_NEUTRAL, 0, 1,
		                                             &result__CType));
	
		__result = __callbackFunction (__serverObjHandle, __callbackData, streamNumber,
		                               streamPosition, recognitionType, result__CType);
	
		__caErrChk (__result);
		
		}
Error:
	CA_DiscardObjHandle (result__CType);

	return;
}

static void CVIFUNC _ISpeechRecoContextEventsRegOnHypothesis_EventVTableFunc (void *thisPtr,
                                                                              long streamNumber,
                                                                              VARIANT streamPosition,
                                                                              LPDISPATCH result)
{
	HRESULT __result = S_OK;
	void * __callbackData;
	CAObjHandle __serverObjHandle;
	_ISpeechRecoContextEventsRegOnHypothesis_CallbackType __callbackFunction;
	CAObjHandle result__CType = 0;
	
	

	__caErrChk (CA_GetEventCallback (thisPtr, 7, &__callbackFunction,
	                                 &__callbackData, &__serverObjHandle));

	if (__callbackFunction != NULL)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (result, &IID_IDispatch, 0,
		                                             LOCALE_NEUTRAL, 0, 1,
		                                             &result__CType));
	
		__result = __callbackFunction (__serverObjHandle, __callbackData, streamNumber,
		                               streamPosition, result__CType);
	
		__caErrChk (__result);
		
		}
Error:
	CA_DiscardObjHandle (result__CType);

	return;
}

static void CVIFUNC _ISpeechRecoContextEventsRegOnPropertyNumberChange_EventVTableFunc (void *thisPtr,
                                                                                        long streamNumber,
                                                                                        VARIANT streamPosition,
                                                                                        BSTR propertyName,
                                                                                        long newNumberValue)
{
	HRESULT __result = S_OK;
	void * __callbackData;
	CAObjHandle __serverObjHandle;
	_ISpeechRecoContextEventsRegOnPropertyNumberChange_CallbackType __callbackFunction;
	char * propertyName__CType = 0;
	
	

	__caErrChk (CA_GetEventCallback (thisPtr, 8, &__callbackFunction,
	                                 &__callbackData, &__serverObjHandle));

	if (__callbackFunction != NULL)
		{
		__caErrChk (CA_BSTRGetCString (propertyName, &propertyName__CType));
	
		__result = __callbackFunction (__serverObjHandle, __callbackData, streamNumber,
		                               streamPosition, propertyName__CType,
		                               newNumberValue);
	
		__caErrChk (__result);
		
		}
Error:
	CA_FreeMemory (propertyName__CType);

	return;
}

static void CVIFUNC _ISpeechRecoContextEventsRegOnPropertyStringChange_EventVTableFunc (void *thisPtr,
                                                                                        long streamNumber,
                                                                                        VARIANT streamPosition,
                                                                                        BSTR propertyName,
                                                                                        BSTR newStringValue)
{
	HRESULT __result = S_OK;
	void * __callbackData;
	CAObjHandle __serverObjHandle;
	_ISpeechRecoContextEventsRegOnPropertyStringChange_CallbackType __callbackFunction;
	char * propertyName__CType = 0;
	char * newStringValue__CType = 0;
	
	

	__caErrChk (CA_GetEventCallback (thisPtr, 9, &__callbackFunction,
	                                 &__callbackData, &__serverObjHandle));

	if (__callbackFunction != NULL)
		{
		__caErrChk (CA_BSTRGetCString (propertyName, &propertyName__CType));
		__caErrChk (CA_BSTRGetCString (newStringValue, &newStringValue__CType));
	
		__result = __callbackFunction (__serverObjHandle, __callbackData, streamNumber,
		                               streamPosition, propertyName__CType,
		                               newStringValue__CType);
	
		__caErrChk (__result);
		
		}
Error:
	CA_FreeMemory (propertyName__CType);
	CA_FreeMemory (newStringValue__CType);

	return;
}

static void CVIFUNC _ISpeechRecoContextEventsRegOnFalseRecognition_EventVTableFunc (void *thisPtr,
                                                                                    long streamNumber,
                                                                                    VARIANT streamPosition,
                                                                                    LPDISPATCH result)
{
	HRESULT __result = S_OK;
	void * __callbackData;
	CAObjHandle __serverObjHandle;
	_ISpeechRecoContextEventsRegOnFalseRecognition_CallbackType __callbackFunction;
	CAObjHandle result__CType = 0;
	
	

	__caErrChk (CA_GetEventCallback (thisPtr, 10, &__callbackFunction,
	                                 &__callbackData, &__serverObjHandle));

	if (__callbackFunction != NULL)
		{
		__caErrChk (CA_CreateObjHandleFromInterface (result, &IID_IDispatch, 0,
		                                             LOCALE_NEUTRAL, 0, 1,
		                                             &result__CType));
	
		__result = __callbackFunction (__serverObjHandle, __callbackData, streamNumber,
		                               streamPosition, result__CType);
	
		__caErrChk (__result);
		
		}
Error:
	CA_DiscardObjHandle (result__CType);

	return;
}

static void CVIFUNC _ISpeechRecoContextEventsRegOnInterference_EventVTableFunc (void *thisPtr,
                                                                                long streamNumber,
                                                                                VARIANT streamPosition,
                                                                                long interference)
{
	HRESULT __result = S_OK;
	void * __callbackData;
	CAObjHandle __serverObjHandle;
	_ISpeechRecoContextEventsRegOnInterference_CallbackType __callbackFunction;
	
	

	__caErrChk (CA_GetEventCallback (thisPtr, 11, &__callbackFunction,
	                                 &__callbackData, &__serverObjHandle));

	if (__callbackFunction != NULL)
		{
	
		__result = __callbackFunction (__serverObjHandle, __callbackData, streamNumber,
		                               streamPosition, interference);
	
		__caErrChk (__result);
		
		}
Error:

	return;
}

static void CVIFUNC _ISpeechRecoContextEventsRegOnRequestUI_EventVTableFunc (void *thisPtr,
                                                                             long streamNumber,
                                                                             VARIANT streamPosition,
                                                                             BSTR UIType)
{
	HRESULT __result = S_OK;
	void * __callbackData;
	CAObjHandle __serverObjHandle;
	_ISpeechRecoContextEventsRegOnRequestUI_CallbackType __callbackFunction;
	char * UIType__CType = 0;
	
	

	__caErrChk (CA_GetEventCallback (thisPtr, 12, &__callbackFunction,
	                                 &__callbackData, &__serverObjHandle));

	if (__callbackFunction != NULL)
		{
		__caErrChk (CA_BSTRGetCString (UIType, &UIType__CType));
	
		__result = __callbackFunction (__serverObjHandle, __callbackData, streamNumber,
		                               streamPosition, UIType__CType);
	
		__caErrChk (__result);
		
		}
Error:
	CA_FreeMemory (UIType__CType);

	return;
}

static void CVIFUNC _ISpeechRecoContextEventsRegOnRecognizerStateChange_EventVTableFunc (void *thisPtr,
                                                                                         long streamNumber,
                                                                                         VARIANT streamPosition,
                                                                                         long newState)
{
	HRESULT __result = S_OK;
	void * __callbackData;
	CAObjHandle __serverObjHandle;
	_ISpeechRecoContextEventsRegOnRecognizerStateChange_CallbackType __callbackFunction;
	
	

	__caErrChk (CA_GetEventCallback (thisPtr, 13, &__callbackFunction,
	                                 &__callbackData, &__serverObjHandle));

	if (__callbackFunction != NULL)
		{
	
		__result = __callbackFunction (__serverObjHandle, __callbackData, streamNumber,
		                               streamPosition, newState);
	
		__caErrChk (__result);
		
		}
Error:

	return;
}

static void CVIFUNC _ISpeechRecoContextEventsRegOnAdaptation_EventVTableFunc (void *thisPtr,
                                                                              long streamNumber,
                                                                              VARIANT streamPosition)
{
	HRESULT __result = S_OK;
	void * __callbackData;
	CAObjHandle __serverObjHandle;
	_ISpeechRecoContextEventsRegOnAdaptation_CallbackType __callbackFunction;
	
	

	__caErrChk (CA_GetEventCallback (thisPtr, 14, &__callbackFunction,
	                                 &__callbackData, &__serverObjHandle));

	if (__callbackFunction != NULL)
		{
	
		__result = __callbackFunction (__serverObjHandle, __callbackData, streamNumber,
		                               streamPosition);
	
		__caErrChk (__result);
		
		}
Error:

	return;
}

static void CVIFUNC _ISpeechRecoContextEventsRegOnRecognitionForOtherContext_EventVTableFunc (void *thisPtr,
                                                                                              long streamNumber,
                                                                                              VARIANT streamPosition)
{
	HRESULT __result = S_OK;
	void * __callbackData;
	CAObjHandle __serverObjHandle;
	_ISpeechRecoContextEventsRegOnRecognitionForOtherContext_CallbackType __callbackFunction;
	
	

	__caErrChk (CA_GetEventCallback (thisPtr, 15, &__callbackFunction,
	                                 &__callbackData, &__serverObjHandle));

	if (__callbackFunction != NULL)
		{
	
		__result = __callbackFunction (__serverObjHandle, __callbackData, streamNumber,
		                               streamPosition);
	
		__caErrChk (__result);
		
		}
Error:

	return;
}

static void CVIFUNC _ISpeechRecoContextEventsRegOnAudioLevel_EventVTableFunc (void *thisPtr,
                                                                              long streamNumber,
                                                                              VARIANT streamPosition,
                                                                              long audioLevel)
{
	HRESULT __result = S_OK;
	void * __callbackData;
	CAObjHandle __serverObjHandle;
	_ISpeechRecoContextEventsRegOnAudioLevel_CallbackType __callbackFunction;
	
	

	__caErrChk (CA_GetEventCallback (thisPtr, 16, &__callbackFunction,
	                                 &__callbackData, &__serverObjHandle));

	if (__callbackFunction != NULL)
		{
	
		__result = __callbackFunction (__serverObjHandle, __callbackData, streamNumber,
		                               streamPosition, audioLevel);
	
		__caErrChk (__result);
		
		}
Error:

	return;
}

static void CVIFUNC _ISpeechRecoContextEventsRegOnEnginePrivate_EventVTableFunc (void *thisPtr,
                                                                                 long streamNumber,
                                                                                 VARIANT streamPosition,
                                                                                 VARIANT engineData)
{
	HRESULT __result = S_OK;
	void * __callbackData;
	CAObjHandle __serverObjHandle;
	_ISpeechRecoContextEventsRegOnEnginePrivate_CallbackType __callbackFunction;
	
	

	__caErrChk (CA_GetEventCallback (thisPtr, 17, &__callbackFunction,
	                                 &__callbackData, &__serverObjHandle));

	if (__callbackFunction != NULL)
		{
	
		__result = __callbackFunction (__serverObjHandle, __callbackData, streamNumber,
		                               streamPosition, engineData);
	
		__caErrChk (__result);
		
		}
Error:

	return;
}

HRESULT CVIFUNC SpeechLib__ISpeechVoiceEventsRegOnStartStream (CAObjHandle serverObject,
                                                               _ISpeechVoiceEventsRegOnStartStream_CallbackType callbackFunction,
                                                               void *callbackData,
                                                               int enableCallbacks,
                                                               int *callbackId)
{
	HRESULT __result = S_OK;

	__result = CA_RegisterEventCallback (serverObject,
	                                     &__ISpeechVoiceEvents_CAEventClassDefn,
	                                     0, callbackFunction, callbackData,
	                                     enableCallbacks, callbackId);

	return __result;
}

HRESULT CVIFUNC SpeechLib__ISpeechVoiceEventsRegOnEndStream (CAObjHandle serverObject,
                                                             _ISpeechVoiceEventsRegOnEndStream_CallbackType callbackFunction,
                                                             void *callbackData,
                                                             int enableCallbacks,
                                                             int *callbackId)
{
	HRESULT __result = S_OK;

	__result = CA_RegisterEventCallback (serverObject,
	                                     &__ISpeechVoiceEvents_CAEventClassDefn,
	                                     1, callbackFunction, callbackData,
	                                     enableCallbacks, callbackId);

	return __result;
}

HRESULT CVIFUNC SpeechLib__ISpeechVoiceEventsRegOnVoiceChange (CAObjHandle serverObject,
                                                               _ISpeechVoiceEventsRegOnVoiceChange_CallbackType callbackFunction,
                                                               void *callbackData,
                                                               int enableCallbacks,
                                                               int *callbackId)
{
	HRESULT __result = S_OK;

	__result = CA_RegisterEventCallback (serverObject,
	                                     &__ISpeechVoiceEvents_CAEventClassDefn,
	                                     2, callbackFunction, callbackData,
	                                     enableCallbacks, callbackId);

	return __result;
}

HRESULT CVIFUNC SpeechLib__ISpeechVoiceEventsRegOnBookmark (CAObjHandle serverObject,
                                                            _ISpeechVoiceEventsRegOnBookmark_CallbackType callbackFunction,
                                                            void *callbackData,
                                                            int enableCallbacks,
                                                            int *callbackId)
{
	HRESULT __result = S_OK;

	__result = CA_RegisterEventCallback (serverObject,
	                                     &__ISpeechVoiceEvents_CAEventClassDefn,
	                                     3, callbackFunction, callbackData,
	                                     enableCallbacks, callbackId);

	return __result;
}

HRESULT CVIFUNC SpeechLib__ISpeechVoiceEventsRegOnWord (CAObjHandle serverObject,
                                                        _ISpeechVoiceEventsRegOnWord_CallbackType callbackFunction,
                                                        void *callbackData,
                                                        int enableCallbacks,
                                                        int *callbackId)
{
	HRESULT __result = S_OK;

	__result = CA_RegisterEventCallback (serverObject,
	                                     &__ISpeechVoiceEvents_CAEventClassDefn,
	                                     4, callbackFunction, callbackData,
	                                     enableCallbacks, callbackId);

	return __result;
}

HRESULT CVIFUNC SpeechLib__ISpeechVoiceEventsRegOnSentence (CAObjHandle serverObject,
                                                            _ISpeechVoiceEventsRegOnSentence_CallbackType callbackFunction,
                                                            void *callbackData,
                                                            int enableCallbacks,
                                                            int *callbackId)
{
	HRESULT __result = S_OK;

	__result = CA_RegisterEventCallback (serverObject,
	                                     &__ISpeechVoiceEvents_CAEventClassDefn,
	                                     5, callbackFunction, callbackData,
	                                     enableCallbacks, callbackId);

	return __result;
}

HRESULT CVIFUNC SpeechLib__ISpeechVoiceEventsRegOnPhoneme (CAObjHandle serverObject,
                                                           _ISpeechVoiceEventsRegOnPhoneme_CallbackType callbackFunction,
                                                           void *callbackData,
                                                           int enableCallbacks,
                                                           int *callbackId)
{
	HRESULT __result = S_OK;

	__result = CA_RegisterEventCallback (serverObject,
	                                     &__ISpeechVoiceEvents_CAEventClassDefn,
	                                     6, callbackFunction, callbackData,
	                                     enableCallbacks, callbackId);

	return __result;
}

HRESULT CVIFUNC SpeechLib__ISpeechVoiceEventsRegOnViseme (CAObjHandle serverObject,
                                                          _ISpeechVoiceEventsRegOnViseme_CallbackType callbackFunction,
                                                          void *callbackData,
                                                          int enableCallbacks,
                                                          int *callbackId)
{
	HRESULT __result = S_OK;

	__result = CA_RegisterEventCallback (serverObject,
	                                     &__ISpeechVoiceEvents_CAEventClassDefn,
	                                     7, callbackFunction, callbackData,
	                                     enableCallbacks, callbackId);

	return __result;
}

HRESULT CVIFUNC SpeechLib__ISpeechVoiceEventsRegOnAudioLevel (CAObjHandle serverObject,
                                                              _ISpeechVoiceEventsRegOnAudioLevel_CallbackType callbackFunction,
                                                              void *callbackData,
                                                              int enableCallbacks,
                                                              int *callbackId)
{
	HRESULT __result = S_OK;

	__result = CA_RegisterEventCallback (serverObject,
	                                     &__ISpeechVoiceEvents_CAEventClassDefn,
	                                     8, callbackFunction, callbackData,
	                                     enableCallbacks, callbackId);

	return __result;
}

HRESULT CVIFUNC SpeechLib__ISpeechVoiceEventsRegOnEnginePrivate (CAObjHandle serverObject,
                                                                 _ISpeechVoiceEventsRegOnEnginePrivate_CallbackType callbackFunction,
                                                                 void *callbackData,
                                                                 int enableCallbacks,
                                                                 int *callbackId)
{
	HRESULT __result = S_OK;

	__result = CA_RegisterEventCallback (serverObject,
	                                     &__ISpeechVoiceEvents_CAEventClassDefn,
	                                     9, callbackFunction, callbackData,
	                                     enableCallbacks, callbackId);

	return __result;
}

HRESULT CVIFUNC SpeechLib__ISpeechRecoContextEventsRegOnStartStream (CAObjHandle serverObject,
                                                                     _ISpeechRecoContextEventsRegOnStartStream_CallbackType callbackFunction,
                                                                     void *callbackData,
                                                                     int enableCallbacks,
                                                                     int *callbackId)
{
	HRESULT __result = S_OK;

	__result = CA_RegisterEventCallback (serverObject,
	                                     &__ISpeechRecoContextEvents_CAEventClassDefn,
	                                     0, callbackFunction, callbackData,
	                                     enableCallbacks, callbackId);

	return __result;
}

HRESULT CVIFUNC SpeechLib__ISpeechRecoContextEventsRegOnEndStream (CAObjHandle serverObject,
                                                                   _ISpeechRecoContextEventsRegOnEndStream_CallbackType callbackFunction,
                                                                   void *callbackData,
                                                                   int enableCallbacks,
                                                                   int *callbackId)
{
	HRESULT __result = S_OK;

	__result = CA_RegisterEventCallback (serverObject,
	                                     &__ISpeechRecoContextEvents_CAEventClassDefn,
	                                     1, callbackFunction, callbackData,
	                                     enableCallbacks, callbackId);

	return __result;
}

HRESULT CVIFUNC SpeechLib__ISpeechRecoContextEventsRegOnBookmark (CAObjHandle serverObject,
                                                                  _ISpeechRecoContextEventsRegOnBookmark_CallbackType callbackFunction,
                                                                  void *callbackData,
                                                                  int enableCallbacks,
                                                                  int *callbackId)
{
	HRESULT __result = S_OK;

	__result = CA_RegisterEventCallback (serverObject,
	                                     &__ISpeechRecoContextEvents_CAEventClassDefn,
	                                     2, callbackFunction, callbackData,
	                                     enableCallbacks, callbackId);

	return __result;
}

HRESULT CVIFUNC SpeechLib__ISpeechRecoContextEventsRegOnSoundStart (CAObjHandle serverObject,
                                                                    _ISpeechRecoContextEventsRegOnSoundStart_CallbackType callbackFunction,
                                                                    void *callbackData,
                                                                    int enableCallbacks,
                                                                    int *callbackId)
{
	HRESULT __result = S_OK;

	__result = CA_RegisterEventCallback (serverObject,
	                                     &__ISpeechRecoContextEvents_CAEventClassDefn,
	                                     3, callbackFunction, callbackData,
	                                     enableCallbacks, callbackId);

	return __result;
}

HRESULT CVIFUNC SpeechLib__ISpeechRecoContextEventsRegOnSoundEnd (CAObjHandle serverObject,
                                                                  _ISpeechRecoContextEventsRegOnSoundEnd_CallbackType callbackFunction,
                                                                  void *callbackData,
                                                                  int enableCallbacks,
                                                                  int *callbackId)
{
	HRESULT __result = S_OK;

	__result = CA_RegisterEventCallback (serverObject,
	                                     &__ISpeechRecoContextEvents_CAEventClassDefn,
	                                     4, callbackFunction, callbackData,
	                                     enableCallbacks, callbackId);

	return __result;
}

HRESULT CVIFUNC SpeechLib__ISpeechRecoContextEventsRegOnPhraseStart (CAObjHandle serverObject,
                                                                     _ISpeechRecoContextEventsRegOnPhraseStart_CallbackType callbackFunction,
                                                                     void *callbackData,
                                                                     int enableCallbacks,
                                                                     int *callbackId)
{
	HRESULT __result = S_OK;

	__result = CA_RegisterEventCallback (serverObject,
	                                     &__ISpeechRecoContextEvents_CAEventClassDefn,
	                                     5, callbackFunction, callbackData,
	                                     enableCallbacks, callbackId);

	return __result;
}

HRESULT CVIFUNC SpeechLib__ISpeechRecoContextEventsRegOnRecognition (CAObjHandle serverObject,
                                                                     _ISpeechRecoContextEventsRegOnRecognition_CallbackType callbackFunction,
                                                                     void *callbackData,
                                                                     int enableCallbacks,
                                                                     int *callbackId)
{
	HRESULT __result = S_OK;

	__result = CA_RegisterEventCallback (serverObject,
	                                     &__ISpeechRecoContextEvents_CAEventClassDefn,
	                                     6, callbackFunction, callbackData,
	                                     enableCallbacks, callbackId);

	return __result;
}

HRESULT CVIFUNC SpeechLib__ISpeechRecoContextEventsRegOnHypothesis (CAObjHandle serverObject,
                                                                    _ISpeechRecoContextEventsRegOnHypothesis_CallbackType callbackFunction,
                                                                    void *callbackData,
                                                                    int enableCallbacks,
                                                                    int *callbackId)
{
	HRESULT __result = S_OK;

	__result = CA_RegisterEventCallback (serverObject,
	                                     &__ISpeechRecoContextEvents_CAEventClassDefn,
	                                     7, callbackFunction, callbackData,
	                                     enableCallbacks, callbackId);

	return __result;
}

HRESULT CVIFUNC SpeechLib__ISpeechRecoContextEventsRegOnPropertyNumberChange (CAObjHandle serverObject,
                                                                              _ISpeechRecoContextEventsRegOnPropertyNumberChange_CallbackType callbackFunction,
                                                                              void *callbackData,
                                                                              int enableCallbacks,
                                                                              int *callbackId)
{
	HRESULT __result = S_OK;

	__result = CA_RegisterEventCallback (serverObject,
	                                     &__ISpeechRecoContextEvents_CAEventClassDefn,
	                                     8, callbackFunction, callbackData,
	                                     enableCallbacks, callbackId);

	return __result;
}

HRESULT CVIFUNC SpeechLib__ISpeechRecoContextEventsRegOnPropertyStringChange (CAObjHandle serverObject,
                                                                              _ISpeechRecoContextEventsRegOnPropertyStringChange_CallbackType callbackFunction,
                                                                              void *callbackData,
                                                                              int enableCallbacks,
                                                                              int *callbackId)
{
	HRESULT __result = S_OK;

	__result = CA_RegisterEventCallback (serverObject,
	                                     &__ISpeechRecoContextEvents_CAEventClassDefn,
	                                     9, callbackFunction, callbackData,
	                                     enableCallbacks, callbackId);

	return __result;
}

HRESULT CVIFUNC SpeechLib__ISpeechRecoContextEventsRegOnFalseRecognition (CAObjHandle serverObject,
                                                                          _ISpeechRecoContextEventsRegOnFalseRecognition_CallbackType callbackFunction,
                                                                          void *callbackData,
                                                                          int enableCallbacks,
                                                                          int *callbackId)
{
	HRESULT __result = S_OK;

	__result = CA_RegisterEventCallback (serverObject,
	                                     &__ISpeechRecoContextEvents_CAEventClassDefn,
	                                     10, callbackFunction, callbackData,
	                                     enableCallbacks, callbackId);

	return __result;
}

HRESULT CVIFUNC SpeechLib__ISpeechRecoContextEventsRegOnInterference (CAObjHandle serverObject,
                                                                      _ISpeechRecoContextEventsRegOnInterference_CallbackType callbackFunction,
                                                                      void *callbackData,
                                                                      int enableCallbacks,
                                                                      int *callbackId)
{
	HRESULT __result = S_OK;

	__result = CA_RegisterEventCallback (serverObject,
	                                     &__ISpeechRecoContextEvents_CAEventClassDefn,
	                                     11, callbackFunction, callbackData,
	                                     enableCallbacks, callbackId);

	return __result;
}

HRESULT CVIFUNC SpeechLib__ISpeechRecoContextEventsRegOnRequestUI (CAObjHandle serverObject,
                                                                   _ISpeechRecoContextEventsRegOnRequestUI_CallbackType callbackFunction,
                                                                   void *callbackData,
                                                                   int enableCallbacks,
                                                                   int *callbackId)
{
	HRESULT __result = S_OK;

	__result = CA_RegisterEventCallback (serverObject,
	                                     &__ISpeechRecoContextEvents_CAEventClassDefn,
	                                     12, callbackFunction, callbackData,
	                                     enableCallbacks, callbackId);

	return __result;
}

HRESULT CVIFUNC SpeechLib__ISpeechRecoContextEventsRegOnRecognizerStateChange (CAObjHandle serverObject,
                                                                               _ISpeechRecoContextEventsRegOnRecognizerStateChange_CallbackType callbackFunction,
                                                                               void *callbackData,
                                                                               int enableCallbacks,
                                                                               int *callbackId)
{
	HRESULT __result = S_OK;

	__result = CA_RegisterEventCallback (serverObject,
	                                     &__ISpeechRecoContextEvents_CAEventClassDefn,
	                                     13, callbackFunction, callbackData,
	                                     enableCallbacks, callbackId);

	return __result;
}

HRESULT CVIFUNC SpeechLib__ISpeechRecoContextEventsRegOnAdaptation (CAObjHandle serverObject,
                                                                    _ISpeechRecoContextEventsRegOnAdaptation_CallbackType callbackFunction,
                                                                    void *callbackData,
                                                                    int enableCallbacks,
                                                                    int *callbackId)
{
	HRESULT __result = S_OK;

	__result = CA_RegisterEventCallback (serverObject,
	                                     &__ISpeechRecoContextEvents_CAEventClassDefn,
	                                     14, callbackFunction, callbackData,
	                                     enableCallbacks, callbackId);

	return __result;
}

HRESULT CVIFUNC SpeechLib__ISpeechRecoContextEventsRegOnRecognitionForOtherContext (CAObjHandle serverObject,
                                                                                    _ISpeechRecoContextEventsRegOnRecognitionForOtherContext_CallbackType callbackFunction,
                                                                                    void *callbackData,
                                                                                    int enableCallbacks,
                                                                                    int *callbackId)
{
	HRESULT __result = S_OK;

	__result = CA_RegisterEventCallback (serverObject,
	                                     &__ISpeechRecoContextEvents_CAEventClassDefn,
	                                     15, callbackFunction, callbackData,
	                                     enableCallbacks, callbackId);

	return __result;
}

HRESULT CVIFUNC SpeechLib__ISpeechRecoContextEventsRegOnAudioLevel (CAObjHandle serverObject,
                                                                    _ISpeechRecoContextEventsRegOnAudioLevel_CallbackType callbackFunction,
                                                                    void *callbackData,
                                                                    int enableCallbacks,
                                                                    int *callbackId)
{
	HRESULT __result = S_OK;

	__result = CA_RegisterEventCallback (serverObject,
	                                     &__ISpeechRecoContextEvents_CAEventClassDefn,
	                                     16, callbackFunction, callbackData,
	                                     enableCallbacks, callbackId);

	return __result;
}

HRESULT CVIFUNC SpeechLib__ISpeechRecoContextEventsRegOnEnginePrivate (CAObjHandle serverObject,
                                                                       _ISpeechRecoContextEventsRegOnEnginePrivate_CallbackType callbackFunction,
                                                                       void *callbackData,
                                                                       int enableCallbacks,
                                                                       int *callbackId)
{
	HRESULT __result = S_OK;

	__result = CA_RegisterEventCallback (serverObject,
	                                     &__ISpeechRecoContextEvents_CAEventClassDefn,
	                                     17, callbackFunction, callbackData,
	                                     enableCallbacks, callbackId);

	return __result;
}
